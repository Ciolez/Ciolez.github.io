<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>面渣逆袭-Java SE</title>
      <link href="/Blog/2023/03/25/interview/%E9%9D%A2%E6%B8%A3%E9%80%86%E8%A2%AD-Java%20SE/"/>
      <url>/Blog/2023/03/25/interview/%E9%9D%A2%E6%B8%A3%E9%80%86%E8%A2%AD-Java%20SE/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-概述"><a href="#Java-概述" class="headerlink" title="Java 概述"></a>Java 概述</h1><h2 id="什么是-Java？"><a href="#什么是-Java？" class="headerlink" title="什么是 Java？"></a>什么是 Java？</h2><p><img src="https://s2.loli.net/2023/03/25/QIy8PnJWDmFwfu4.png" alt="下辈子还学Java"></p><center>下辈子还学Java</center><p>PS：碎怂 Java，有啥好介绍的。哦，面试啊。</p><p>Java 是一门面向对象的编程语言，不仅吸收了 C++语言的各种优点，还摒弃了 C++里难以理解的多继承、指针等概念，因此 Java 语言具有功能强大和简单易用两个特征。Java 语言作为静态面向对象编程语言的优秀代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程 。</p><h2 id="Java-语言有哪些特点？"><a href="#Java-语言有哪些特点？" class="headerlink" title="Java 语言有哪些特点？"></a>Java 语言有哪些特点？</h2><p>Java 语言有很多优秀（可吹）的特点，以下几个是比较突出的：</p><p><img src="https://s2.loli.net/2023/03/25/WaFqbCT5gxBXizr.png" alt="Java语言特点"></p><center>Java语言特点</center><p>面向对象（封装，继承，多态）；</p><ul><li>平台无关性，平台无关性的具体表现在于，Java 是“一次编写，到处运行（Write Once，Run any Where）”的语言，因此采用 Java 语言编写的程序具有很好的可移植性，而保证这一点的正是 Java 的虚拟机机制。在引入虚拟机之后，Java 语言在不同的平台上运行不需要重新编译。</li><li>支持多线程。C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持；</li><li>编译与解释并存；</li></ul><h2 id="JVM、JDK-和-JRE-有什么区别？"><a href="#JVM、JDK-和-JRE-有什么区别？" class="headerlink" title="JVM、JDK 和 JRE 有什么区别？"></a>JVM、JDK 和 JRE 有什么区别？</h2><p><strong>JVM</strong>：Java Virtual Machine，Java 虚拟机，Java 程序运行在 Java 虚拟机上。针对不同系统的实现（Windows，Linux，macOS）不同的 JVM，因此 Java 语言可以实现跨平台。</p><p><strong>JRE</strong>： Java 运⾏时环境。它是运⾏已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，Java 命令和其他的⼀些基础构件。但是，它不能⽤于创建新程序。</p><p><strong>JDK</strong>: Java Development Kit，它是功能⻬全的 Java SDK。它拥有 JRE 所拥有的⼀切，还有编译器（javac）和⼯具（如 javadoc 和 jdb）。它能够创建和编译程序。</p><p>简单来说，JDK 包含 JRE，JRE 包含 JVM。</p><p><img src="https://s2.loli.net/2023/03/25/WpvRYwIc5NFjzbs.png" alt="JDK、JRE、JVM关系"></p><center>JDK、JRE、JVM关系</center><h2 id="说说什么是跨平台性？原理是什么"><a href="#说说什么是跨平台性？原理是什么" class="headerlink" title="说说什么是跨平台性？原理是什么"></a>说说什么是跨平台性？原理是什么</h2><p>所谓跨平台性，是指 Java 语言编写的程序，一次编译后，可以在多个系统平台上运行。</p><p>实现原理：Java 程序是通过 Java 虚拟机在系统平台上运行的，只要该系统可以安装相应的 Java 虚拟机，该系统就可以运行 java 程序。</p><h2 id="什么是字节码？采用字节码的好处是什么"><a href="#什么是字节码？采用字节码的好处是什么" class="headerlink" title="什么是字节码？采用字节码的好处是什么?"></a>什么是字节码？采用字节码的好处是什么?</h2><p>所谓的字节码，就是 Java 程序经过编译之类产生的.class 文件，字节码能够被虚拟机识别，从而实现 Java 程序的跨平台性。</p><p><strong>Java</strong> 程序从源代码到运行主要有三步：</p><ul><li><strong>编译</strong>：将我们的代码（.java）编译成虚拟机可以识别理解的字节码(.class)</li><li><strong>解释</strong>：虚拟机执行 Java 字节码，将字节码翻译成机器能识别的机器码</li><li><strong>执行</strong>：对应的机器执行二进制机器码</li></ul><p><img src="https://s2.loli.net/2023/03/25/dsaiNYbMrITCqWe.png" alt="Java程序执行过程"></p><center>Java程序执行过程</center><p>只需要把 Java 程序编译成 Java 虚拟机能识别的 Java 字节码，不同的平台安装对应的 Java 虚拟机，这样就可以可以实现 Java 语言的平台无关性。</p><h2 id="为什么说-Java-语言“编译与解释并存”？"><a href="#为什么说-Java-语言“编译与解释并存”？" class="headerlink" title="为什么说 Java 语言“编译与解释并存”？"></a>为什么说 Java 语言“编译与解释并存”？</h2><p>高级编程语言按照程序的执行方式分为<strong>编译型</strong>和<strong>解释型</strong>两种。</p><p>简单来说，编译型语言是指编译器针对特定的操作系统将源代码一次性翻译成可被该平台执行的机器码；解释型语言是指解释器对源程序逐行解释成特定平台的机器码并立即执行。</p><p>比如，你想读一本外国的小说，你可以找一个翻译人员帮助你翻译，有两种选择方式，你可以先等翻译人员将全本的小说（也就是源码）都翻译成汉语，再去阅读，也可以让翻译人员翻译一段，你在旁边阅读一段，慢慢把书读完。</p><p>Java 语言既具有编译型语言的特征，也具有解释型语言的特征，因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（<code>\*.class</code> 文件），这种字节码必须再经过 JVM，解释成操作系统能识别的机器码，在由操作系统执行。因此，我们可以认为 Java 语言<strong>编译</strong>与<strong>解释</strong>并存。</p><p><img src="https://s2.loli.net/2023/03/25/e8pcbTFuf3Xl2Nd.png" alt="编译与解释"><center>编译与解释</center></p><h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="Java-有哪些数据类型？"><a href="#Java-有哪些数据类型？" class="headerlink" title="Java 有哪些数据类型？"></a>Java 有哪些数据类型？</h2><p><strong>定义：</strong>Java 语言是强类型语言，对于每一种数据都定义了明确的具体的数据类型，在内存中分配了不同大小的内存空间。</p><p>Java 语言数据类型分为两种：<strong>基本数据类型</strong>和<strong>引用数据类型</strong>。</p><p><img src="https://s2.loli.net/2023/03/25/Jwcrf1LRy9jSx8t.png" alt="Java数据类型"></p><center>Java数据类型</center><p><strong>基本数据类型：</strong></p><ul><li>数值型<ul><li>整数类型（byte、short、int、long）</li><li>浮点类型（float、double）</li></ul></li><li>字符型（char）</li><li>布尔型（boolean）</li></ul><p>Java 基本数据类型范围和默认值：</p><table><thead><tr><th>基本类型</th><th>位数</th><th>字节</th><th>默认值</th></tr></thead><tbody><tr><td><code>int</code></td><td>32</td><td>4</td><td>0</td></tr><tr><td><code>short</code></td><td>16</td><td>2</td><td>0</td></tr><tr><td><code>long</code></td><td>64</td><td>8</td><td>0L</td></tr><tr><td><code>byte</code></td><td>8</td><td>1</td><td>0</td></tr><tr><td><code>char</code></td><td>16</td><td>2</td><td>‘u0000’</td></tr><tr><td><code>float</code></td><td>32</td><td>4</td><td>0f</td></tr><tr><td><code>double</code></td><td>64</td><td>8</td><td>0d</td></tr><tr><td><code>boolean</code></td><td>1</td><td></td><td>false</td></tr></tbody></table><p><strong>引用数据类型：</strong></p><ul><li>类（class）</li><li>接口（interface）</li><li>数组([])</li></ul><h2 id="自动类型转换、强制类型转换？看看这几行代码？"><a href="#自动类型转换、强制类型转换？看看这几行代码？" class="headerlink" title="自动类型转换、强制类型转换？看看这几行代码？"></a>自动类型转换、强制类型转换？看看这几行代码？</h2><p>Java 所有的数值型变量可以相互转换，当把一个表数范围小的数值或变量直接赋给另一个表数范围大的变量时，可以进行自动类型转换；反之，需要强制转换。</p><p><img src="https://s2.loli.net/2023/03/25/EjDO1Z8GTtk7mIK.png" alt="Java自动类型转换方向"><center>Java自动类型转换方向</center></p><p>这就好像，小杯里的水倒进大杯没问题，但大杯的水倒进小杯就不行了，可能会溢出。</p><blockquote><p><code>float f=3.4</code>，对吗？</p></blockquote><p>不正确。3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换<code>float f =(float)3.4;</code>或者写成<code>float f =3.4F</code></p><blockquote><p><code>short s1 = 1; s1 = s1 + 1；</code>对吗？<code>short s1 = 1; s1 += 1;</code>对吗？</p></blockquote><p>对于 short s1 &#x3D; 1; s1 &#x3D; s1 + 1;编译出错，由于 1 是 int 类型，因此 s1+1 运算结果也是 int 型，需要强制转换类型才能赋值给 short 型。</p><p>而 short s1 &#x3D; 1; s1 +&#x3D; 1;可以正确编译，因为 s1+&#x3D; 1;相当于 s1 &#x3D; (short(s1 + 1);其中有隐含的强制类型转换。</p><h2 id="什么是自动拆箱-x2F-封箱？"><a href="#什么是自动拆箱-x2F-封箱？" class="headerlink" title="什么是自动拆箱&#x2F;封箱？"></a>什么是自动拆箱&#x2F;封箱？</h2><ul><li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li><li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li></ul><p>Java 可以自动对基本数据类型和它们的包装类进行装箱和拆箱。</p><p><img src="https://s2.loli.net/2023/03/25/uqNUcS2FdwYnvBp.png" alt="装箱和拆箱"></p><center>装箱和拆箱</center><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;  <span class="comment">//装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i;   <span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure><h2 id="amp-和-amp-amp-有什么区别？"><a href="#amp-和-amp-amp-有什么区别？" class="headerlink" title="&amp;和&amp;&amp;有什么区别？"></a>&amp;和&amp;&amp;有什么区别？</h2><p>&amp;运算符有两种用法：<code>短路与</code>、<code>逻辑与</code>。</p><p>&amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是 true 整个表达式的值才是 true。</p><p>&amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用&amp;&amp;而不是&amp;。</p><p>例如在验证用户登录时判定用户名不是 null 而且不是空字符串，应当写为<code>username != null &amp;&amp;!username.equals(&quot;&quot;)</code>，二者的顺序不能交换，更不能用&amp;运算符，因为第一个条件如果不成立，根本不能进行字符串的 equals 比较，否则会产生 NullPointerException 异常。</p><p><strong>注意</strong>：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。</p><h2 id="switch-是否能作用在-byte-x2F-long-x2F-String-上？"><a href="#switch-是否能作用在-byte-x2F-long-x2F-String-上？" class="headerlink" title="switch 是否能作用在 byte&#x2F;long&#x2F;String 上？"></a>switch 是否能作用在 byte&#x2F;long&#x2F;String 上？</h2><p>Java5 以前 switch(expr)中，expr 只能是 byte、short、char、int。</p><p>从 Java 5 开始，Java 中引入了枚举类型， expr 也可以是 enum 类型。</p><p>从 Java 7 开始，expr 还可以是字符串(String)，但是长整型(long)在目前所有的版本中都是不可以的。</p><h2 id="break-continue-return-的区别及作用？"><a href="#break-continue-return-的区别及作用？" class="headerlink" title="break ,continue ,return 的区别及作用？"></a>break ,continue ,return 的区别及作用？</h2><ul><li>break 跳出整个循环，不再执行循环(<strong>结束当前的循环体</strong>)</li><li>continue 跳出本次循环，继续执行下次循环(<strong>结束正在执行的循环 进入下一个循环条件</strong>)</li><li>return 程序返回，不再执行下面的代码(<strong>结束当前的方法 直接返回</strong>)</li></ul><p><img src="https://s2.loli.net/2023/03/25/OFBd6CnD1gM8vj7.png" alt="break 、continue 、return"></p><center>break 、continue 、return</center><h2 id="用最有效率的方法计算-2-乘以-8？"><a href="#用最有效率的方法计算-2-乘以-8？" class="headerlink" title="用最有效率的方法计算 2 乘以 8？"></a>用最有效率的方法计算 2 乘以 8？</h2><p>2 &lt;&lt; 3。<strong>位运算</strong>，数字的二进制位左移三位相当于乘以 2 的三次方。</p><h2 id="说说自增自减运算？看下这几个代码运行结果？"><a href="#说说自增自减运算？看下这几个代码运行结果？" class="headerlink" title="说说自增自减运算？看下这几个代码运行结果？"></a>说说自增自减运算？看下这几个代码运行结果？</h2><p>在写代码的过程中，常见的一种情况是需要某个整数类型变量增加 1 或减少 1，Java 提供了一种特殊的运算符，用于这种表达式，叫做自增运算符（++)和自减运算符（–）。</p><p>++和–运算符可以放在变量之前，也可以放在变量之后。</p><p>当运算符放在变量之前时(前缀)，先自增&#x2F;减，再赋值；当运算符放在变量之后时(后缀)，先赋值，再自增&#x2F;减。</p><p>例如，当 <code>b = ++a</code> 时，先自增（自己增加 1），再赋值（赋值给 b）；当 <code>b = a++</code> 时，先赋值(赋值给 b)，再自增（自己增加 1）。也就是，++a 输出的是 a+1 的值，a++输出的是 a 值。</p><p>用一句口诀就是：“符号在前就先加&#x2F;减，符号在后就后加&#x2F;减”。</p><blockquote><p>看一下这段代码运行结果？</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span>  <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">i = i++;</span><br><span class="line">System.out.println(i);</span><br></pre></td></tr></table></figure><p>答案是 1。有点离谱对不对。</p><p>对于 JVM 而言，它对自增运算的处理，是会先定义一个临时变量来接收 i 的值，然后进行自增运算，最后又将临时变量赋给了值为 2 的 i，所以最后的结果为 1。</p><p>相当于这样的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>；</span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i;</span><br><span class="line">i++；</span><br><span class="line">i = temp;</span><br><span class="line">System.out.println(i);</span><br></pre></td></tr></table></figure><blockquote><p>这段代码会输出什么？</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">100</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    count = count++;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;count = &quot;</span>+count);</span><br></pre></td></tr></table></figure><p>答案是 0。</p><p>和上面的题目一样的道理，同样是用了临时变量，count 实际是等于临时变量的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">autoAdd</span><span class="params">(<span class="type">int</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> count;</span><br><span class="line">    count = coutn + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：笔试面试可能会碰到的奇葩题，开发这么写，见一次吊一次。</p><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="⾯向对象和⾯向过程的区别"><a href="#⾯向对象和⾯向过程的区别" class="headerlink" title="⾯向对象和⾯向过程的区别?"></a>⾯向对象和⾯向过程的区别?</h2><ul><li><strong>⾯向过程</strong> ：面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的一次调用就可以。</li><li><strong>⾯向对象</strong> ：面向对象，把构成问题的事务分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事件在解决整个问题的过程所发生的行为。 目的是为了写出通用的代码，加强代码的重用，屏蔽差异性。</li></ul><p>用一个比喻：面向过程是编年体；面向对象是纪传体。</p><p><img src="https://s2.loli.net/2023/03/25/EeSzF5ZUXgNyWk7.png" alt="面向对象和面向过程的区别"></p><center>面向对象和面向过程的区别</center><h2 id="面向对象有哪些特性"><a href="#面向对象有哪些特性" class="headerlink" title="面向对象有哪些特性"></a>面向对象有哪些特性</h2><p><img src="https://s2.loli.net/2023/03/25/ILcC43QerKxj69Y.png" alt="面向对象三大特征"></p><center>面向对象三大特征</center><ul><li><p><strong>封装</strong></p><p>封装把⼀个对象的属性私有化，同时提供⼀些可以被外界访问的属性的⽅法。</p></li><li><p><strong>继承</strong></p><p>继承是使⽤已存在的类的定义作为基础创建新的类，新类的定义可以增加新的属性或新的方法，也可以继承父类的属性和方法。通过继承可以很方便地进行代码复用。</p></li></ul><blockquote><p>关于继承有以下三个要点：</p></blockquote><ol><li>⼦类拥有⽗类对象所有的属性和⽅法（包括私有属性和私有⽅法），但是⽗类中的私有属性和⽅法⼦类是⽆法访问，只是拥有。</li><li>⼦类可以拥有⾃⼰属性和⽅法，即⼦类可以对⽗类进⾏扩展。</li><li>⼦类可以⽤⾃⼰的⽅式实现⽗类的⽅法。</li></ol><ul><li><p><strong>多态</strong></p><p>所谓多态就是指程序中定义的引⽤变量所指向的具体类型和通过该引⽤变量发出的⽅法调⽤在编程时并不确定，⽽是在程序运⾏期间才确定，即⼀个引⽤变量到底会指向哪个类的实例对象，该引⽤变量发出的⽅法调⽤到底是哪个类中实现的⽅法，必须在由程序运⾏期间才能决定。</p><p>在 Java 中有两种形式可以实现多态：继承（多个⼦类对同⼀⽅法的重写）和接⼝（实现接⼝并覆盖接⼝中同⼀⽅法）。</p></li></ul><h2 id="重载（overload）和重写（override）的区别？"><a href="#重载（overload）和重写（override）的区别？" class="headerlink" title="重载（overload）和重写（override）的区别？"></a>重载（overload）和重写（override）的区别？</h2><p>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。</p><ul><li>重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；</li><li>重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。</li></ul><p>方法重载的规则：</p><ol><li>方法名一致，参数列表中参数的顺序，类型，个数不同。</li><li>重载与方法的返回值无关，存在于父类和子类，同类中。</li><li>可以抛出不同的异常，可以有不同修饰符。</li></ol><h2 id="访问修饰符-public、private、protected、以及不写（默认）时的区别？"><a href="#访问修饰符-public、private、protected、以及不写（默认）时的区别？" class="headerlink" title="访问修饰符 public、private、protected、以及不写（默认）时的区别？"></a>访问修饰符 public、private、protected、以及不写（默认）时的区别？</h2><p>Java 中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。</p><ul><li><strong>default</strong> (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。可以修饰在类、接口、变量、方法。</li><li><strong>private</strong> : 在同一类内可见。可以修饰变量、方法。<strong>注意：不能修饰类（外部类）</strong></li><li><strong>public</strong> : 对所有类可见。可以修饰类、接口、变量、方法</li><li><strong>protected</strong> : 对同一包内的类和所有子类可见。可以修饰变量、方法。<strong>注意：不能修饰类（外部类）</strong>。</li></ul><p><img src="https://s2.loli.net/2023/03/25/5bmp4xKCsTWfDYS.png" alt="访问修饰符和可见性"></p><center>访问修饰符和可见性</center><h2 id="this-关键字有什么作用？"><a href="#this-关键字有什么作用？" class="headerlink" title="this 关键字有什么作用？"></a>this 关键字有什么作用？</h2><p>this 是自身的一个对象，代表对象本身，可以理解为：<strong>指向对象本身的一个指针</strong>。</p><p>this 的用法在 Java 中大体可以分为 3 种：</p><ol><li>普通的直接引用，this 相当于是指向当前对象本身</li><li>形参与成员变量名字重名，用 this 来区分：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name=name;</span><br><span class="line">    <span class="built_in">this</span>.age=age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>引用本类的构造函数</li></ol><h2 id="抽象类-abstract-class-和接口-interface-有什么区别？"><a href="#抽象类-abstract-class-和接口-interface-有什么区别？" class="headerlink" title="抽象类(abstract class)和接口(interface)有什么区别？"></a>抽象类(abstract class)和接口(interface)有什么区别？</h2><ol><li>接⼝的⽅法默认是 public ，所有⽅法在接⼝中不能有实现(Java 8 开始接⼝⽅法可以有默认实现），⽽抽象类可以有⾮抽象的⽅法。</li><li>接⼝中除了 static 、 final 变量，不能有其他变量，⽽抽象类中则不⼀定。</li><li>⼀个类可以实现多个接⼝，但只能实现⼀个抽象类。接⼝⾃⼰本身可以通过 extends 关键字扩展多个接⼝。</li><li>接⼝⽅法默认修饰符是 public ，抽象⽅法可以有 public 、 protected 和 default 这些修饰符（抽象⽅法就是为了被重写所以不能使⽤ private 关键字修饰！）。</li><li>从设计层⾯来说，抽象是对类的抽象，是⼀种模板设计，⽽接⼝是对⾏为的抽象，是⼀种⾏为的规范。</li></ol><blockquote><ol><li>在 JDK8 中，接⼝也可以定义静态⽅法，可以直接⽤接⼝名调⽤。实现类和实现是不可以调⽤的。如果同时实现两个接⼝，接⼝中定义了⼀样的默认⽅法，则必须重写，不然会报错。</li><li>jdk9 的接⼝被允许定义私有⽅法 。</li></ol></blockquote><p>总结⼀下 jdk7~jdk9 Java 中接⼝的变化：</p><ol><li>在 jdk 7 或更早版本中，接⼝⾥⾯只能有常量变量和抽象⽅法。这些接⼝⽅法必须由选择实现接⼝的类实现。</li><li>jdk 8 的时候接⼝可以有默认⽅法和静态⽅法功能。</li><li>jdk 9 在接⼝中引⼊了私有⽅法和私有静态⽅法。</li></ol><h2 id="成员变量与局部变量的区别有哪些？"><a href="#成员变量与局部变量的区别有哪些？" class="headerlink" title="成员变量与局部变量的区别有哪些？"></a>成员变量与局部变量的区别有哪些？</h2><ol><li><strong>从语法形式上看</strong>：成员变量是属于类的，⽽局部变量是在⽅法中定义的变量或是⽅法的参数；成员变量可以被 public , private , static 等修饰符所修饰，⽽局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。</li><li><strong>从变量在内存中的存储⽅式来看</strong>：如果成员变量是使⽤ static 修饰的，那么这个成员变量是属于类的，如果没有使⽤ static 修饰，这个成员变量是属于实例的。对象存于堆内存，如果局部变量类型为基本数据类型，那么存储在栈内存，如果为引⽤数据类型，那存放的是指向堆内存对象的引⽤或者是指向常量池中的地址。</li><li><strong>从变量在内存中的⽣存时间上看</strong>：成员变量是对象的⼀部分，它随着对象的创建⽽存在，⽽局部变量随着⽅法的调⽤⽽⾃动消失。</li><li><strong>成员变量如果没有被赋初值</strong>：则会⾃动以类型的默认值⽽赋值（⼀种情况例外:被 final 修饰的成员变量也必须显式地赋值），⽽局部变量则不会⾃动赋值。</li></ol><h2 id="静态变量和实例变量的区别？静态方法、实例方法呢？"><a href="#静态变量和实例变量的区别？静态方法、实例方法呢？" class="headerlink" title="静态变量和实例变量的区别？静态方法、实例方法呢？"></a>静态变量和实例变量的区别？静态方法、实例方法呢？</h2><blockquote><p>静态变量和实例变量的区别？</p></blockquote><p><strong>静态变量:</strong> 是被 static 修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个副本。</p><p><strong>实例变量:</strong> 必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。</p><blockquote><p>静态⽅法和实例⽅法有何不同?</p></blockquote><p>类似地。</p><p><strong>静态方法</strong>：static 修饰的方法，也被称为类方法。在外部调⽤静态⽅法时，可以使⽤”<strong>类名.⽅法名</strong>“的⽅式，也可以使⽤”<strong>对象名.⽅法名</strong>“的⽅式。静态方法里不能访问类的非静态成员变量和方法。</p><p><strong>实例⽅法</strong>：依存于类的实例，需要使用”<strong>对象名.⽅法名</strong>“的⽅式调用；可以访问类的所有成员变量和方法。</p><h2 id="final-关键字有什么作用？"><a href="#final-关键字有什么作用？" class="headerlink" title="final 关键字有什么作用？"></a>final 关键字有什么作用？</h2><p>final 表示不可变的意思，可用于修饰类、属性和方法：</p><ul><li><p>被 final 修饰的类不可以被继承</p></li><li><p>被 final 修饰的方法不可以被重写</p></li><li><p>被 final 修饰的变量不可变，被 final 修饰的变量必须被显式第指定初始值，还得注意的是，这里的不可变指的是变量的引用不可变，不是引用指向的内容的不可变。</p><p>例如：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">sb.append(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">System.out.println(sb);  <span class="comment">//abcd</span></span><br></pre></td></tr></table></figure><p>一张图说明：</p><p><img src="https://s2.loli.net/2023/03/25/y4c1REeQd7TK9Sq.png" alt="final修饰变量"></p><center>final修饰变量</center><h2 id="final、finally、finalize-的区别？"><a href="#final、finally、finalize-的区别？" class="headerlink" title="final、finally、finalize 的区别？"></a>final、finally、finalize 的区别？</h2><ul><li><p>final 用于修饰变量、方法和类：final 修饰的类不可被继承；修饰的方法不可被重写；修饰的变量不可变。</p></li><li><p>finally 作为异常处理的一部分，它只能在 <code>try/catch</code> 语句中，并且附带一个语句块表示这段语句最终一定被执行（无论是否抛出异常），经常被用在需要释放资源的情况下，<code>System.exit (0)</code> 可以阻断 finally 执行。</p></li><li><p>finalize 是在 <code>java.lang.Object</code> 里定义的方法，也就是说每一个对象都有这么个方法，这个方法在 <code>gc</code> 启动，该对象被回收的时候被调用。</p><p>一个对象的 finalize 方法只会被调用一次，finalize 被调用不一定会立即回收该对象，所以有可能调用 finalize 后，该对象又不需要被回收了，然后到了真正要被回收的时候，因为前面调用过一次，所以不会再次调用 finalize 了，进而产生问题，因此不推荐使用 finalize 方法。</p></li></ul><h2 id="x3D-x3D-和-equals-的区别？"><a href="#x3D-x3D-和-equals-的区别？" class="headerlink" title="&#x3D;&#x3D;和 equals 的区别？"></a>&#x3D;&#x3D;和 equals 的区别？</h2><p><strong>&#x3D;&#x3D;</strong> : 它的作⽤是判断两个对象的地址是不是相等。即，判断两个对象是不是同⼀个对象(基本数据类型 <strong>&#x3D;&#x3D;</strong> 比较的是值，引⽤数据类型 <strong>&#x3D;&#x3D;</strong> 比较的是内存地址)。</p><p><strong>equals()</strong> : 它的作⽤也是判断两个对象是否相等。但是这个“相等”一般也分两种情况：</p><ul><li>默认情况：类没有覆盖 equals() ⽅法。则通过 equals() 比较该类的两个对象时，等价于通过“ <strong>&#x3D;&#x3D;</strong> ”比较这两个对象，还是相当于比较内存地址。</li><li>自定义情况：类覆盖了 equals() ⽅法。我们平时覆盖的 equals()方法一般是比较两个对象的内容是否相同，自定义了一个相等的标准，也就是两个对象的值是否相等。</li></ul><p>举个例⼦，Person，我们认为两个人的编号和姓名相同，就是一个人：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String no;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Person)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) o;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(no, person.no) &amp;&amp;</span><br><span class="line">                Objects.equals(name, person.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(no, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="hashCode-与-equals"><a href="#hashCode-与-equals" class="headerlink" title="hashCode 与 equals?"></a>hashCode 与 equals?</h2><p>这个也是面试常问——“你重写过 hashcode 和 equals 么，为什么重写 equals 时必须重写 hashCode ⽅法？”</p><blockquote><p>什么是 HashCode？</p></blockquote><p>hashCode() 的作⽤是获取哈希码，也称为散列码；它实际上是返回⼀个 int 整数，定义在 Object 类中， 是一个本地⽅法，这个⽅法通常⽤来将对象的内存地址转换为整数之后返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>哈希码主要在哈希表这类集合映射的时候用到，哈希表存储的是键值对(key-value)，它的特点是：能根据“键”快速的映射到对应的“值”。这其中就利⽤到了哈希码！</p><blockquote><p>为什么要有 hashCode？</p></blockquote><p>上面已经讲了，主要是在哈希表这种结构中用的到。</p><p>例如 HashMap 怎么把 key 映射到对应的 value 上呢？用的就是哈希取余法，也就是拿哈希码和存储元素的数组的长度取余，获取 key 对应的 value 所在的下标位置。</p><blockquote><p>为什么重写 quals 时必须重写 hashCode ⽅法？</p></blockquote><p>如果两个对象相等，则 hashcode ⼀定也是相同的。两个对象相等，对两个对象分别调⽤ equals ⽅法都返回 true。反之，两个对象有相同的 hashcode 值，它们也不⼀定是相等的 。因此，<strong>equals</strong> ⽅法被覆盖过，则 <strong>hashCode</strong> ⽅法也必须被覆盖。</p><p>hashCode() 的默认⾏为是对堆上的对象产⽣独特值。如果没有重写 hashCode() ，则该 class 的两个对象⽆论如何都不会相等（即使这两个对象指向相同的数据）</p><blockquote><p>为什么两个对象有相同的 hashcode 值，它们也不⼀定是相等的？</p></blockquote><p>因为可能会<strong>碰撞</strong>， hashCode() 所使⽤的散列算法也许刚好会让多个对象传回相同的散列值。越糟糕的散列算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 hashCode ）。</p><h2 id="Java-是值传递，还是引用传递？"><a href="#Java-是值传递，还是引用传递？" class="headerlink" title="Java 是值传递，还是引用传递？"></a>Java 是值传递，还是引用传递？</h2><p>Java 语言是<strong>值传递</strong>。Java 语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的。</p><p>JVM 的内存分为堆和栈，其中栈中存储了基本数据类型和引用数据类型实例的地址，也就是对象地址。</p><p>而对象所占的空间是在堆中开辟的，所以传递的时候可以理解为把变量存储的对象地址给传递过去，因此引用类型也是值传递。</p><p>![Java引用数据值传递示意图](<a href="https://s2.loli.net/2023/03/25/XE8aDYhZfG93V16.png">https://s2.loli.net/2023/03/25/XE8aDYhZfG93V16.png</a><center>Java引用数据值传递示意图</center></p><h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝?"></a>深拷贝和浅拷贝?</h2><ul><li><strong>浅拷贝</strong>：仅拷贝被拷贝对象的成员变量的值，也就是基本数据类型变量的值，和引用数据类型变量的地址值，而对于引用类型变量指向的堆中的对象不会拷贝。</li><li><strong>深拷贝</strong>：完全拷贝一个对象，拷贝被拷贝对象的成员变量的值，堆中的对象也会拷贝一份。</li></ul><p>例如现在有一个 order 对象，里面有一个 products 列表，它的浅拷贝和深拷贝的示意图：</p><p><img src="https://s2.loli.net/2023/03/25/SWNerYqUVjfv5Gk.png" alt="浅拷贝和深拷贝示意图"></p><center>浅拷贝和深拷贝示意图</center><p>因此深拷贝是安全的，浅拷贝的话如果有引用类型，那么拷贝后对象，引用类型变量修改，会影响原对象。</p><blockquote><p>浅拷贝如何实现呢？</p></blockquote><p>Object 类提供的 clone()方法可以非常简单地实现对象的浅拷贝。</p><blockquote><p>深拷贝如何实现呢？</p></blockquote><ul><li>重写克隆方法：重写克隆方法，引用类型变量单独克隆，这里可能会涉及多层递归。</li><li>序列化：可以先将原对象序列化，再反序列化成拷贝对象。</li></ul><h2 id="Java-创建对象有哪几种方式？"><a href="#Java-创建对象有哪几种方式？" class="headerlink" title="Java 创建对象有哪几种方式？"></a>Java 创建对象有哪几种方式？</h2><p>Java 中有以下四种创建对象的方式:</p><p><img src="https://s2.loli.net/2023/03/25/SrT7zsNOxcidPkM.png" alt="Java创建对象的四种方式"></p><center>Java创建对象的四种方式</center><ul><li>new 创建新对象</li><li>通过反射机制</li><li>采用 clone 机制</li><li>通过序列化机制</li></ul><p>前两者都需要显式地调用构造方法。对于 clone 机制,需要注意浅拷贝和深拷贝的区别，对于序列化机制需要明确其实现原理，在 Java 中序列化可以通过实现 Externalizable 或者 Serializable 来实现。</p><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h2 id="String-是-Java-基本数据类型吗？可以被继承吗？"><a href="#String-是-Java-基本数据类型吗？可以被继承吗？" class="headerlink" title="String 是 Java 基本数据类型吗？可以被继承吗？"></a>String 是 Java 基本数据类型吗？可以被继承吗？</h2><blockquote><p>String 是 Java 基本数据类型吗？</p></blockquote><p>不是。Java 中的基本数据类型只有 8 个：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type），剩下的都是引用类型（reference type）。</p><p>String 是一个比较特殊的引用数据类型。</p><blockquote><p>String 类可以继承吗？</p></blockquote><p>不行。String 类使用 final 修饰，是所谓的不可变类，无法被继承。</p><h2 id="String-和-StringBuilder、StringBuffer-的区别？"><a href="#String-和-StringBuilder、StringBuffer-的区别？" class="headerlink" title="String 和 StringBuilder、StringBuffer 的区别？"></a>String 和 StringBuilder、StringBuffer 的区别？</h2><ul><li>String：String 的值被创建后不能修改，任何对 String 的修改都会引发新的 String 对象的生成。</li><li>StringBuffer：跟 String 类似，但是值可以被修改，使用 synchronized 来保证线程安全。</li><li>StringBuilder：StringBuffer 的非线程安全版本，性能上更高一些。</li></ul><h2 id="String-str1-x3D-new-String-“abc”-和-String-str2-x3D-“abc”-和-区别？"><a href="#String-str1-x3D-new-String-“abc”-和-String-str2-x3D-“abc”-和-区别？" class="headerlink" title="String str1 &#x3D; new String(“abc”)和 String str2 &#x3D; “abc” 和 区别？"></a>String str1 &#x3D; new String(“abc”)和 String str2 &#x3D; “abc” 和 区别？</h2><p>两个语句都会去字符串常量池中检查是否已经存在 “abc”，如果有则直接使用，如果没有则会在常量池中创建 “abc” 对象。</p><p><img src="https://s2.loli.net/2023/03/25/v1IJW9hQDg4zwSK.png" alt="堆与常量池中的String"></p><center>堆与常量池中的String</center><p>但是不同的是，String str1 &#x3D; new String(“abc”) 还会通过 new String() 在堆里创建一个 “abc” 字符串对象实例。所以后者可以理解为被前者包含。</p><blockquote><p>String s &#x3D; new String(“abc”)创建了几个对象？</p></blockquote><p>很明显，一个或两个。如果字符串常量池已经有“abc”，则是一个；否则，两个。</p><p>当字符创常量池没有 “abc”，此时会创建如下两个对象：</p><ul><li>一个是字符串字面量 “abc” 所对应的、字符串常量池中的实例</li><li>另一个是通过 new String() 创建并初始化的，内容与”abc”相同的实例，在堆中。</li></ul><h2 id="String-不是不可变类吗？字符串拼接是如何实现的？"><a href="#String-不是不可变类吗？字符串拼接是如何实现的？" class="headerlink" title="String 不是不可变类吗？字符串拼接是如何实现的？"></a>String 不是不可变类吗？字符串拼接是如何实现的？</h2><p>String 的确是不可变的，“**+**”的拼接操作，其实是会生成新的对象。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;hello &quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;world!&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">ab</span> <span class="operator">=</span> a + b;</span><br></pre></td></tr></table></figure><p>在<strong>jdk1.8 之前</strong>，a 和 b 初始化时位于字符串常量池，ab 拼接后的对象位于堆中。经过拼接新生成了 String 对象。如果拼接多次，那么会生成多个中间对象。</p><p>内存如下：</p><p><img src="https://s2.loli.net/2023/03/25/H7wxdj2S36rlmzu.png" alt="jdk1.8之前的字符串拼接"></p><center>jdk1.8之前的字符串拼接</center><p>在<strong>Java8 时</strong>JDK 对“+”号拼接进行了优化，上面所写的拼接方式会被优化为基于 StringBuilder 的 append 方法进行处理。Java 会在编译期对“+”号进行处理。</p><p>下面是通过 javap -verbose 命令反编译字节码的结果，很显然可以看到 StringBuilder 的创建和 append 方法的调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">stack=<span class="number">2</span>, locals=<span class="number">4</span>, args_size=<span class="number">1</span></span><br><span class="line">     <span class="number">0</span>: ldc           #<span class="number">2</span>                  <span class="comment">// String hello</span></span><br><span class="line">     <span class="number">2</span>: astore_1</span><br><span class="line">     <span class="number">3</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String world!</span></span><br><span class="line">     <span class="number">5</span>: astore_2</span><br><span class="line">     <span class="number">6</span>: <span class="keyword">new</span>           #<span class="number">4</span>                  <span class="comment">// class java/lang/StringBuilder</span></span><br><span class="line">     <span class="number">9</span>: dup</span><br><span class="line">    <span class="number">10</span>: invokespecial #<span class="number">5</span>                  <span class="comment">// Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">    <span class="number">13</span>: aload_1</span><br><span class="line">    <span class="number">14</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">    <span class="number">17</span>: aload_2</span><br><span class="line">    <span class="number">18</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">    <span class="number">21</span>: invokevirtual #<span class="number">7</span>                  <span class="comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br><span class="line">    <span class="number">24</span>: astore_3</span><br><span class="line">    <span class="number">25</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>也就是说其实上面的代码其实相当于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;hello &quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;world!&quot;</span>;</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">sb.append(a);</span><br><span class="line">sb.append(b);</span><br><span class="line"><span class="type">String</span> <span class="variable">ab</span> <span class="operator">=</span> sb.toString();</span><br></pre></td></tr></table></figure><p>此时，如果再笼统的回答：通过加号拼接字符串会创建多个 String 对象，因此性能比 StringBuilder 差，就是错误的了。因为本质上加号拼接的效果最终经过编译器处理之后和 StringBuilder 是一致的。</p><p>当然，循环里拼接还是建议用 StringBuilder，为什么，因为循环一次就会创建一个新的 StringBuilder 对象，大家可以自行实验。</p><h2 id="intern-方法有什么作用？"><a href="#intern-方法有什么作用？" class="headerlink" title="intern 方法有什么作用？"></a>intern 方法有什么作用？</h2><p>JDK 源码里已经对这个方法进行了说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* &lt;p&gt;</span><br><span class="line">* When the intern method is invoked, <span class="keyword">if</span> the pool already contains a</span><br><span class="line">* string equal to <span class="built_in">this</span> &#123;<span class="meta">@code</span> String&#125; object as determined by</span><br><span class="line">* the &#123;<span class="meta">@link</span> #equals(Object)&#125; method, then the string from the pool is</span><br><span class="line">* returned. Otherwise, <span class="built_in">this</span> &#123;<span class="meta">@code</span> String&#125; object is added to the</span><br><span class="line">* pool and a reference to <span class="built_in">this</span> &#123;<span class="meta">@code</span> String&#125; object is returned.</span><br><span class="line">* &lt;p&gt;</span><br></pre></td></tr></table></figure><p>意思也很好懂：</p><ul><li>如果当前字符串内容存在于字符串常量池（即 equals()方法为 true，也就是内容一样），直接返回字符串常量池中的字符串</li><li>否则，将此 String 对象添加到池中，并返回 String 对象的引用</li></ul><h1 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h1><h2 id="Integer-a-x3D-127，Integer-b-x3D-127；Integer-c-x3D-128，Integer-d-x3D-128；，相等吗"><a href="#Integer-a-x3D-127，Integer-b-x3D-127；Integer-c-x3D-128，Integer-d-x3D-128；，相等吗" class="headerlink" title="Integer a&#x3D; 127，Integer b &#x3D; 127；Integer c&#x3D; 128，Integer d &#x3D; 128；，相等吗?"></a>Integer a&#x3D; 127，Integer b &#x3D; 127；Integer c&#x3D; 128，Integer d &#x3D; 128；，相等吗?</h2><p>答案是 a 和 b 相等，c 和 d 不相等。</p><ul><li>对于基本数据类型&#x3D;&#x3D;比较的值</li><li>对于引用数据类型&#x3D;&#x3D;比较的是地址</li></ul><p>Integer a&#x3D; 127 这种赋值，是用到了 Integer 自动装箱的机制。自动装箱的时候会去缓存池里取 Integer 对象，没有取到才会创建新的对象。</p><p>如果整型字面量的值在-128 到 127 之间，那么自动装箱时不会 new 新的 Integer 对象，而是直接引用缓存池中的 Integer 对象，超过范围 a1&#x3D;&#x3D;b1 的结果是 false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">127</span>);</span><br><span class="line">    System.out.println(a == b); <span class="comment">//true</span></span><br><span class="line">    System.out.println(b==b1);  <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">    System.out.println(c == d);  <span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>什么是 Integer 缓存？</p></blockquote><p>因为根据实践发现大部分的数据操作都集中在值比较小的范围，因此 Integer 搞了个缓存池，默认范围是 -128 到 127，可以根据通过设置<code>JVM-XX:AutoBoxCacheMax=</code>来修改缓存的最大值，最小值改不了。</p><p>实现的原理是 int 在自动装箱的时候会调用 Integer.valueOf，进而用到了 IntegerCache。</p><p><img src="https://s2.loli.net/2023/03/25/rDbxMkK2l9mCQOS.png" alt="Integer.valueOf"></p><center>Integer.valueOf</center><p>很简单，就是判断下值是否在缓存范围之内，如果是的话去 IntegerCache 中取，不是的话就创建一个新的 Integer 对象。</p><p>IntegerCache 是一个静态内部类， 在静态块中会初始化好缓存值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123;</span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">           <span class="comment">//创建Integer对象存储</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">               cache[k] = <span class="keyword">new</span> <span class="title class_">Integer</span>(j++);</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="String-怎么转成-Integer-的？原理？"><a href="#String-怎么转成-Integer-的？原理？" class="headerlink" title="String 怎么转成 Integer 的？原理？"></a>String 怎么转成 Integer 的？原理？</h2><p>PS:这道题印象中在一些面经中出场过几次。</p><p>String 转成 Integer，主要有两个方法：</p><ul><li>Integer.parseInt(String s)</li><li>Integer.valueOf(String s)</li></ul><p>不管哪一种，最终还是会调用 Integer 类内中的<code>parseInt(String s, int radix)</code>方法。</p><p>抛去一些边界之类的看看核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">parseInt</span><span class="params">(String s, <span class="type">int</span> radix)</span></span><br><span class="line">                <span class="keyword">throws</span> NumberFormatException</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//是否是负数</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">negative</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//char字符数组下标和长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, len = s.length();</span><br><span class="line">        ……</span><br><span class="line">        <span class="type">int</span> digit;</span><br><span class="line">        <span class="comment">//判断字符长度是否大于0，否则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ……</span><br><span class="line">            <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">                <span class="comment">// Accumulating negatively avoids surprises near MAX_VALUE</span></span><br><span class="line">                <span class="comment">//返回指定基数中字符表示的数值。（此处是十进制数值）</span></span><br><span class="line">                digit = Character.digit(s.charAt(i++),radix);</span><br><span class="line">                <span class="comment">//进制位乘以数值</span></span><br><span class="line">                result *= radix;</span><br><span class="line">                result -= digit;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据上面得到的是否负数，返回相应的值</span></span><br><span class="line">        <span class="keyword">return</span> negative ? result : -result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>去掉枝枝蔓蔓（当然这些枝枝蔓蔓可以去看看，源码 cover 了很多情况），其实剩下的就是一个简单的字符串遍历计算，不过计算方式有点反常规，是用负的值累减。</p><p><img src="https://s2.loli.net/2023/03/25/4LcRgakzqlVOFQu.png" alt="parseInt示意图"></p><center>parseInt示意图</center><h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><h2 id="38-Object-类的常见方法"><a href="#38-Object-类的常见方法" class="headerlink" title="38.Object 类的常见方法?"></a>38.Object 类的常见方法?</h2><p>Object 类是一个特殊的类，是所有类的父类，也就是说所有类都可以调用它的方法。它主要提供了以下 11 个方法，大概可以分为六类：</p><p><img src="https://s2.loli.net/2023/03/25/Y269U5zFdA1uVkB.png" alt="Object类的方法"></p><center>Object类的方法</center><p><strong>对象比较</strong>：</p><ul><li>public native int hashCode() ：native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的 HashMap。</li><li>public boolean equals(Object obj)：用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写用户比较字符串的值是否相等。</li></ul><p><strong>对象拷贝</strong>：</p><ul><li>protected native Object clone() throws CloneNotSupportedException：naitive 方法，用于创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() !&#x3D; x 为 true，x.clone().getClass() &#x3D;&#x3D; x.getClass() 为 true。Object 本身没有实现 Cloneable 接口，所以不重写 clone 方法并且进行调用的话会发生 CloneNotSupportedException 异常。</li></ul><p><strong>对象转字符串：</strong></p><ul><li>public String toString()：返回类的名字@实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</li></ul><p><strong>多线程调度：</strong></p><ul><li>public final native void notify()：native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</li><li>public final native void notifyAll()：native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</li><li>public final native void wait(long timeout) throws InterruptedException：native 方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 。timeout 是等待时间。</li><li>public final void wait(long timeout, int nanos) throws InterruptedException：多了 nanos 参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 毫秒。</li><li>public final void wait() throws InterruptedException：跟之前的 2 个 wait 方法一样，只不过该方法一直等待，没有超时时间这个概念</li></ul><p><strong>反射：</strong></p><ul><li>public final native Class&lt;?&gt; getClass()：native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</li></ul><p><strong>垃圾回收：</strong></p><ul><li>protected void finalize() throws Throwable ：通知垃圾收集器回收对象。</li></ul><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><h2 id="Java-中异常处理体系"><a href="#Java-中异常处理体系" class="headerlink" title="Java 中异常处理体系?"></a>Java 中异常处理体系?</h2><p>Java 的异常体系是分为多层的。</p><p><img src="https://s2.loli.net/2023/03/25/vPXSqzOLFw1yYDn.png" alt="Java异常体系"></p><center>Java异常体系</center><p><code>Throwable</code>是 Java 语言中所有错误或异常的基类。 Throwable 又分为<code>Error</code>和<code>Exception</code>，其中 Error 是系统内部错误，比如虚拟机异常，是程序无法处理的。<code>Exception</code>是程序问题导致的异常，又分为两种：</p><ul><li>CheckedException 受检异常：编译器会强制检查并要求处理的异常。</li><li>RuntimeException 运行时异常：程序运行中出现异常，比如我们熟悉的空指针、数组下标越界等等</li></ul><h2 id="异常的处理方式？"><a href="#异常的处理方式？" class="headerlink" title="异常的处理方式？"></a>异常的处理方式？</h2><p>针对异常的处理主要有两种方式：</p><p><img src="https://s2.loli.net/2023/03/25/sgBdV8eLAprhJ1H.png" alt="异常处理"></p><center>异常处理</center><ul><li><strong>遇到异常不进行具体处理，而是继续抛给调用者 （throw，throws）</strong></li></ul><p>抛出异常有三种形式，一是 throw,一个 throws，还有一种系统自动抛异常。</p><p>throws 用在方法上，后面跟的是异常类，可以跟多个；而 throw 用在方法内，后面跟的是异常对象。</p><ul><li><strong>try catch 捕获异常</strong></li></ul><p>在 catch 语句块中补货发生的异常，并进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">//包含可能会出现异常的代码以及声明异常的方法</span></span><br><span class="line"> &#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">     <span class="comment">//捕获异常并进行处理</span></span><br><span class="line"> &#125;<span class="keyword">finally</span> &#123;                                                       &#125;</span><br><span class="line">     <span class="comment">//可选，必执行的代码</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>try-catch 捕获异常的时候还可以选择加上 finally 语句块，finally 语句块不管程序是否正常执行，最终它都会必然执行。</p><h2 id="三道经典异常处理代码题"><a href="#三道经典异常处理代码题" class="headerlink" title="三道经典异常处理代码题"></a>三道经典异常处理代码题</h2><blockquote><p>题目 1</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TryDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(test());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：31。</p><p>try、catch。finally 的基础用法，在 return 前会先执行 finally 语句块，所以是先输出 finally 里的 3，再输出 return 的 1。</p><blockquote><p>题目 2</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TryDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(test1());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：3。</p><p>try 返回前先执行 finally，结果 finally 里不按套路出牌，直接 return 了，自然也就走不到 try 里面的 return 了。</p><p>finally 里面使用 return 仅存在于面试题中，实际开发这么写要挨吊的。</p><blockquote><p>题目 3</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TryDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(test1());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            i = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            i = <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：2。</p><p>大家可能会以为结果应该是 3，因为在 return 前会执行 finally，而 i 在 finally 中被修改为 3 了，那最终返回 i 不是应该为 3 吗？</p><p>但其实，在执行 finally 之前，JVM 会先将 i 的结果暂存起来，然后 finally 执行完毕后，会返回之前暂存的结果，而不是返回 i，所以即使 i 已经被修改为 3，最终返回的还是之前暂存起来的结果 2。</p><h1 id="I-x2F-O"><a href="#I-x2F-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h1><h2 id="Java-中-IO-流分为几种"><a href="#Java-中-IO-流分为几种" class="headerlink" title="Java 中 IO 流分为几种?"></a>Java 中 IO 流分为几种?</h2><p>流按照不同的特点，有很多种划分方式。</p><ul><li>按照流的流向分，可以分为<strong>输入流</strong>和<strong>输出流</strong>；</li><li>按照操作单元划分，可以划分为<strong>字节流</strong>和<strong>字符流</strong>；</li><li>按照流的角色划分为<strong>节点流</strong>和<strong>处理流</strong></li></ul><p>Java Io 流共涉及 40 多个类，看上去杂乱，其实都存在一定的关联， Java I0 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p><ul><li><strong>InputStream</strong>&#x2F;<strong>Reader</strong>: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li><strong>OutputStream</strong>&#x2F;<strong>Writer</strong>: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul><p><img src="https://s2.loli.net/2023/03/25/ZCTHvtDWhUcMxkg.jpg" alt="IO-操作方式分类"></p><center>IO-操作方式分类</center><blockquote><p>IO 流用到了什么设计模式？</p></blockquote><p>其实，Java 的 IO 流体系还用到了一个设计模式——<strong>装饰器模式</strong>。</p><p>InputStream 相关的部分类图如下，篇幅有限，装饰器模式就不展开说了。</p><p><img src="https://s2.loli.net/2023/03/25/KLmPAfTvauZEiWU.png" alt="Java IO流用到装饰器模式"></p><center>Java IO流用到装饰器模式</center><h2 id="既然有了字节流-为什么还要有字符流"><a href="#既然有了字节流-为什么还要有字符流" class="headerlink" title="既然有了字节流,为什么还要有字符流?"></a>既然有了字节流,为什么还要有字符流?</h2><p>其实字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还比较耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。</p><p>所以， I&#x2F;O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p><h2 id="BIO、NIO、AIO？"><a href="#BIO、NIO、AIO？" class="headerlink" title="BIO、NIO、AIO？"></a>BIO、NIO、AIO？</h2><p><img src="https://s2.loli.net/2023/03/25/lgt1ONFrRkKMjBm.png" alt="BIO、NIO、AIO"></p><center>BIO、NIO、AIO</center><p><strong>BIO</strong>(blocking I&#x2F;O) ： 就是传统的 IO，同步阻塞，服务器实现模式为一个连接一个线程，即<strong>客户端有连接请求时服务器端就需要启动一个线程进行处理</strong>，如果这个连接不做任何事情会造成不必要的线程开销，可以通过连接池机制改善(实现多个客户连接服务器)。</p><p><img src="https://s2.loli.net/2023/03/25/K1QgzBbkxwy7JIp.png" alt="BIO、NIO、AIO"></p><center>BIO、NIO、AIO</center><p>BIO 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4 以前的唯一选择，程序简单易理解。</p><p><strong>NIO</strong> ：全称 java non-blocking IO，是指 JDK 提供的新 API。从 JDK1.4 开始，Java 提供了一系列改进的输入&#x2F;输出的新特性，被统称为 NIO(即 New IO)。</p><p>NIO 是<strong>同步非阻塞</strong>的，服务器端用一个线程处理多个连接，客户端发送的连接请求会注册到多路复用器上，多路复用器轮询到连接有 IO 请求就进行处理：</p><p><img src="https://s2.loli.net/2023/03/25/HaEuOgCDbtN8nsI.png" alt="NIO线程"></p><center>NIO线程</center><p>NIO 的数据是面向<strong>缓冲区 Buffer</strong>的，必须从 Buffer 中读取或写入。</p><p>所以完整的 NIO 示意图：</p><p><img src="https://s2.loli.net/2023/03/25/dHeTBA3VgUSjXph.png" alt="NIO完整示意图"></p><center>NIO完整示意图</center><p>可以看出，NIO 的运行机制：</p><ul><li>每个 Channel 对应一个 Buffer。</li><li>Selector 对应一个线程，一个线程对应多个 Channel。</li><li>Selector 会根据不同的事件，在各个通道上切换。</li><li>Buffer 是内存块，底层是数据。</li></ul><p><strong>AIO</strong>：JDK 7 引入了 Asynchronous I&#x2F;O，是<strong>异步不阻塞</strong>的 IO。在进行 I&#x2F;O 编程中，常用到两种模式：Reactor 和 Proactor。Java 的 NIO 就是 Reactor，当有事件触发时，服务器端得到通知，进行相应的处理，完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用。</p><h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><h2 id="什么是序列化？什么是反序列化？"><a href="#什么是序列化？什么是反序列化？" class="headerlink" title="什么是序列化？什么是反序列化？"></a>什么是序列化？什么是反序列化？</h2><p>什么是序列化，序列化就是<strong>把 Java 对象转为二进制流</strong>，方便存储和传输。</p><p>所以<strong>反序列化就是把二进制流恢复成对象</strong>。</p><p><img src="https://s2.loli.net/2023/03/25/wRUPpaz1srmDY2X.png" alt="序列化和反序列化"></p><center>序列化和反序列化</center><p>类比我们生活中一些大件物品的运输，运输的时候把它拆了打包，用的时候再拆包组装。</p><blockquote><p>Serializable 接口有什么用？</p></blockquote><p>这个接口只是一个标记，没有具体的作用，但是如果不实现这个接口，在有些序列化场景会报错，所以一般建议，创建的 JavaBean 类都实现 Serializable。</p><blockquote><p>serialVersionUID 又有什么用？</p></blockquote><p>serialVersionUID 就是起验证作用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br></pre></td></tr></table></figure><p>我们经常会看到这样的代码，这个 ID 其实就是用来验证序列化的对象和反序列化对应的对象 ID 是否一致。</p><p>这个 ID 的数字其实不重要，无论是 1L 还是 IDE 自动生成的，只要序列化时候对象的 serialVersionUID 和反序列化时候对象的 serialVersionUID 一致的话就行。</p><p>如果没有显示指定 serialVersionUID ，则编译器会根据类的相关信息自动生成一个，可以认为是一个指纹。</p><p>所以如果你没有定义一个 serialVersionUID， 结果序列化一个对象之后，在反序列化之前把对象的类的结构改了，比如增加了一个成员变量，则此时的反序列化会失败。</p><p>因为类的结构变了，所以 serialVersionUID 就不一致。</p><blockquote><p>Java 序列化不包含静态变量？</p></blockquote><p>序列化的时候是不包含静态变量的。</p><blockquote><p>如果有些变量不想序列化，怎么办？</p></blockquote><p>对于不想进行序列化的变量，使用<code>transient</code>关键字修饰。</p><p><code>transient</code> 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 <code>transient</code> 修饰的变量值不会被持久化和恢复。<code>transient</code> 只能修饰变量，不能修饰类和方法。</p><h2 id="说说有几种序列化方式？"><a href="#说说有几种序列化方式？" class="headerlink" title="说说有几种序列化方式？"></a>说说有几种序列化方式？</h2><p>Java 序列化方式有很多，常见的有三种：</p><p><img src="https://s2.loli.net/2023/03/25/d5RN6pXFgyT4b1z.png" alt="Java常见序列化方式"></p><center>Java常见序列化方式</center><ul><li>Java 对象序列化 ：Java 原生序列化方法即通过 Java 原生流(InputStream 和 OutputStream 之间的转化)的方式进行转化，一般是对象输出流 <code>ObjectOutputStream</code>和对象输入流<code>ObjectInputStream</code>。</li><li>Json 序列化：这个可能是我们最常用的序列化方式，Json 序列化的选择很多，一般会使用 jackson 包，通过 ObjectMapper 类来进行一些操作，比如将对象转化为 byte 数组或者将 json 串转化为对象。</li><li>ProtoBuff 序列化：ProtocolBuffer 是一种轻便高效的结构化数据存储格式，ProtoBuff 序列化对象可以很大程度上将其压缩，可以大大减少数据传输大小，提高系统性能。</li></ul><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="Java-泛型了解么？什么是类型擦除？介绍一下常用的通配符？"><a href="#Java-泛型了解么？什么是类型擦除？介绍一下常用的通配符？" class="headerlink" title="Java 泛型了解么？什么是类型擦除？介绍一下常用的通配符？"></a>Java 泛型了解么？什么是类型擦除？介绍一下常用的通配符？</h2><blockquote><p>什么是泛型？</p></blockquote><p>Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">list.add(<span class="number">12</span>);</span><br><span class="line"><span class="comment">//这里直接添加会报错</span></span><br><span class="line">list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">Class&lt;? <span class="keyword">extends</span> <span class="title class_">List</span>&gt; clazz = list.getClass();</span><br><span class="line"><span class="type">Method</span> <span class="variable">add</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;add&quot;</span>, Object.class);</span><br><span class="line"><span class="comment">//但是通过反射添加，是可以的</span></span><br><span class="line">add.invoke(list, <span class="string">&quot;kl&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure><p>泛型一般有三种使用方式:<strong>泛型类</strong>、<strong>泛型接口</strong>、<strong>泛型方法</strong>。</p><p><img src="https://s2.loli.net/2023/03/25/Zg6AJCcEUY2O1rS.png" alt="泛型类、泛型接口、泛型方法"></p><center>泛型类、泛型接口、泛型方法</center><p><strong>1.泛型类</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Generic</span>&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Generic</span><span class="params">(T key)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getKey</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何实例化泛型类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Generic&lt;Integer&gt; genericInteger = <span class="keyword">new</span> <span class="title class_">Generic</span>&lt;Integer&gt;(<span class="number">123456</span>);</span><br></pre></td></tr></table></figure><p><strong>2.泛型接口</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Generator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现泛型接口，指定类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GeneratorImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;String&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.泛型方法</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt; E &gt; <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">( E[] inputArray )</span></span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">for</span> ( E element : inputArray )&#123;</span><br><span class="line">         System.out.printf( <span class="string">&quot;%s &quot;</span>, element );</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建不同类型数组： Integer, Double 和 Character</span></span><br><span class="line">Integer[] intArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">String[] stringArray = &#123; <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span> &#125;;</span><br><span class="line">printArray( intArray  );</span><br><span class="line">printArray( stringArray  );</span><br></pre></td></tr></table></figure><blockquote><p>泛型常用的通配符有哪些？</p></blockquote><p><strong>常用的通配符为： T，E，K，V，？</strong></p><ul><li>？ 表示不确定的 java 类型</li><li>T (type) 表示具体的一个 java 类型</li><li>K V (key value) 分别代表 java 键值中的 Key Value</li><li>E (element) 代表 Element</li></ul><blockquote><p>什么是泛型擦除？</p></blockquote><p>所谓的泛型擦除，官方名叫“类型擦除”。</p><p>Java 的泛型是伪泛型，这是因为 Java 在编译期间，所有的类型信息都会被擦掉。</p><p>也就是说，在运行的时候是没有泛型的。</p><p>例如这段代码，往一群猫里放条狗：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;Cat&gt; cats = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Cat&gt;();</span><br><span class="line"><span class="type">LinkedList</span> <span class="variable">list</span> <span class="operator">=</span> cats;  <span class="comment">// 注意我在这里把范型去掉了，但是list和cats是同一个链表！</span></span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Dog</span>());  <span class="comment">// 完全没问题！</span></span><br></pre></td></tr></table></figure><p>因为 Java 的范型只存在于源码里，编译的时候给你静态地检查一下范型类型是否正确，而到了运行时就不检查了。上面这段代码在 JRE（Java<strong>运行</strong>环境）看来和下面这段没区别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LinkedList</span> <span class="variable">cats</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();  <span class="comment">// 注意：没有范型！</span></span><br><span class="line"><span class="type">LinkedList</span> <span class="variable">list</span> <span class="operator">=</span> cats;</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Dog</span>());</span><br></pre></td></tr></table></figure><p>为什么要类型擦除呢？</p><p>主要是为了向下兼容，因为 JDK5 之前是没有泛型的，为了让 JVM 保持向下兼容，就出了类型擦除这个策略。</p><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="说一下你对注解的理解？"><a href="#说一下你对注解的理解？" class="headerlink" title="说一下你对注解的理解？"></a>说一下你对注解的理解？</h2><p><strong>Java 注解本质上是一个标记</strong>，可以理解成生活中的一个人的一些小装扮，比如戴什么什么帽子，戴什么眼镜。</p><p><img src="https://s2.loli.net/2023/03/25/eYCJOxQZHKU6uzL.png" alt="Java注解和帽子"></p><center>Java注解和帽子</center><p>注解可以标记在类上、方法上、属性上等，标记自身也可以设置一些值，比如帽子颜色是绿色。</p><p>有了标记之后，我们就可以在编译或者运行阶段去识别这些标记，然后搞一些事情，这就是注解的用处。</p><p>例如我们常见的 AOP，使用注解作为切点就是运行期注解的应用；比如 lombok，就是注解在编译期的运行。</p><p>注解生命周期有三大类，分别是：</p><ul><li>RetentionPolicy.SOURCE：给编译器用的，不会写入 class 文件</li><li>RetentionPolicy.CLASS：会写入 class 文件，在类加载阶段丢弃，也就是运行的时候就没这个信息了</li><li>RetentionPolicy.RUNTIME：会写入 class 文件，永久保存，可以通过反射获取注解信息</li></ul><p>所以我上文写的是解析的时候，没写具体是解析啥，因为不同的生命周期的解析动作是不同的。</p><p>像常见的：</p><p><img src="https://s2.loli.net/2023/03/25/mkAyb49zSGsfUhg.png" alt="Override注解"></p><center>Override注解</center><p>就是给编译器用的，编译器编译的时候检查没问题就 over 了，class 文件里面不会有 Override 这个标记。</p><p>再比如 Spring 常见的 Autowired ，就是 RUNTIME 的，所以<strong>在运行的时候可以通过反射得到注解的信息</strong>，还能拿到标记的值 required 。</p><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javase-35.png" alt="Autowired注解"></p><center>Autowired注解</center><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="什么是反射？应用？原理？"><a href="#什么是反射？应用？原理？" class="headerlink" title="什么是反射？应用？原理？"></a>什么是反射？应用？原理？</h2><blockquote><p>什么是反射？</p></blockquote><p>我们通常都是利用<code>new</code>方式来创建对象实例，这可以说就是一种“正射”，这种方式在编译时候就确定了类型信息。</p><p>而如果，我们想在时候动态地获取类信息、创建类实例、调用类方法这时候就要用到<strong>反射</strong>。</p><p>通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。</p><p>反射最核心的四个类：</p><p><img src="https://s2.loli.net/2023/03/25/GbZatyLWsB5inIH.png" alt="Java反射相关类"></p><center>Java反射相关类</center><p>反射的应用场景？</p><p>一般我们平时都是在在写业务代码，很少会接触到直接使用反射机制的场景。</p><p>但是，这并不代表反射没有用。相反，正是因为反射，你才能这么轻松地使用各种框架。像 Spring&#x2F;Spring Boot、MyBatis 等等框架中都大量使用了反射机制。</p><p>像 Spring 里的很多 <strong>注解</strong> ，它真正的功能实现就是利用反射。</p><p>就像为什么我们使用 Spring 的时候 ，一个<code>@Component</code>注解就声明了一个类为 Spring Bean 呢？为什么通过一个 <code>@Value</code>注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？</p><p>这些都是因为我们可以基于反射操作类，然后获取到类&#x2F;属性&#x2F;方法&#x2F;方法的参数上的注解，注解这里就有两个作用，一是标记，我们对注解标记的类&#x2F;属性&#x2F;方法进行对应的处理；二是注解本身有一些信息，可以参与到处理的逻辑中。</p><blockquote><p>反射的原理？</p></blockquote><p>我们都知道 Java 程序的执行分为编译和运行两步，编译之后会生成字节码(.class)文件，JVM 进行类加载的时候，会加载字节码文件，将类型相关的所有信息加载进方法区，反射就是去获取这些信息，然后进行各种操作。</p><h1 id="JDK1-8-新特性"><a href="#JDK1-8-新特性" class="headerlink" title="JDK1.8 新特性"></a>JDK1.8 新特性</h1><p>JDK 已经出到 17 了，但是你迭代你的版本，我用我的 8。JDK1.8 的一些新特性，当然现在也不新了，其实在工作中已经很常用了。</p><h2 id="JDK1-8-都有哪些新特性？"><a href="#JDK1-8-都有哪些新特性？" class="headerlink" title="JDK1.8 都有哪些新特性？"></a>JDK1.8 都有哪些新特性？</h2><p>JDK1.8 有不少新特性，我们经常接触到的新特性如下：</p><p><img src="https://s2.loli.net/2023/03/25/CouX8eUMa9DGVRs.png" alt="JDK1.8主要新特性"></p><center>JDK1.8主要新特性</center><ul><li><p>接口默认方法：Java 8 允许我们给接口添加一个非抽象的方法实现，只需要使用 default 关键字修饰即可</p></li><li><p>Lambda 表达式和函数式接口：Lambda 表达式本质上是一段匿名内部类，也可以是一段可以传递的代码。Lambda 允许把函数作为一个方法的参数（函数作为参数传递到方法中），使用 Lambda 表达式使代码更加简洁，但是也不要滥用，否则会有可读性等问题，《Effective Java》作者 Josh Bloch 建议使用 Lambda 表达式最好不要超过 3 行。</p></li><li><p>Stream API：用函数式编程方式在集合类上进行复杂操作的工具，配合 Lambda 表达式可以方便的对集合进行处理。</p><p>Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。使用 Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。也可以使用 Stream API 来并行执行操作。</p><p>简而言之，Stream API 提供了一种高效且易于使用的处理数据的方式。</p></li><li><p>日期时间 API：Java 8 引入了新的日期时间 API 改进了日期时间的管理。</p></li><li><p>Optional 类：用来解决空指针异常的问题。很久以前 Google Guava 项目引入了 Optional 作为解决空指针异常的一种方式，不赞成代码被 null 检查的代码污染，期望程序员写整洁的代码。受 Google Guava 的鼓励，Optional 现在是 Java 8 库的一部分。</p></li></ul><h2 id="Lambda-表达式了解多少？"><a href="#Lambda-表达式了解多少？" class="headerlink" title="Lambda 表达式了解多少？"></a>Lambda 表达式了解多少？</h2><p>Lambda 表达式本质上是一段匿名内部类，也可以是一段可以传递的代码。</p><p>比如我们以前使用 Runnable 创建并运行线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread is running before Java8!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p>这是通过内部类的方式来重写 run 方法，使用 Lambda 表达式，还可以更加简洁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>( () -&gt; System.out.println(<span class="string">&quot;Thread is running since Java8!&quot;</span>) ).start();</span><br></pre></td></tr></table></figure><p>当然不是每个接口都可以缩写成 Lambda 表达式。只有那些函数式接口（Functional Interface）才能缩写成 Lambda 表示式。</p><p>所谓函数式接口（Functional Interface）就是只包含一个抽象方法的声明。针对该接口类型的所有 Lambda 表达式都会与这个抽象方法匹配。</p><blockquote><p>Java8 有哪些内置函数式接口？</p></blockquote><p>JDK 1.8 API 包含了很多内置的函数式接口。其中就包括我们在老版本中经常见到的 <strong>Comparator</strong> 和 <strong>Runnable</strong>，Java 8 为他们都添加了 @FunctionalInterface 注解，以用来支持 Lambda 表达式。</p><p>除了这两个之外，还有 Callable、Predicate、Function、Supplier、Consumer 等等。</p><h2 id="Optional-了解吗？"><a href="#Optional-了解吗？" class="headerlink" title="Optional 了解吗？"></a>Optional 了解吗？</h2><p><code>Optional</code>是用于防范<code>NullPointerException</code>。</p><p>可以将 <code>Optional</code> 看做是包装对象（可能是 <code>null</code>, 也有可能非 <code>null</code>）的容器。当我们定义了 一个方法，这个方法返回的对象可能是空，也有可能非空的时候，我们就可以考虑用 <code>Optional</code> 来包装它，这也是在 Java 8 被推荐使用的做法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; optional = Optional.of(<span class="string">&quot;bam&quot;</span>);</span><br><span class="line"></span><br><span class="line">optional.isPresent();           <span class="comment">// true</span></span><br><span class="line">optional.get();                 <span class="comment">// &quot;bam&quot;</span></span><br><span class="line">optional.orElse(<span class="string">&quot;fallback&quot;</span>);    <span class="comment">// &quot;bam&quot;</span></span><br><span class="line"></span><br><span class="line">optional.ifPresent((s) -&gt; System.out.println(s.charAt(<span class="number">0</span>)));     <span class="comment">// &quot;b&quot;</span></span><br></pre></td></tr></table></figure><h2 id="Stream-流用过吗？"><a href="#Stream-流用过吗？" class="headerlink" title="Stream 流用过吗？"></a>Stream 流用过吗？</h2><p><code>Stream</code> 流，简单来说，使用 <code>java.util.Stream</code> 对一个包含一个或多个元素的集合做各种操作。这些操作可能是 <em>中间操作</em> 亦或是 <em>终端操作</em>。 终端操作会返回一个结果，而中间操作会返回一个 <code>Stream</code> 流。</p><p>Stream 流一般用于集合，我们对一个集合做几个常见操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringCollection = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">stringCollection.add(<span class="string">&quot;ddd2&quot;</span>);</span><br><span class="line">stringCollection.add(<span class="string">&quot;aaa2&quot;</span>);</span><br><span class="line">stringCollection.add(<span class="string">&quot;bbb1&quot;</span>);</span><br><span class="line">stringCollection.add(<span class="string">&quot;aaa1&quot;</span>);</span><br><span class="line">stringCollection.add(<span class="string">&quot;bbb3&quot;</span>);</span><br><span class="line">stringCollection.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">stringCollection.add(<span class="string">&quot;bbb2&quot;</span>);</span><br><span class="line">stringCollection.add(<span class="string">&quot;ddd1&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>Filter 过滤</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stringCollection</span><br><span class="line">    .stream()</span><br><span class="line">    .filter((s) -&gt; s.startsWith(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;aaa2&quot;, &quot;aaa1&quot;</span></span><br></pre></td></tr></table></figure><ul><li><strong>Sorted 排序</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stringCollection</span><br><span class="line">    .stream()</span><br><span class="line">    .sorted()</span><br><span class="line">    .filter((s) -&gt; s.startsWith(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;aaa1&quot;, &quot;aaa2&quot;</span></span><br></pre></td></tr></table></figure><ul><li><strong>Map 转换</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stringCollection</span><br><span class="line">    .stream()</span><br><span class="line">    .map(String::toUpperCase)</span><br><span class="line">    .sorted((a, b) -&gt; b.compareTo(a))</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;DDD2&quot;, &quot;DDD1&quot;, &quot;CCC&quot;, &quot;BBB3&quot;, &quot;BBB2&quot;, &quot;AAA2&quot;, &quot;AAA1&quot;</span></span><br></pre></td></tr></table></figure><ul><li><strong>Match 匹配</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证 list 中 string 是否有以 a 开头的, 匹配到第一个，即返回 true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">anyStartsWithA</span> <span class="operator">=</span></span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .anyMatch((s) -&gt; s.startsWith(<span class="string">&quot;a&quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(anyStartsWithA);      <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证 list 中 string 是否都是以 a 开头的</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">allStartsWithA</span> <span class="operator">=</span></span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .allMatch((s) -&gt; s.startsWith(<span class="string">&quot;a&quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(allStartsWithA);      <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证 list 中 string 是否都不是以 z 开头的,</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">noneStartsWithZ</span> <span class="operator">=</span></span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .noneMatch((s) -&gt; s.startsWith(<span class="string">&quot;z&quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(noneStartsWithZ);      <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li><strong>Count 计数</strong></li></ul><p><code>count</code> 是一个终端操作，它能够统计 <code>stream</code> 流中的元素总数，返回值是 <code>long</code> 类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先对 list 中字符串开头为 b 进行过滤，让后统计数量</span></span><br><span class="line"><span class="type">long</span> <span class="variable">startsWithB</span> <span class="operator">=</span></span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .filter((s) -&gt; s.startsWith(<span class="string">&quot;b&quot;</span>))</span><br><span class="line">        .count();</span><br><span class="line"></span><br><span class="line">System.out.println(startsWithB);    <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><ul><li><strong>Reduce</strong></li></ul><p><code>Reduce</code> 中文翻译为：<em>减少、缩小</em>。通过入参的 <code>Function</code>，我们能够将 <code>list</code> 归约成一个值。它的返回类型是 <code>Optional</code> 类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; reduced =</span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .sorted()</span><br><span class="line">        .reduce((s1, s2) -&gt; s1 + <span class="string">&quot;#&quot;</span> + s2);</span><br><span class="line"></span><br><span class="line">reduced.ifPresent(System.out::println);</span><br><span class="line"><span class="comment">// &quot;aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2&quot;</span></span><br></pre></td></tr></table></figure><p>以上是常见的几种流式操作，还有其它的一些流式操作，可以帮助我们更便捷地处理集合数据。</p><p><img src="https://s2.loli.net/2023/03/25/XIG8RUh5rQKy6Yx.png" alt="Java Stream流"></p><center>Java Stream流</center>]]></content>
      
      
      <categories>
          
          <category> 面渣逆袭 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面渣逆袭 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面渣逆袭-Java集合框架</title>
      <link href="/Blog/2023/03/24/interview/%E9%9D%A2%E6%B8%A3%E9%80%86%E8%A2%AD-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
      <url>/Blog/2023/03/24/interview/%E9%9D%A2%E6%B8%A3%E9%80%86%E8%A2%AD-Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><h2 id="说说有哪些常见集合？"><a href="#说说有哪些常见集合？" class="headerlink" title="说说有哪些常见集合？"></a>说说有哪些常见集合？</h2><p>集合相关类和接口都在java.util中，主要分为3种：List（列表）、Map（映射）、Set(集)。</p><p><img src="https://s2.loli.net/2023/03/25/7j3BpYmFHaOeVSy.png" alt="Java集合主要关系"></p><center>Java集合主要关系</center><p>其中<code>Collection</code>是集合<code>List</code>、<code>Set</code>的父接口，它主要有两个子接口：</p><ul><li><code>List</code>：存储的元素有序，可重复。</li><li><code>Set</code>：存储的元素不无序，不可重复。</li></ul><p><code>Map</code>是另外的接口，是键值对映射结构的集合。</p><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><p>List，也没啥好问的，但不排除面试官剑走偏锋，比如面试官也看了我这篇文章。</p><h2 id="ArrayList和LinkedList有什么区别？"><a href="#ArrayList和LinkedList有什么区别？" class="headerlink" title="ArrayList和LinkedList有什么区别？"></a>ArrayList和LinkedList有什么区别？</h2><p><strong>（1）</strong>数据结构不同</p><ul><li>ArrayList基于数组实现</li><li>LinkedList基于双向链表实现</li></ul><p><img src="https://s2.loli.net/2023/03/25/PyeWLaFcVoEK5tl.png" alt="ArrayList和LinkedList的数据结构"></p><center>ArrayList和LinkedList的数据结构</center><p><strong>（2）</strong> 多数情况下，ArrayList更利于查找，LinkedList更利于增删</p><ul><li>ArrayList基于数组实现，get(int index)可以直接通过数组下标获取，时间复杂度是O(1)；LinkedList基于链表实现，get(int index)需要遍历链表，时间复杂度是O(n)；当然，get(E element)这种查找，两种集合都需要遍历，时间复杂度都是O(n)。</li><li>ArrayList增删如果是数组末尾的位置，直接插入或者删除就可以了，但是如果插入中间的位置，就需要把插入位置后的元素都向前或者向后移动，甚至还有可能触发扩容；双向链表的插入和删除只需要改变前驱节点、后继节点和插入节点的指向就行了，不需要移动元素。</li></ul><p><img src="https://s2.loli.net/2023/03/25/MDaAGcgLrOxUedI.png" alt="ArrayList和LinkedList中间插入"></p><center>ArrayList和LinkedList中间插入</center><p><img src="https://s2.loli.net/2023/03/25/IW9D4VQqAEw3KPo.png" alt="ArrayList和LinkedList中间删除"></p><center>ArrayList和LinkedList中间删除</center><blockquote><p>注意，这个地方可能会出陷阱，LinkedList更利于增删更多是体现在平均步长上，不是体现在时间复杂度上，二者增删的时间复杂度都是O(n)</p></blockquote><p><strong>（3）</strong>是否支持随机访问</p><ul><li>ArrayList基于数组，所以它可以根据下标查找，支持随机访问，当然，它也实现了RandmoAccess 接口，这个接口只是用来标识是否支持随机访问。</li><li>LinkedList基于链表，所以它没法根据序号直接获取元素，它没有实现RandmoAccess 接口，标记不支持随机访问。</li></ul><p><strong>（4）</strong>内存占用，ArrayList基于数组，是一块连续的内存空间，LinkedList基于链表，内存空间不连续，它们在空间占用上都有一些额外的消耗：</p><ul><li>ArrayList是预先定义好的数组，可能会有空的内存空间，存在一定空间浪费</li><li>LinkedList每个节点，需要存储前驱和后继，所以每个节点会占用更多的空间</li></ul><h2 id="ArrayList的扩容机制了解吗？"><a href="#ArrayList的扩容机制了解吗？" class="headerlink" title="ArrayList的扩容机制了解吗？"></a>ArrayList的扩容机制了解吗？</h2><p>ArrayList是基于数组的集合，数组的容量是在定义的时候确定的，如果数组满了，再插入，就会数组溢出。所以在插入时候，会先检查是否需要扩容，如果当前容量+1超过数组长度，就会进行扩容。</p><p>ArrayList的扩容是创建一个<strong>1.5倍</strong>的新数组，然后把原数组的值拷贝过去。</p><p><img src="https://s2.loli.net/2023/03/25/7Xd98Fmv4uTViQO.png" alt="ArrayList扩容"></p><center>ArrayList扩容</center><h2 id="ArrayList怎么序列化的知道吗？-为什么用transient修饰数组？"><a href="#ArrayList怎么序列化的知道吗？-为什么用transient修饰数组？" class="headerlink" title="ArrayList怎么序列化的知道吗？ 为什么用transient修饰数组？"></a>ArrayList怎么序列化的知道吗？ 为什么用transient修饰数组？</h2><p>ArrayList的序列化不太一样，它使用<code>transient</code>修饰存储元素的<code>elementData</code>的数组，<code>transient</code>关键字的作用是让被修饰的成员属性不被序列化。</p><p><strong>为什么最ArrayList不直接序列化元素数组呢？</strong></p><p>出于效率的考虑，数组可能长度100，但实际只用了50，剩下的50不用其实不用序列化，这样可以提高序列化和反序列化的效率，还可以节省内存空间。</p><p><strong>那ArrayList怎么序列化呢？</strong></p><p>ArrayList通过两个方法<strong>readObject、writeObject</strong>自定义序列化和反序列化策略，实际直接使用两个流<code>ObjectOutputStream</code>和<code>ObjectInputStream</code>来进行序列化和反序列化。</p><p><img src="https://s2.loli.net/2023/03/25/D7Qh1RkiH3odUrJ.png" alt="ArrayList自定义序列化"></p><center>ArrayList自定义序列化</center><h2 id="快速失败-fail-fast-和安全失败-fail-safe-了解吗？"><a href="#快速失败-fail-fast-和安全失败-fail-safe-了解吗？" class="headerlink" title="快速失败(fail-fast)和安全失败(fail-safe)了解吗？"></a>快速失败(fail-fast)和安全失败(fail-safe)了解吗？</h2><p><strong>快速失败（fail—fast）</strong>：快速失败是Java集合的一种错误检测机制</p><ul><li>在用迭代器遍历一个集合对象时，如果线程A遍历过程中，线程B对集合对象的内容进行了修改（增加、删除、修改），则会抛出Concurrent Modification Exception。</li><li>原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 <code>modCount</code> 变量。集合在被遍历期间如果内容发生变化，就会改变<code>modCount</code>的值。每当迭代器使用hashNext()&#x2F;next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</li><li>注意：这里异常的抛出条件是检测到 modCount！&#x3D;expectedmodCount 这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。</li><li>场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改），比如ArrayList 类。</li></ul><p><strong>安全失败（fail—safe）</strong></p><ul><li>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。</li><li>原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。</li><li>缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</li><li>场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改，比如CopyOnWriteArrayList类。</li></ul><h2 id="有哪几种实现ArrayList线程安全的方法？"><a href="#有哪几种实现ArrayList线程安全的方法？" class="headerlink" title="有哪几种实现ArrayList线程安全的方法？"></a>有哪几种实现ArrayList线程安全的方法？</h2><p>fail-fast是一种可能触发的机制，实际上，ArrayList的线程安全仍然没有保证，一般，保证ArrayList的线程安全可以通过这些方案：</p><ul><li>使用 Vector 代替 ArrayList。（不推荐，Vector是一个历史遗留类）</li><li>使用 Collections.synchronizedList 包装 ArrayList，然后操作包装后的 list。</li><li>使用 CopyOnWriteArrayList 代替 ArrayList。</li><li>在使用 ArrayList 时，应用程序通过同步机制去控制 ArrayList 的读写。</li></ul><h2 id="CopyOnWriteArrayList了解多少？"><a href="#CopyOnWriteArrayList了解多少？" class="headerlink" title="CopyOnWriteArrayList了解多少？"></a>CopyOnWriteArrayList了解多少？</h2><p>CopyOnWriteArrayList就是线程安全版本的ArrayList。</p><p>它的名字叫<code>CopyOnWrite</code>——写时复制，已经明示了它的原理。</p><p>CopyOnWriteArrayList采用了一种读写分离的并发策略。CopyOnWriteArrayList容器允许并发读，读操作是无锁的，性能较高。至于写操作，比如向容器中添加一个元素，则首先将当前容器复制一份，然后在新副本上执行写操作，结束之后再将原容器的引用指向新容器。</p><p><img src="https://s2.loli.net/2023/03/25/ZyImWCazglBTJDj.png" alt="CopyOnWriteArrayList原理"></p><center>CopyOnWriteArrayList原理</center><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>Map中，毫无疑问，最重要的就是HashMap，面试基本被盘出包浆了，各种问法，一定要好好准备。</p><h2 id="能说一下HashMap的数据结构吗？"><a href="#能说一下HashMap的数据结构吗？" class="headerlink" title="能说一下HashMap的数据结构吗？"></a>能说一下HashMap的数据结构吗？</h2><p>JDK1.7的数据结构是<code>数组</code>+<code>链表</code>，JDK1.7还有人在用？不会吧……</p><p>说一下JDK1.8的数据结构吧：</p><p>JDK1.8的数据结构是<code>数组</code>+<code>链表</code>+<code>红黑树</code>。</p><p>数据结构示意图如下：</p><p><img src="https://s2.loli.net/2023/03/25/6LPEW4vOBubCZAi.png" alt="jdk1.8 hashmap数据结构示意图"></p><center>jdk1.8 hashmap数据结构示意图</center><p>其中，桶数组是用来存储数据元素，链表是用来解决冲突，红黑树是为了提高查询的效率。</p><ul><li>数据元素通过映射关系，也就是散列函数，映射到桶数组对应索引的位置</li><li>如果发生冲突，从冲突的位置拉一个链表，插入冲突的元素</li><li>如果链表长度&gt;8&amp;数组大小&gt;&#x3D;64，链表转为红黑树</li><li>如果红黑树节点个数&lt;6 ，转为链表</li></ul><h2 id="你对红黑树了解多少？为什么不用二叉树-x2F-平衡树呢？"><a href="#你对红黑树了解多少？为什么不用二叉树-x2F-平衡树呢？" class="headerlink" title="你对红黑树了解多少？为什么不用二叉树&#x2F;平衡树呢？"></a>你对红黑树了解多少？为什么不用二叉树&#x2F;平衡树呢？</h2><p>红黑树本质上是一种二叉查找树，为了保持平衡，它又在二叉查找树的基础上增加了一些规则：</p><ol><li>每个节点要么是红色，要么是黑色；</li><li>根节点永远是黑色的；</li><li>所有的叶子节点都是是黑色的（注意这里说叶子节点其实是图中的 NULL 节点）；</li><li>每个红色节点的两个子节点一定都是黑色；</li><li>从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点；</li></ol><p><img src="https://s2.loli.net/2023/03/25/ye6h9lxR51wZtAG.png" alt="红黑树"></p><center>红黑树</center><blockquote><p>之所以不用二叉树：</p></blockquote><p>红黑树是一种平衡的二叉树，插入、删除、查找的最坏时间复杂度都为 O(logn)，避免了二叉树最坏情况下的O(n)时间复杂度。</p><blockquote><p>之所以不用平衡二叉树：</p></blockquote><p>平衡二叉树是比红黑树更严格的平衡树，为了保持保持平衡，需要旋转的次数更多，也就是说平衡二叉树保持平衡的效率更低，所以平衡二叉树插入和删除的效率比红黑树要低。</p><h2 id="红黑树怎么保持平衡的知道吗？"><a href="#红黑树怎么保持平衡的知道吗？" class="headerlink" title="红黑树怎么保持平衡的知道吗？"></a>红黑树怎么保持平衡的知道吗？</h2><p>红黑树有两种方式保持平衡：<code>旋转</code>和<code>染色</code>。</p><ul><li>旋转：旋转分为两种，左旋和右旋</li></ul><p><img src="https://s2.loli.net/2023/03/25/uD2HLMYkbqQKBT4.png" alt="左旋"><center>左旋</center></p><p><img src="https://s2.loli.net/2023/03/25/fbz72UAtFwiV61a.png" alt="右旋"></p><center>右旋</center><ul><li>染⾊：</li></ul><p><img src="https://s2.loli.net/2023/03/25/hJV3szm1IkQx6Rc.png" alt="染色"></p><center>染色</center><h2 id="HashMap的put流程知道吗？"><a href="#HashMap的put流程知道吗？" class="headerlink" title="HashMap的put流程知道吗？"></a>HashMap的put流程知道吗？</h2><p>先上个流程图吧:</p><p><img src="https://s2.loli.net/2023/03/25/uLXVqShZ6GklUce.jpg" alt="HashMap插入数据流程图"></p><center>HashMap插入数据流程图</center><ol><li><p>首先进行哈希值的扰动，获取一个新的哈希值。<code>(key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</code></p></li><li><p>判断tab是否位空或者长度为0，如果是则进行扩容操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    n = (tab = resize()).length;</span><br></pre></td></tr></table></figure></li><li><p>根据哈希值计算下标，如果对应小标正好没有存放数据，则直接插入即可否则需要覆盖。<code>tab[i = (n - 1) &amp; hash])</code></p></li><li><p>判断tab[i]是否为树节点，否则向链表中插入数据，是则向树中插入节点。</p></li><li><p>如果链表中插入节点的时候，链表长度大于等于8，则需要把链表转换为红黑树。<code>treeifyBin(tab, hash);</code></p></li><li><p>最后所有元素处理完成后，判断是否超过阈值；<code>threshold</code>，超过则扩容。</p></li></ol><h2 id="HashMap怎么查找元素的呢？"><a href="#HashMap怎么查找元素的呢？" class="headerlink" title="HashMap怎么查找元素的呢？"></a>HashMap怎么查找元素的呢？</h2><p>先看流程图：</p><p><img src="https://s2.loli.net/2023/03/25/W8YNGAyaBQJuU56.png" alt="HashMap查找流程图"></p><center>HashMap查找流程图</center><p>HashMap的查找就简单很多：</p><ol><li>使用扰动函数，获取新的哈希值</li><li>计算数组下标，获取节点</li><li>当前节点和key匹配，直接返回</li><li>否则，当前节点是否为树节点，查找红黑树</li><li>否则，遍历链表查找</li></ol><h2 id="HashMap的哈希-x2F-扰动函数是怎么设计的"><a href="#HashMap的哈希-x2F-扰动函数是怎么设计的" class="headerlink" title="HashMap的哈希&#x2F;扰动函数是怎么设计的?"></a>HashMap的哈希&#x2F;扰动函数是怎么设计的?</h2><p>HashMap的哈希函数是先拿到 key 的hashcode，是一个32位的int类型的数值，然后让hashcode的高16位和低16位进行异或操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="comment">// key的hashCode和key的hashCode右移16位做异或运算</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么设计是为了降低哈希碰撞的概率。</p><h2 id="为什么哈希-x2F-扰动函数能降hash碰撞？"><a href="#为什么哈希-x2F-扰动函数能降hash碰撞？" class="headerlink" title="为什么哈希&#x2F;扰动函数能降hash碰撞？"></a>为什么哈希&#x2F;扰动函数能降hash碰撞？</h2><p>因为 key.hashCode() 函数调用的是 key 键值类型自带的哈希函数，返回 int 型散列值。int 值范围为 <strong>-2147483648~2147483647</strong>，加起来大概 40 亿的映射空间。</p><p>只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个 40 亿长度的数组，内存是放不下的。</p><p>假如 HashMap 数组的初始大小才 16，就需要用之前需要对数组的长度取模运算，得到的余数才能用来访问数组下标。</p><p>源码中模运算就是把散列值和数组长度 - 1 做一个 “<code>与&amp;</code>“ 操作，位运算比取余 % 运算要快。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bucketIndex = indexFor(hash, table.length);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">indexFor</span><span class="params">(<span class="type">int</span> h, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺便说一下，这也正好解释了为什么 HashMap 的数组长度要取 2 的整数幂。因为这样（数组长度 - 1）正好相当于一个 “低位掩码”。<code>与</code> 操作的结果就是散列值的高位全部归零，只保留低位值，用来做数组下标访问。以初始长度 16 为例，16-1&#x3D;15。2 进制表示是<code> 0000 0000 0000 0000 0000 0000 0000 1111</code>。和某个散列值做 <code>与</code> 操作如下，结果就是截取了最低的四位值。</p><p><img src="https://s2.loli.net/2023/03/25/ubX3zo9xGVy4vmL.png" alt="哈希&amp;运算">哈希&amp;运算</p><p>这样是要快捷一些，但是新的问题来了，就算散列值分布再松散，要是只取最后几位的话，碰撞也会很严重。如果散列本身做得不好，分布上成等差数列的漏洞，如果正好让最后几个低位呈现规律性重复，那就更难搞了。</p><p>这时候 <code>扰动函数</code> 的价值就体现出来了，看一下扰动函数的示意图：</p><p><img src="https://s2.loli.net/2023/03/25/OFDliIzN1AkPVmS.jpg" alt="扰动函数示意图"></p><center>扰动函数示意图</center><p>右移 16 位，正好是 32bit 的一半，自己的高半区和低半区做异或，就是为了混合原始哈希码的高位和低位，以此来加大低位的随机性。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。</p><h2 id="为什么HashMap的容量是2的倍数呢？"><a href="#为什么HashMap的容量是2的倍数呢？" class="headerlink" title="为什么HashMap的容量是2的倍数呢？"></a>为什么HashMap的容量是2的倍数呢？</h2><ul><li>第一个原因是为了方便哈希取余：</li></ul><p>将元素放在table数组上面，是用hash值%数组大小定位位置，而HashMap是用hash值&amp;(数组大小-1)，却能和前面达到一样的效果，这就得益于HashMap的大小是2的倍数，2的倍数意味着该数的二进制位只有一位为1，而该数-1就可以得到二进制位上1变成0，后面的0变成1，再通过&amp;运算，就可以得到和%一样的效果，并且位运算比%的效率高得多</p><p>HashMap的容量是2的n次幂时，(n-1)的2进制也就是1111111***111这样形式的，这样与添加元素的hash值进行位运算时，能够充分的散列，使得添加的元素均匀分布在HashMap的每个位置上，减少hash碰撞。</p><ul><li>第二个方面是在扩容时，利用扩容后的大小也是2的倍数，将已经产生hash碰撞的元素完美的转移到新的table中去</li></ul><p>我们可以简单看看HashMap的扩容机制，HashMap中的元素在超过<code>负载因子*HashMap</code>大小时就会产生扩容。</p><p><img src="https://s2.loli.net/2023/03/25/7bF1nWkY9J3XA2m.png" alt="put中的扩容">put中的扩容</p><h2 id="如果初始化HashMap，传一个17的值new-HashMap-lt-gt-，它会怎么处理？"><a href="#如果初始化HashMap，传一个17的值new-HashMap-lt-gt-，它会怎么处理？" class="headerlink" title="如果初始化HashMap，传一个17的值new HashMap&lt;&gt;，它会怎么处理？"></a>如果初始化HashMap，传一个17的值<code>new HashMap&lt;&gt;</code>，它会怎么处理？</h2><p>简单来说，就是初始化时，传的不是2的倍数时，HashMap会向上寻找<code>离得最近的2的倍数</code>，所以传入17，但HashMap的实际容量是32。</p><p>我们来看看详情，在HashMap的初始化中，有这样⼀段⽅法；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line"> ...</span><br><span class="line"> <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line"> <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>阀值 threshold ，通过⽅法<code> tableSizeFor</code> 进⾏计算，是根据初始化传的参数来计算的。</li><li>同时，这个⽅法也要要寻找⽐初始值⼤的，最⼩的那个2进制数值。⽐如传了17，我应该找到的是32。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line"> <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line"> n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"> n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line"> n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line"> n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line"> n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line"> <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>; &#125;</span><br></pre></td></tr></table></figure><ul><li>MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30，这个是临界范围，也就是最⼤的Map集合。</li><li>计算过程是向右移位1、2、4、8、16，和原来的数做<code>|</code>运算，这主要是为了把⼆进制的各个位置都填上1，当⼆进制的各个位置都是1以后，就是⼀个标准的2的倍数减1了，最后把结果加1再返回即可。</li></ul><p>以17为例，看一下初始化计算table容量的过程：</p><p><img src="https://s2.loli.net/2023/03/25/zKv73EidV6xkLCy.png" alt="容量计算">容量计算</p><h2 id="你还知道哪些哈希函数的构造方法呢？"><a href="#你还知道哪些哈希函数的构造方法呢？" class="headerlink" title="你还知道哪些哈希函数的构造方法呢？"></a>你还知道哪些哈希函数的构造方法呢？</h2><p>HashMap里哈希构造函数的方法叫：</p><ul><li><strong>除留取余法</strong>：H（key)&#x3D;key%p（p&lt;&#x3D;N）,关键字除以一个不大于哈希表长度的正整数p，所得余数为地址，当然HashMap里进行了优化改造，效率更高，散列也更均衡。</li></ul><p>除此之外，还有这几种常见的哈希函数构造方法：</p><ul><li><p><strong>直接定址法</strong></p><p>直接根据<code>key</code>来映射到对应的数组位置，例如1232放到下标1232的位置。</p></li><li><p><strong>数字分析法</strong></p><p>取<code>key</code>的某些数字（例如十位和百位）作为映射的位置</p></li><li><p><strong>平方取中法</strong></p><p>取<code>key</code>平方的中间几位作为映射的位置</p></li><li><p><strong>折叠法</strong></p><p>将<code>key</code>分割成位数相同的几段，然后把它们的叠加和作为映射的位置</p></li></ul><p><img src="https://s2.loli.net/2023/03/25/XEjGVp6WPYUfbhe.png" alt="散列函数构造"></p><center>散列函数构造</center><h2 id="解决哈希冲突有哪些方法呢？"><a href="#解决哈希冲突有哪些方法呢？" class="headerlink" title="解决哈希冲突有哪些方法呢？"></a>解决哈希冲突有哪些方法呢？</h2><p>我们到现在已经知道，HashMap使用链表的原因为了处理哈希冲突，这种方法就是所谓的：</p><ul><li><strong>链地址法</strong>：在冲突的位置拉一个链表，把冲突的元素放进去。</li></ul><p>除此之外，还有一些常见的解决冲突的办法：</p><ul><li><p><strong>开放定址法</strong>：开放定址法就是从冲突的位置再接着往下找，给冲突元素找个空位。</p><p>找到空闲位置的方法也有很多种：</p><ul><li>线行探查法: 从冲突的位置开始，依次判断下一个位置是否空闲，直至找到空闲位置</li><li>平方探查法: 从冲突的位置x开始，第一次增加<code>1^2</code>个位置，第二次增加<code>2^2</code>…，直至找到空闲的位置</li><li>……</li></ul></li></ul><p><img src="https://s2.loli.net/2023/03/25/W3TUwo5JYDEmy4P.png" alt="开放定址法"></p><center>开放定址法</center><ul><li><strong>再哈希法</strong>：换种哈希函数，重新计算冲突元素的地址。</li><li><strong>建立公共溢出区</strong>：再建一个数组，把冲突的元素放进去。</li></ul><h2 id="为什么HashMap链表转红黑树的阈值为8呢？"><a href="#为什么HashMap链表转红黑树的阈值为8呢？" class="headerlink" title="为什么HashMap链表转红黑树的阈值为8呢？"></a>为什么HashMap链表转红黑树的阈值为8呢？</h2><p>树化发生在table数组的长度大于64，且链表的长度大于8的时候。</p><p>为什么是8呢？源码的注释也给出了答案。</p><p><img src="https://s2.loli.net/2023/03/25/d7kxVqP1QWIgBSi.png" alt="源码注释"></p><center>源码注释</center><p>红黑树节点的大小大概是普通节点大小的两倍，所以转红黑树，牺牲了空间换时间，更多的是一种兜底的策略，保证极端情况下的查找效率。</p><p>阈值为什么要选8呢？和统计学有关。理想情况下，使用随机哈希码，链表里的节点符合泊松分布，出现节点个数的概率是递减的，节点个数为8的情况，发生概率仅为<code>0.00000006</code>。</p><p>至于红黑树转回链表的阈值为什么是6，而不是8？是因为如果这个阈值也设置成8，假如发生碰撞，节点增减刚好在8附近，会发生链表和红黑树的不断转换，导致资源浪费。</p><h2 id="扩容在什么时候呢？为什么扩容因子是0-75？"><a href="#扩容在什么时候呢？为什么扩容因子是0-75？" class="headerlink" title="扩容在什么时候呢？为什么扩容因子是0.75？"></a>扩容在什么时候呢？为什么扩容因子是0.75？</h2><p>为了减少哈希冲突发生的概率，当当前HashMap的元素个数达到一个临界值的时候，就会触发扩容，把所有元素rehash之后再放在扩容后的容器中，这是一个相当耗时的操作。</p><p><img src="https://s2.loli.net/2023/03/25/bMNR2QixSowtkyj.png" alt="put时，扩容"></p><center>put时，扩容</center><p>而这个<code>临界值threshold</code>就是由加载因子和当前容器的容量大小来确定的，假如采用默认的构造方法：</p><blockquote><p>临界值（threshold ）&#x3D; 默认容量（DEFAULT_INITIAL_CAPACITY） * 默认扩容因子（DEFAULT_LOAD_FACTOR）</p></blockquote><p><img src="https://s2.loli.net/2023/03/25/hrpbEqLDujkG3FW.png" alt="threshold计算"></p><center>threshold计算</center><p>那就是大于<code>16x0.75=12</code>时，就会触发扩容操作。</p><blockquote><p>那么为什么选择了0.75作为HashMap的默认加载因子呢？</p></blockquote><p>简单来说，这是对<code>空间</code>成本和<code>时间</code>成本平衡的考虑。</p><p>在HashMap中有这样一段注释：</p><p><img src="https://s2.loli.net/2023/03/25/lXsmDAQpaH8eTRF.png" alt="关于默认负载因子的注释"></p><center>关于默认负载因子的注释</center><p>我们都知道，HashMap的散列构造方式是Hash取余，负载因子决定元素个数达到多少时候扩容。</p><p>假如我们设的比较大，元素比较多，空位比较少的时候才扩容，那么发生哈希冲突的概率就增加了，查找的时间成本就增加了。</p><p>我们设的比较小的话，元素比较少，空位比较多的时候就扩容了，发生哈希碰撞的概率就降低了，查找时间成本降低，但是就需要更多的空间去存储元素，空间成本就增加了。</p><h2 id="那扩容机制了解吗？"><a href="#那扩容机制了解吗？" class="headerlink" title="那扩容机制了解吗？"></a>那扩容机制了解吗？</h2><p>HashMap是基于数组+链表和红黑树实现的，但用于存放key值的桶数组的长度是固定的，由初始化参数确定。</p><p>那么，随着数据的插入数量增加以及负载因子的作用下，就需要扩容来存放更多的数据。而扩容中有一个非常重要的点，就是jdk1.8中的优化操作，可以不需要再重新计算每一个元素的哈希值。</p><p>因为HashMap的初始容量是2的次幂，扩容之后的长度是原来的二倍，新的容量也是2的次幂，所以，元素，要么在原位置，要么在原位置再移动2的次幂。</p><p>看下这张图，n为table的长度，图<code>a</code>表示扩容前的key1和key2两种key确定索引的位置，图<code>b</code>表示扩容后key1和key2两种key确定索引位置。</p><p><img src="https://s2.loli.net/2023/03/25/j3RIFtmxeCWNAv7.png" alt="扩容之后的索引计算"></p><center>扩容之后的索引计算</center><p>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p><p><img src="https://s2.loli.net/2023/03/25/Vk8D7LUOtamPRdr.png" alt="扩容位置变化"></p><center>扩容位置变化</center><p>所以在扩容时，只需要看原来的hash值新增的那一位是0还是1就行了，是0的话索引没变，是1的化变成<code>原索引+oldCap</code>，看看如16扩容为32的示意图：</p><p><img src="https://s2.loli.net/2023/03/25/8FDaRtcOdNqbQHy.png" alt="扩容节点迁移示意图"></p><center>扩容节点迁移示意图</center><p>扩容节点迁移主要逻辑：</p><p><img src="https://s2.loli.net/2023/03/25/ItDlzMUqyZJ8gT4.png" alt="扩容主要逻辑"></p><center>扩容主要逻辑</center><h2 id="jdk1-8对HashMap主要做了哪些优化呢？为什么？"><a href="#jdk1-8对HashMap主要做了哪些优化呢？为什么？" class="headerlink" title="jdk1.8对HashMap主要做了哪些优化呢？为什么？"></a>jdk1.8对HashMap主要做了哪些优化呢？为什么？</h2><p>jdk1.8 的HashMap主要有五点优化：</p><ol><li><p><strong>数据结构</strong>：数组 + 链表改成了数组 + 链表或红黑树</p><p><code>原因</code>：发生 hash 冲突，元素会存入链表，链表过长转为红黑树，将时间复杂度由<code>O(n)</code>降为<code>O(logn)</code></p></li><li><p><strong>链表插入方式</strong>：链表的插入方式从头插法改成了尾插法</p><p>简单说就是插入时，如果数组位置上已经有元素，1.7 将新元素放到数组中，原始节点作为新节点的后继节点，1.8 遍历链表，将元素放置到链表的最后。</p><p><code>原因</code>：因为 1.7 头插法扩容时，头插法会使链表发生反转，多线程环境下会产生环。</p></li><li><p><strong>扩容rehash</strong>：扩容的时候 1.7 需要对原数组中的元素进行重新 hash 定位在新数组的位置，1.8 采用更简单的判断逻辑，不需要重新通过哈希函数计算位置，新的位置不变或索引 + 新增容量大小。</p><p><code>原因：</code>提高扩容的效率，更快地扩容。</p></li><li><p><strong>扩容时机</strong>：在插入时，1.7 先判断是否需要扩容，再插入，1.8 先进行插入，插入完成再判断是否需要扩容；</p></li><li><p><strong>散列函数</strong>：1.7 做了四次移位和四次异或，jdk1.8只做一次。</p><p><code>原因</code>：做 4 次的话，边际效用也不大，改为一次，提升效率。</p></li></ol><h2 id="你能自己设计实现一个HashMap吗？"><a href="#你能自己设计实现一个HashMap吗？" class="headerlink" title="你能自己设计实现一个HashMap吗？"></a>你能自己设计实现一个HashMap吗？</h2><p>这道题<strong>快手</strong>常考。</p><p>不要慌，红黑树版咱们多半是写不出来，但是数组+链表版还是问题不大的，详细可见： <a href="https://mp.weixin.qq.com/s/Z9yoRZW5itrtgbS-cj0bUg">手写HashMap，快手面试官直呼内行！</a>。</p><p>整体的设计：</p><ul><li>散列函数：hashCode()+除留余数法</li><li>冲突解决：链地址法</li><li>扩容：节点重新hash获取位置</li></ul><p><img src="https://s2.loli.net/2023/03/25/VlJN8DgZWFA2abi.png" alt="自定义HashMap整体结构"></p><center>自定义HashMap整体结构</center><p>完整代码：</p><p><img src="https://s2.loli.net/2023/03/25/6gz8GOhktCXFpwu.png" alt="完整代码"></p><center>完整代码</center><h2 id="HashMap-是线程安全的吗？多线程下会有什么问题？"><a href="#HashMap-是线程安全的吗？多线程下会有什么问题？" class="headerlink" title="HashMap 是线程安全的吗？多线程下会有什么问题？"></a>HashMap 是线程安全的吗？多线程下会有什么问题？</h2><p>HashMap不是线程安全的，可能会发生这些问题：</p><ul><li>多线程下扩容死循环。JDK1.7 中的 HashMap 使用头插法插入元素，在多线程的环境下，扩容的时候有可能导致环形链表的出现，形成死循环。因此，JDK1.8 使用尾插法插入元素，在扩容时会保持链表元素原本的顺序，不会出现环形链表的问题。</li><li>多线程的 put 可能导致元素的丢失。多线程同时执行 put 操作，如果计算出来的索引位置是相同的，那会造成前一个 key 被后一个 key 覆盖，从而导致元素的丢失。此问题在 JDK 1.7 和 JDK 1.8 中都存在。</li><li>put 和 get 并发时，可能导致 get 为 null。线程 1 执行 put 时，因为元素个数超出 threshold 而导致 rehash，线程 2 此时执行 get，有可能导致这个问题。这个问题在 JDK 1.7 和 JDK 1.8 中都存在。</li></ul><h2 id="有什么办法能解决HashMap线程不安全的问题呢？"><a href="#有什么办法能解决HashMap线程不安全的问题呢？" class="headerlink" title="有什么办法能解决HashMap线程不安全的问题呢？"></a>有什么办法能解决HashMap线程不安全的问题呢？</h2><p>Java 中有 HashTable、Collections.synchronizedMap、以及 ConcurrentHashMap 可以实现线程安全的 Map。</p><ul><li>HashTable 是直接在操作方法上加 synchronized 关键字，锁住整个table数组，粒度比较大；</li><li>Collections.synchronizedMap 是使用 Collections 集合工具的内部类，通过传入 Map 封装出一个 SynchronizedMap 对象，内部定义了一个对象锁，方法内通过对象锁实现；</li><li>ConcurrentHashMap 在jdk1.7中使用分段锁，在jdk1.8中使用CAS+synchronized。</li></ul><h2 id="能具体说一下ConcurrentHashmap的实现吗？"><a href="#能具体说一下ConcurrentHashmap的实现吗？" class="headerlink" title="能具体说一下ConcurrentHashmap的实现吗？"></a>能具体说一下ConcurrentHashmap的实现吗？</h2><p>ConcurrentHashmap线程安全在jdk1.7版本是基于<code>分段锁</code>实现，在jdk1.8是基于<code>CAS+synchronized</code>实现。</p><h3 id="1-7分段锁"><a href="#1-7分段锁" class="headerlink" title="1.7分段锁"></a>1.7分段锁</h3><p>从结构上说，1.7版本的ConcurrentHashMap采用分段锁机制，里面包含一个Segment数组，Segment继承于ReentrantLock，Segment则包含HashEntry的数组，HashEntry本身就是一个链表的结构，具有保存key、value的能力能指向下一个节点的指针。</p><p>实际上就是相当于每个Segment都是一个HashMap，默认的Segment长度是16，也就是支持16个线程的并发写，Segment之间相互不会受到影响。</p><p><img src="https://s2.loli.net/2023/03/25/1DAjO2EceYS4Ush.png" alt="1.7ConcurrentHashMap示意图"></p><center>1.7ConcurrentHashMap示意图</center><p><strong>put流程</strong></p><p>整个流程和HashMap非常类似，只不过是先定位到具体的Segment，然后通过ReentrantLock去操作而已，后面的流程，就和HashMap基本上是一样的。</p><ol><li>计算hash，定位到segment，segment如果是空就先初始化</li><li>使用ReentrantLock加锁，如果获取锁失败则尝试自旋，自旋超过次数就阻塞获取，保证一定获取锁成功</li><li>遍历HashEntry，就是和HashMap一样，数组中key和hash一样就直接替换，不存在就再插入链表，链表同样操作</li></ol><p><img src="https://s2.loli.net/2023/03/25/dCJ3UvKiZhacN52.jpg" alt="jdk1.7 put流程"></p><p><strong>get流程</strong></p><p>get也很简单，key通过hash定位到segment，再遍历链表定位到具体的元素上，需要注意的是value是volatile的，所以get是不需要加锁的。</p><h3 id="1-8-CAS-synchronized"><a href="#1-8-CAS-synchronized" class="headerlink" title="1.8 CAS+synchronized"></a><strong>1.8 CAS+synchronized</strong></h3><p>jdk1.8实现线程安全不是在数据结构上下功夫，它的数据结构和HashMap是一样的，数组+链表+红黑树。它实现线程安全的关键点在于put流程。</p><p><strong>put流程</strong></p><ol><li>首先计算hash，遍历node数组，如果node是空的话，就通过CAS+自旋的方式初始化</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tab = initTable();</span><br></pre></td></tr></table></figure><p>node数组初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="type">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果正在初始化或者扩容</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//等待</span></span><br><span class="line">            Thread.<span class="keyword">yield</span>(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;   <span class="comment">//CAS操作</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.如果当前数组位置是空则直接通过CAS自旋写入数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="type">boolean</span> <span class="title function_">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i,</span></span><br><span class="line"><span class="params">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="type">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果hash&#x3D;&#x3D;MOVED，说明需要扩容，执行扩容</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">                tab = helpTransfer(tab, f);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; <span class="type">int</span> sc;</span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="literal">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</span><br><span class="line">        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> resizeStamp(tab.length);</span><br><span class="line">        <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">               (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">                transfer(tab, nextTab);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果都不满足，就使用synchronized写入数据，写入数据同样判断链表、红黑树，链表写入和HashMap的方式一样，key hash一样就覆盖，反之就尾插法，链表长度超过8就转换成红黑树</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (f)&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/03/25/Sy2FxOUk9MumcI4.jpg" alt="ConcurrentHashmap jdk1.8put流程"></p><center>ConcurrentHashmap jdk1.8put流程</center><p><strong>get查询</strong></p><p>get很简单，和HashMap基本相同，通过key计算位置，table该位置key相同就返回，如果是红黑树按照红黑树获取，否则就遍历链表获取。</p><h2 id="HashMap-内部节点是有序的吗？"><a href="#HashMap-内部节点是有序的吗？" class="headerlink" title="HashMap 内部节点是有序的吗？"></a>HashMap 内部节点是有序的吗？</h2><p>HashMap是无序的，根据 hash 值随机插入。如果想使用有序的Map，可以使用LinkedHashMap 或者 TreeMap。</p><h2 id="讲讲-LinkedHashMap-怎么实现有序的？"><a href="#讲讲-LinkedHashMap-怎么实现有序的？" class="headerlink" title="讲讲 LinkedHashMap 怎么实现有序的？"></a>讲讲 LinkedHashMap 怎么实现有序的？</h2><p>LinkedHashMap维护了一个双向链表，有头尾节点，同时 LinkedHashMap 节点 Entry 内部除了继承 HashMap 的 Node 属性，还有 before 和 after 用于标识前置节点和后置节点。</p><p><img src="https://s2.loli.net/2023/03/25/YhRlEvASn2GxaWf.png" alt="Entry节点"></p><center>Entry节点</center><p>可以实现按插入的顺序或访问顺序排序。</p><p><img src="https://s2.loli.net/2023/03/25/LMi9pVtx7bGgDEs.png" alt="LinkedHashMap实现原理"></p><center>LinkedHashMap实现原理</center><h2 id="讲讲-TreeMap-怎么实现有序的？"><a href="#讲讲-TreeMap-怎么实现有序的？" class="headerlink" title="讲讲 TreeMap 怎么实现有序的？"></a>讲讲 TreeMap 怎么实现有序的？</h2><p>TreeMap 是按照 Key 的自然顺序或者 Comprator 的顺序进行排序，内部是通过红黑树来实现。所以要么 key 所属的类实现 Comparable 接口，或者自定义一个实现了 Comparator 接口的比较器，传给 TreeMap 用于 key 的比较。</p><p><img src="https://s2.loli.net/2023/03/25/IoF3tMSGq2vzn8P.png" alt="TreeMap"></p><center>TreeMap</center><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>Set面试没啥好问的，拿HashSet来凑个数。</p><h2 id="讲讲HashSet的底层实现？"><a href="#讲讲HashSet的底层实现？" class="headerlink" title="讲讲HashSet的底层实现？"></a>讲讲HashSet的底层实现？</h2><p>HashSet 底层就是基于 HashMap 实现的。（ HashSet 的源码⾮常⾮常少，因为除了 clone() 、 writeObject() 、 readObject() 是 HashSet⾃⼰不得不实现之外，其他⽅法都是直接调⽤ HashMap 中的⽅法。</p><p>HashSet的add方法，直接调用HashMap的put方法，将添加的元素作为key，new一个Object作为value，直接调用HashMap的put方法，它会根据返回值是否为空来判断是否插入元素成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/03/25/KVYnWC7e95Fu31i.png" alt="HashSet套娃"></p><center>HashSet套娃</center><p>而在HashMap的putVal方法中，进行了一系列判断，最后的结果是，只有在key在table数组中不存在的时候，才会返回插入的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">    <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">    <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">        e.value = value;</span><br><span class="line">    afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面渣逆袭 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面渣逆袭 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面渣逆袭-Java并发编程</title>
      <link href="/Blog/2023/03/23/interview/%E9%9D%A2%E6%B8%A3%E9%80%86%E8%A2%AD-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
      <url>/Blog/2023/03/23/interview/%E9%9D%A2%E6%B8%A3%E9%80%86%E8%A2%AD-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="并行跟并发有什么区别？"><a href="#并行跟并发有什么区别？" class="headerlink" title="并行跟并发有什么区别？"></a>并行跟并发有什么区别？</h2><p>从操作系统的角度来看，线程是CPU分配的最小单位。</p><ul><li>并行就是同一时刻，两个线程都在执行。这就要求有两个CPU去分别执行两个线程。</li><li>并发就是同一时刻，只有一个执行，但是一个时间段内，两个线程都执行了。并发的实现依赖于CPU切换线程，因为切换的时间特别短，所以基本对于用户是无感知的。</li></ul><p><img src="https://s2.loli.net/2023/03/26/eziMS5qWXpIx6Gc.png" alt="并行和并发"></p><center>并行和并发</center><p>就好像我们去食堂打饭，并行就是我们在多个窗口排队，几个阿姨同时打菜；并发就是我们挤在一个窗口，阿姨给这个打一勺，又手忙脚乱地给那个打一勺。</p><p><img src="https://s2.loli.net/2023/03/26/ciyl8QbYSuqfjWz.png" alt="并行并发和食堂打饭"></p><center>并行并发和食堂打饭</center><h2 id="说说什么是进程和线程？"><a href="#说说什么是进程和线程？" class="headerlink" title="说说什么是进程和线程？"></a>说说什么是进程和线程？</h2><p>要说线程，必须得先说说进程。</p><ul><li>进程：进程是代码在数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位。</li><li>线程：线程是进程的一个执行路径，一个进程中至少有一个线程，进程中的多个线程共享进程的资源。</li></ul><p>操作系统在分配资源时是把资源分配给进程的， 但是 CPU 资源比较特殊，它是被分配到线程的，因为真正要占用CPU运行的是线程，所以也说线程是 CPU分配的基本单位。</p><p>比如在Java中，当我们启动 main 函数其实就启动了一个JVM进程，而 main 函数在的线程就是这个进程中的一个线程，也称主线程。</p><p><img src="https://s2.loli.net/2023/03/26/UtSiT9lypJxfn7d.png" alt="程序进程线程关系"></p><center>程序进程线程关系</center><p>一个进程中有多个线程，多个线程共用进程的堆和方法区资源，但是每个线程有自己的程序计数器和栈。</p><h2 id="说说线程有几种创建方式？"><a href="#说说线程有几种创建方式？" class="headerlink" title="说说线程有几种创建方式？"></a>说说线程有几种创建方式？</h2><p>Java中创建线程主要有三种方式，分别为继承Thread类、实现Runnable接口、实现Callable接口。</p><p><img src="https://s2.loli.net/2023/03/26/i8jWvXQAoGqFHMR.png" alt="线程创建三种方式"></p><center>线程创建三种方式</center><ul><li>继承Thread类，重写run()方法，调用start()方法启动线程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 继承Thread类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;This is child thread&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现 Runnable 接口，重写run()方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Runnable!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RunnableTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RunnableTask</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两种都是没有返回值的，但是如果我们需要获取线程的执行结果，该怎么办呢？</p><ul><li>实现Callable接口，重写call()方法，这种方式可以通过FutureTask获取任务执行的返回值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallerTask</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello,i am running!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建异步任务</span></span><br><span class="line">        FutureTask&lt;String&gt; task=<span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;String&gt;(<span class="keyword">new</span> <span class="title class_">CallerTask</span>());</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//等待执行完成，并获取返回结果</span></span><br><span class="line">            String result=task.get();</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为什么调用start-方法时会执行run-方法，那怎么不直接调用run-方法？"><a href="#为什么调用start-方法时会执行run-方法，那怎么不直接调用run-方法？" class="headerlink" title="为什么调用start()方法时会执行run()方法，那怎么不直接调用run()方法？"></a>为什么调用start()方法时会执行run()方法，那怎么不直接调用run()方法？</h2><p>JVM执行start方法，会先创建一条线程，由创建出来的新线程去执行thread的run方法，这才起到多线程的效果。</p><p><img src="https://s2.loli.net/2023/03/26/mBwuQW7ovFGtTPE.png" alt="start方法"></p><center>start方法</center><p><strong>为什么我们不能直接调用run()方法？</strong>也很清楚， 如果直接调用Thread的run()方法，那么run方法还是运行在主线程中，相当于顺序执行，就起不到多线程的效果。</p><h2 id="线程有哪些常用的调度方法？"><a href="#线程有哪些常用的调度方法？" class="headerlink" title="线程有哪些常用的调度方法？"></a>线程有哪些常用的调度方法？</h2><p><img src="https://s2.loli.net/2023/03/26/t43V5jcZbSTh1NG.png" alt="线程常用调度方法"></p><center>线程常用调度方法</center><p><strong>线程等待与通知</strong></p><p>在Object类中有一些函数可以用于线程的等待与通知。</p><ul><li>wait()：当一个线程A调用一个共享变量的 wait()方法时， 线程A会被阻塞挂起， 发生下面几种情况才会返回 ：<ul><li>（1） 线程A调用了共享对象 notify()或者 notifyAll()方法；</li><li>（2）其他线程调用了线程A的 interrupt() 方法，线程A抛出InterruptedException异常返回。</li></ul></li><li>wait(long timeout) ：这个方法相比 wait() 方法多了一个超时参数，它的不同之处在于，如果线程A调用共享对象的wait(long timeout)方法后，没有在指定的 timeout ms时间内被其它线程唤醒，那么这个方法还是会因为超时而返回。</li><li>wait(long timeout, int nanos)，其内部调用的是 wait(long timout）函数。</li></ul><p>上面是线程等待的方法，而唤醒线程主要是下面两个方法：</p><ul><li>notify() : 一个线程A调用共享对象的 notify() 方法后，会唤醒一个在这个共享变量上调用 wait 系列方法后被挂起的线程。 一个共享变量上可能会有多个线程在等待，具体唤醒哪个等待的线程是随机的。</li><li>notifyAll() ：不同于在共享变量上调用 notify() 函数会唤醒被阻塞到该共享变量上的一个线程，notifyAll()方法则会唤醒所有在该共享变量上由于调用 wait 系列方法而被挂起的线程。</li></ul><p>Thread类也提供了一个方法用于等待的方法：</p><ul><li><p>join()：如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后才</p><p>从thread.join()返回。</p></li></ul><p><strong>线程休眠</strong></p><ul><li>sleep(long millis) :Thread类中的静态方法，当一个执行中的线程A调用了Thread 的sleep方法后，线程A会暂时让出指定时间的执行权，但是线程A所拥有的监视器资源，比如锁还是持有不让出的。指定的睡眠时间到了后该函数会正常返回，接着参与 CPU 的调度，获取到 CPU 资源后就可以继续运行。</li></ul><p><strong>让出优先权</strong></p><ul><li>yield() ：Thread类中的静态方法，当一个线程调用 yield 方法时，实际就是在暗示线程调度器当前线程请求让出自己的CPU ，但是线程调度器可以无条件忽略这个暗示。</li></ul><p><strong>线程中断</strong></p><p>Java 中的线程中断是一种线程间的协作模式，通过设置线程的中断标志并不能直接终止该线程的执行，而是被中断的线程根据中断状态自行处理。</p><ul><li>void interrupt() ：中断线程，例如，当线程A运行时，线程B可以调用线程interrupt() 方法来设置线程的中断标志为true 并立即返回。设置标志仅仅是设置标志, 线程A实际并没有被中断， 会继续往下执行。</li><li>boolean isInterrupted() 方法： 检测当前线程是否被中断。</li><li>boolean interrupted() 方法： 检测当前线程是否被中断，与 isInterrupted 不同的是，该方法如果发现当前线程被中断，则会清除中断标志。</li></ul><h2 id="线程有几种状态？"><a href="#线程有几种状态？" class="headerlink" title="线程有几种状态？"></a>线程有几种状态？</h2><p>在Java中，线程共有六种状态：</p><table><thead><tr><th>状态</th><th>说明</th></tr></thead><tbody><tr><td>NEW</td><td>初始状态：线程被创建，但还没有调用start()方法</td></tr><tr><td>RUNNABLE</td><td>运行状态：Java线程将操作系统中的就绪和运行两种状态笼统的称作“运行”</td></tr><tr><td>BLOCKED</td><td>阻塞状态：表示线程阻塞于锁</td></tr><tr><td>WAITING</td><td>等待状态：表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作（通知或中断）</td></tr><tr><td>TIME_WAITING</td><td>超时等待状态：该状态不同于 WAITIND，它是可以在指定的时间自行返回的</td></tr><tr><td>TERMINATED</td><td>终止状态：表示当前线程已经执行完毕</td></tr></tbody></table><p>线程在自身的生命周期中， 并不是固定地处于某个状态，而是随着代码的执行在不同的状态之间进行切换，Java线程状态变化如图示：</p><p><img src="https://s2.loli.net/2023/03/26/mRJFlo67CNvA9Lg.png" alt="Java线程状态变化">Java线程状态变化</p><h2 id="什么是线程上下文切换？"><a href="#什么是线程上下文切换？" class="headerlink" title="什么是线程上下文切换？"></a>什么是线程上下文切换？</h2><p>使用多线程的目的是为了充分利用CPU，但是我们知道，并发其实是一个CPU来应付多个线程。</p><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javathread-8.png" alt="线程切换"></p><center>线程切换</center><p>为了让用户感觉多个线程是在同时执行的， CPU 资源的分配采用了时间片轮转也就是给每个线程分配一个时间片，线程在时间片内占用 CPU 执行任务。当线程使用完时间片后，就会处于就绪状态并让出 CPU 让其他线程占用，这就是上下文切换。</p><p><img src="https://s2.loli.net/2023/03/26/JRxVPqOcNADY5L9.png" alt="上下文切换时机"></p><center>上下文切换时机</center><h2 id="守护线程了解吗？"><a href="#守护线程了解吗？" class="headerlink" title="守护线程了解吗？"></a>守护线程了解吗？</h2><p>Java中的线程分为两类，分别为 daemon 线程（守护线程）和 user 线程（用户线程）。</p><p>在JVM 启动时会调用 main 函数，main函数所在的线程就是一个用户线程。其实在 JVM 内部同时还启动了很多守护线程， 比如垃圾回收线程。</p><p>那么守护线程和用户线程有什么区别呢？区别之一是当最后一个非守护线程束时， JVM会正常退出，而不管当前是否存在守护线程，也就是说守护线程是否结束并不影响 JVM退出。换而言之，只要有一个用户线程还没结束，正常情况下JVM就不会退出。</p><h2 id="线程间有哪些通信方式？"><a href="#线程间有哪些通信方式？" class="headerlink" title="线程间有哪些通信方式？"></a>线程间有哪些通信方式？</h2><p><img src="https://s2.loli.net/2023/03/26/xQSL4sBFnUq1cPM.png" alt="线程间通信方式"></p><center>线程间通信方式</center><ul><li><strong>volatile和synchronized关键字</strong></li></ul><p>关键字volatile可以用来修饰字段（成员变量），就是告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访问的可见性。</p><p>关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性。</p><ul><li><strong>等待&#x2F;通知机制</strong></li></ul><p>可以通过Java内置的等待&#x2F;通知机制（wait()&#x2F;notify()）实现一个线程修改一个对象的值，而另一个线程感知到了变化，然后进行相应的操作。</p><ul><li><strong>管道输入&#x2F;输出流</strong></li></ul><p>管道输入&#x2F;输出流和普通的文件输入&#x2F;输出流或者网络输入&#x2F;输出流不同之处在于，它主要用于线程之间的数据传输，而传输的媒介为内存。</p><p>管道输入&#x2F;输出流主要包括了如下4种具体实现：PipedOutputStream、PipedInputStream、 PipedReader和PipedWriter，前两种面向字节，而后两种面向字符。</p><ul><li><strong>使用Thread.join()</strong></li></ul><p>如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后才从thread.join()返回。。线程Thread除了提供join()方法之外，还提供了join(long millis)和join(long millis,int nanos)两个具备超时特性的方法。</p><ul><li><strong>使用ThreadLocal</strong></li></ul><p>ThreadLocal，即线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结构。这个结构被附带在线程上，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值。</p><p>可以通过set(T)方法来设置一个值，在当前线程下再通过get()方法获取到原先设置的值。</p><blockquote><p>关于多线程，其实很大概率还会出一些笔试题，比如交替打印、银行转账、生产消费模型等等，后面老三会单独出一期来盘点一下常见的多线程笔试题。</p></blockquote><h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p>ThreadLocal其实应用场景不是很多，但却是被炸了千百遍的面试老油条，涉及到多线程、数据结构、JVM，可问的点比较多，一定要拿下。</p><h2 id="ThreadLocal是什么？"><a href="#ThreadLocal是什么？" class="headerlink" title="ThreadLocal是什么？"></a>ThreadLocal是什么？</h2><p>ThreadLocal，也就是线程本地变量。如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地拷贝，多个线程操作这个变量的时候，实际是操作自己本地内存里面的变量，从而起到线程隔离的作用，避免了线程安全问题。</p><p><img src="https://s2.loli.net/2023/03/26/nk9FdMoGCxb3O6z.png" alt="ThreadLocal线程副本"></p><center>ThreadLocal线程副本</center><ul><li>创建</li></ul><p>创建了一个ThreadLoca变量localVariable，任何一个线程都能并发访问localVariable。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个ThreadLocal变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; localVariable = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><ul><li>写入</li></ul><p>线程可以在任何地方使用localVariable，写入变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localVariable.set(<span class="string">&quot;鄙人三某”);</span></span><br></pre></td></tr></table></figure><ul><li>读取</li></ul><p>线程在任何地方读取的都是它写入的变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localVariable.get();</span><br></pre></td></tr></table></figure><h2 id="你在工作中用到过ThreadLocal吗？"><a href="#你在工作中用到过ThreadLocal吗？" class="headerlink" title="你在工作中用到过ThreadLocal吗？"></a>你在工作中用到过ThreadLocal吗？</h2><p>有用到过的，用来做用户信息上下文的存储。</p><p>我们的系统应用是一个典型的MVC架构，登录后的用户每次访问接口，都会在请求头中携带一个token，在控制层可以根据这个token，解析出用户的基本信息。那么问题来了，假如在服务层和持久层都要用到用户信息，比如rpc调用、更新用户获取等等，那应该怎么办呢？</p><p>一种办法是显式定义用户相关的参数，比如账号、用户名……这样一来，我们可能需要大面积地修改代码，多少有点瓜皮，那该怎么办呢？</p><p>这时候我们就可以用到ThreadLocal，在控制层拦截请求把用户信息存入ThreadLocal，这样我们在任何一个地方，都可以取出ThreadLocal中存的用户数据。</p><p><img src="https://s2.loli.net/2023/03/26/PwFUYcHuaB5sWGX.png" alt="ThreadLoca存放用户上下文"></p><center>ThreadLoca存放用户上下文</center><p>很多其它场景的cookie、session等等数据隔离也都可以通过ThreadLocal去实现。</p><p>我们常用的数据库连接池也用到了ThreadLocal：</p><ul><li>数据库连接池的连接交给ThreadLoca进行管理，保证当前线程的操作都是同一个Connnection。</li></ul><h2 id="ThreadLocal怎么实现的呢？"><a href="#ThreadLocal怎么实现的呢？" class="headerlink" title="ThreadLocal怎么实现的呢？"></a>ThreadLocal怎么实现的呢？</h2><p>我们看一下ThreadLocal的set(T)方法，发现先获取到当前线程，再获取<code>ThreadLocalMap</code>，然后把元素存到这个map中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="comment">//获取当前线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">//获取ThreadLocalMap</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="comment">//讲当前元素存入map</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadLocal实现的秘密都在这个<code>ThreadLocalMap</code>了，可以Thread类中定义了一个类型为<code>ThreadLocal.ThreadLocalMap</code>的成员变量<code>threadLocals</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">   <span class="comment">//ThreadLocal.ThreadLocalMap是Thread的属性</span></span><br><span class="line">   ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadLocalMap既然被称为Map，那么毫无疑问它是&lt;key,value&gt;型的数据结构。我们都知道map的本质是一个个&lt;key,value&gt;形式的节点组成的数组，那ThreadLocalMap的节点是什么样的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//节点类</span></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="comment">//key赋值</span></span><br><span class="line">        <span class="built_in">super</span>(k);</span><br><span class="line">        <span class="comment">//value赋值</span></span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的节点，key可以简单低视作ThreadLocal，value为代码中放入的值，当然实际上key并不是ThreadLocal本身，而是它的一个<strong>弱引用</strong>，可以看到Entry的key继承了 WeakReference（弱引用），再来看一下key怎么赋值的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">WeakReference</span><span class="params">(T referent)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(referent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>key的赋值，使用的是WeakReference的赋值。</p><p><img src="https://s2.loli.net/2023/03/26/ju4zfwcVFEXyqDh.png" alt="ThreadLoca结构图"></p><center>ThreadLoca结构图</center><blockquote><p>所以，怎么回答ThreadLocal原理？要答出这几个点：</p></blockquote><ul><li>Thread类有一个类型为ThreadLocal.ThreadLocalMap的实例变量threadLocals，每个线程都有一个属于自己的ThreadLocalMap。</li><li>ThreadLocalMap内部维护着Entry数组，每个Entry代表一个完整的对象，key是ThreadLocal的弱引用，value是ThreadLocal的泛型值。</li><li>每个线程在往ThreadLocal里设置值的时候，都是往自己的ThreadLocalMap里存，读也是以某个ThreadLocal作为引用，在自己的map里找对应的key，从而实现了线程隔离。</li><li>ThreadLocal本身不存储值，它只是作为一个key来让线程往ThreadLocalMap里存取值。</li></ul><h2 id="ThreadLocal-内存泄露是怎么回事？"><a href="#ThreadLocal-内存泄露是怎么回事？" class="headerlink" title="ThreadLocal 内存泄露是怎么回事？"></a>ThreadLocal 内存泄露是怎么回事？</h2><p>我们先来分析一下使用ThreadLocal时的内存，我们都知道，在JVM中，栈内存线程私有，存储了对象的引用，堆内存线程共享，存储了对象实例。</p><p>所以呢，栈中存储了ThreadLocal、Thread的引用，堆中存储了它们的具体实例。</p><p><img src="https://s2.loli.net/2023/03/26/5xrpekKcZzMmFRy.png" alt="ThreadLocal内存分配"></p><center>ThreadLocal内存分配</center><p>ThreadLocalMap中使用的 key 为 ThreadLocal 的弱引用。</p><blockquote><p>“弱引用：只要垃圾回收机制一运行，不管JVM的内存空间是否充足，都会回收该对象占用的内存。”</p></blockquote><p>那么现在问题就来了，弱引用很容易被回收，如果ThreadLocal（ThreadLocalMap的Key）被垃圾回收器回收了，但是ThreadLocalMap生命周期和Thread是一样的，它这时候如果不被回收，就会出现这种情况：ThreadLocalMap的key没了，value还在，这就会<strong>造成了内存泄漏问题</strong>。</p><blockquote><p>那怎么解决内存泄漏问题呢？</p></blockquote><p>很简单，使用完ThreadLocal后，及时调用remove()方法释放内存空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;String&gt; localVariable = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    localVariable.set(<span class="string">&quot;鄙人三某”);</span></span><br><span class="line"><span class="string">    ……</span></span><br><span class="line"><span class="string">&#125; finally &#123;</span></span><br><span class="line"><span class="string">    localVariable.remove();</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>那为什么key还要设计成弱引用？</p></blockquote><p>key设计成弱引用同样是为了防止内存泄漏。</p><p>假如key被设计成强引用，如果ThreadLocal Reference被销毁，此时它指向ThreadLoca的强引用就没有了，但是此时key还强引用指向ThreadLoca，就会导致ThreadLocal不能被回收，这时候就发生了内存泄漏的问题。</p><h2 id="ThreadLocalMap的结构了解吗？"><a href="#ThreadLocalMap的结构了解吗？" class="headerlink" title="ThreadLocalMap的结构了解吗？"></a>ThreadLocalMap的结构了解吗？</h2><p>ThreadLocalMap虽然被叫做Map，其实它是没有实现Map接口的，但是结构还是和HashMap比较类似的，主要关注的是两个要素：<code>元素数组</code>和<code>散列方法</code>。</p><p><img src="https://s2.loli.net/2023/03/26/P24hG3xqYelWoNJ.png" alt="ThreadLocalMap结构示意图"></p><center>ThreadLocalMap结构示意图</center><ul><li><p>元素数组</p><p>一个table数组，存储Entry类型的元素，Entry是ThreaLocal弱引用作为key，Object作为value的结构。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Entry[] table;</span><br></pre></td></tr></table></figure><ul><li><p>散列方法</p><p>散列方法就是怎么把对应的key映射到table数组的相应下标，ThreadLocalMap用的是哈希取余法，取出key的threadLocalHashCode，然后和table数组长度减一&amp;运算（相当于取余）。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>这里的threadLocalHashCode计算有点东西，每创建一个ThreadLocal对象，它就会新增<code>0x61c88647</code>，这个值很特殊，它是<strong>斐波那契数</strong> 也叫 <strong>黄金分割数</strong>。<code>hash</code>增量为 这个数字，带来的好处就是 <code>hash</code> <strong>分布非常均匀</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HASH_INCREMENT</span> <span class="operator">=</span> <span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextHashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ThreadLocalMap怎么解决Hash冲突的？"><a href="#ThreadLocalMap怎么解决Hash冲突的？" class="headerlink" title="ThreadLocalMap怎么解决Hash冲突的？"></a>ThreadLocalMap怎么解决Hash冲突的？</h2><p>我们可能都知道HashMap使用了链表来解决冲突，也就是所谓的链地址法。</p><p>ThreadLocalMap没有使用链表，自然也不是用链地址法来解决冲突了，它用的是另外一种方式——<strong>开放定址法</strong>。开放定址法是什么意思呢？简单来说，就是这个坑被人占了，那就接着去找空着的坑。</p><p><img src="https://s2.loli.net/2023/03/26/RehL1yq2YaDmgrw.png" alt="ThreadLocalMap解决冲突"></p><center>ThreadLocalMap解决冲突</center><p>如上图所示，如果我们插入一个value&#x3D;27的数据，通过 hash计算后应该落入第 4 个槽位中，而槽位 4 已经有了 Entry数据，而且Entry数据的key和当前不相等。此时就会线性向后查找，一直找到 Entry为 null的槽位才会停止查找，把元素放到空的槽中。</p><p>在get的时候，也会根据ThreadLocal对象的hash值，定位到table中的位置，然后判断该槽位Entry对象中的key是否和get的key一致，如果不一致，就判断下一个位置。</p><h2 id="ThreadLocalMap扩容机制了解吗？"><a href="#ThreadLocalMap扩容机制了解吗？" class="headerlink" title="ThreadLocalMap扩容机制了解吗？"></a>ThreadLocalMap扩容机制了解吗？</h2><p>在ThreadLocalMap.set()方法的最后，如果执行完启发式清理工作后，未清理到任何数据，且当前散列数组中<code>Entry</code>的数量已经达到了列表的扩容阈值<code>(len*2/3)</code>，就开始执行<code>rehash()</code>逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">    rehash();</span><br></pre></td></tr></table></figure><p>再着看rehash()具体实现：这里会先去清理过期的Entry，然后还要根据条件判断<code>size &gt;= threshold - threshold / 4</code> 也就是<code>size &gt;= threshold* 3/4</code>来决定是否需要扩容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rehash</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//清理过期Entry</span></span><br><span class="line">    expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//扩容</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">        resize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清理过期Entry</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">expungeStaleEntries</span><span class="params">()</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == <span class="literal">null</span>)</span><br><span class="line">            expungeStaleEntry(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着看看具体的<code>resize()</code>方法，扩容后的<code>newTab</code>的大小为老数组的两倍，然后遍历老的table数组，散列方法重新计算位置，开放地址解决冲突，然后放到新的<code>newTab</code>，遍历完成之后，<code>oldTab</code>中所有的<code>entry</code>数据都已经放入到<code>newTab</code>中了，然后table引用指向<code>newTab</code></p><p><img src="https://s2.loli.net/2023/03/26/e9vhXli13fZkuYp.png" alt="ThreadLocalMap扩容"></p><center>ThreadLocalMap扩容</center><p>具体代码：</p><p><img src="https://s2.loli.net/2023/03/26/otjQZfn9V5FBSGy.png" alt="ThreadLocalMap resize"></p><center>ThreadLocalMap resize</center><h2 id="父子线程怎么共享数据？"><a href="#父子线程怎么共享数据？" class="headerlink" title="父子线程怎么共享数据？"></a>父子线程怎么共享数据？</h2><p>父线程能用ThreadLocal来给子线程传值吗？毫无疑问，不能。那该怎么办？</p><p>这时候可以用到另外一个类——<code>InheritableThreadLocal </code>。</p><p>使用起来很简单，在主线程的InheritableThreadLocal实例设置值，在子线程中就可以拿到了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InheritableThreadLocalTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ThreadLocal</span> <span class="variable">threadLocal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InheritableThreadLocal</span>();</span><br><span class="line">        <span class="comment">// 主线程</span></span><br><span class="line">        threadLocal.set(<span class="string">&quot;不擅技术&quot;</span>);</span><br><span class="line">        <span class="comment">//子线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="built_in">super</span>.run();</span><br><span class="line">                System.out.println(<span class="string">&quot;鄙人三某 ，&quot;</span> + threadLocal.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>那原理是什么呢？</p></blockquote><p>原理很简单，在Thread类里还有另外一个变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">inheritableThreadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>在Thread.init的时候，如果父线程的<code>inheritableThreadLocals</code>不为空，就把它赋给当前线程（子线程）的<code>inheritableThreadLocals </code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="literal">null</span>)</span><br><span class="line">    <span class="built_in">this</span>.inheritableThreadLocals =</span><br><span class="line">        ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br></pre></td></tr></table></figure><h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><h2 id="说一下你对Java内存模型（JMM）的理解？"><a href="#说一下你对Java内存模型（JMM）的理解？" class="headerlink" title="说一下你对Java内存模型（JMM）的理解？"></a>说一下你对Java内存模型（JMM）的理解？</h2><p>Java内存模型（Java Memory Model，JMM），是一种抽象的模型，被定义出来屏蔽各种硬件和操作系统的内存访问差异。</p><p>JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在<code>主内存</code>（Main Memory）中，每个线程都有一个私有的<code>本地内存</code>（Local Memory），本地内存中存储了该线程以读&#x2F;写共享变量的副本。</p><p>Java内存模型的抽象图：</p><p><img src="https://s2.loli.net/2023/03/26/iSt7KJHjXF5c9Qv.png" alt="Java内存模型"></p><center>Java内存模型</center><p>本地内存是JMM的 一个抽象概念，并不真实存在。它其实涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。</p><p><img src="https://s2.loli.net/2023/03/26/8AMvK1YcbiG34rl.png" alt="实际线程工作模型"></p><center>实际线程工作模型</center><p>图里面的是一个双核 CPU 系统架构 ，每个核有自己的控制器和运算器，其中控制器包含一组寄存器和操作控制器，运算器执行算术逻辅运算。每个核都有自己的一级缓存，在有些架构里面还有一个所有 CPU 共享的二级缓存。 那么 Java 内存模型里面的工作内存，就对应这里的 Ll 缓存或者 L2 缓存或者 CPU 寄存器。</p><h2 id="说说你对原子性、可见性、有序性的理解？"><a href="#说说你对原子性、可见性、有序性的理解？" class="headerlink" title="说说你对原子性、可见性、有序性的理解？"></a>说说你对原子性、可见性、有序性的理解？</h2><p>原子性、有序性、可见性是并发编程中非常重要的基础概念，JMM的很多技术都是围绕着这三大特性展开。</p><ul><li><strong>原子性</strong>：原子性指的是一个操作是不可分割、不可中断的，要么全部执行并且执行的过程不会被任何因素打断，要么就全不执行。</li><li><strong>可见性</strong>：可见性指的是一个线程修改了某一个共享变量的值时，其它线程能够立即知道这个修改。</li><li><strong>有序性</strong>：有序性指的是对于一个线程的执行代码，从前往后依次执行，单线程下可以认为程序是有序的，但是并发时有可能会发生指令重排。</li></ul><blockquote><p>分析下面几行代码的原子性？</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">i++;</span><br><span class="line">i = i + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><ul><li>第1句是基本类型赋值，是原子性操作。</li><li>第2句先读i的值，再赋值到j，两步操作，不能保证原子性。</li><li>第3和第4句其实是等效的，先读取i的值，再+1，最后赋值到i，三步操作了，不能保证原子性。</li></ul><blockquote><p>原子性、可见性、有序性都应该怎么保证呢？</p></blockquote><ul><li>原子性：JMM只能保证基本的原子性，如果要保证一个代码块的原子性，需要使用<code>synchronized </code>。</li><li>可见性：Java是利用<code>volatile</code>关键字来保证可见性的，除此之外，<code>final</code>和<code>synchronized</code>也能保证可见性。</li><li>有序性：<code>synchronized</code>或者<code>volatile</code>都可以保证多线程之间操作的有序性。</li></ul><h2 id="那说说什么是指令重排？"><a href="#那说说什么是指令重排？" class="headerlink" title="那说说什么是指令重排？"></a>那说说什么是指令重排？</h2><p>在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。重排序分3种类型。</p><ol><li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li><li>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应 机器指令的执行顺序。</li><li>内存系统的重排序。由于处理器使用缓存和读&#x2F;写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li></ol><p>从Java源代码到最终实际执行的指令序列，会分别经历下面3种重排序，如图：</p><p><img src="https://s2.loli.net/2023/03/26/OGxIHL3DCpUmic4.png" alt="多级指令重排"></p><center>多级指令重排</center><p>我们比较熟悉的双重校验单例模式就是一个经典的指令重排的例子，<code>Singleton instance=new Singleton()；</code>对应的JVM指令分为三步：分配内存空间–&gt;初始化对象—&gt;对象指向分配的内存空间，但是经过了编译器的指令重排序，第二步和第三步就可能会重排序。</p><p><img src="https://s2.loli.net/2023/03/26/R5MdZIeiKtQSxul.png" alt="双重校验单例模式异常情形"></p><center>双重校验单例模式异常情形</center><p>JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p><h2 id="指令重排有限制吗？happens-before了解吗？"><a href="#指令重排有限制吗？happens-before了解吗？" class="headerlink" title="指令重排有限制吗？happens-before了解吗？"></a>指令重排有限制吗？happens-before了解吗？</h2><p>指令重排也是有一些限制的，有两个规则<code>happens-before</code>和<code>as-if-serial</code>来约束。</p><p>happens-before的定义：</p><ul><li>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</li><li>两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照 happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法</li></ul><p>happens-before和我们息息相关的有六大规则：</p><p><img src="https://s2.loli.net/2023/03/26/V96mGv4nl3ue8dh.png" alt="happens-before六大规则"></p><center>happens-before六大规则</center><ul><li><strong>程序顺序规则</strong>：一个线程中的每个操作，happens-before于该线程中的任意后续操作。</li><li><strong>监视器锁规则</strong>：对一个锁的解锁，happens-before于随后对这个锁的加锁。</li><li><strong>volatile变量规则</strong>：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。</li><li><strong>传递性</strong>：如果A happens-before B，且B happens-before C，那么A happens-before C。</li><li><strong>start()规则</strong>：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的 ThreadB.start()操作happens-before于线程B中的任意操作。</li><li><strong>join()规则</strong>：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作 happens-before于线程A从ThreadB.join()操作成功返回。</li></ul><h2 id="as-if-serial又是什么？单线程的程序一定是顺序的吗？"><a href="#as-if-serial又是什么？单线程的程序一定是顺序的吗？" class="headerlink" title="as-if-serial又是什么？单线程的程序一定是顺序的吗？"></a>as-if-serial又是什么？单线程的程序一定是顺序的吗？</h2><p>as-if-serial语义的意思是：不管怎么重排序（编译器和处理器为了提高并行度），<strong>单线程程序的执行结果不能被改变</strong>。编译器、runtime和处理器都必须遵守as-if-serial语义。</p><p>为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。为了具体说明，请看下面计算圆面积的代码示例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">pi</span> <span class="operator">=</span> <span class="number">3.14</span>;   <span class="comment">// A</span></span><br><span class="line"><span class="type">double</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">1.0</span>;   <span class="comment">// B </span></span><br><span class="line"><span class="type">double</span> <span class="variable">area</span> <span class="operator">=</span> pi * r * r;   <span class="comment">// C</span></span><br></pre></td></tr></table></figure><p>上面3个操作的数据依赖关系：</p><p><img src="https://s2.loli.net/2023/03/26/UGoiJmbgA3LI1Kx.png" alt="img"></p><p>A和C之间存在数据依赖关系，同时B和C之间也存在数据依赖关系。因此在最终执行的指令序列中，C不能被重排序到A和B的前面（C排到A和B的前面，程序的结果将会被改变）。但A和B之间没有数据依赖关系，编译器和处理器可以重排序A和B之间的执行顺序。</p><p>所以最终，程序可能会有两种执行顺序：</p><p><img src="https://s2.loli.net/2023/03/26/i95om3a6LnH147q.png" alt="两种执行结果"></p><center>两种执行结果</center><p>as-if-serial语义把单线程程序保护了起来，遵守as-if-serial语义的编译器、runtime和处理器共同编织了这么一个“楚门的世界”：单线程程序是按程序的“顺序”来执行的。as- if-serial语义使单线程情况下，我们不需要担心重排序的问题，可见性的问题。</p><h2 id="volatile实现原理了解吗？"><a href="#volatile实现原理了解吗？" class="headerlink" title="volatile实现原理了解吗？"></a>volatile实现原理了解吗？</h2><p>volatile有两个作用，保证<strong>可见性</strong>和<strong>有序性</strong>。</p><blockquote><p>volatile怎么保证可见性的呢？</p></blockquote><p>相比synchronized的加锁方式来解决共享变量的内存可见性问题，volatile就是更轻量的选择，它没有上下文切换的额外开销成本。</p><p>volatile可以确保对某个变量的更新对其他线程马上可见，一个变量被声明为volatile 时，线程在写入变量时不会把值缓存在寄存器或者其他地方，而是会把值刷新回主内存 当其它线程读取该共享变量 ，会从主内存重新获取最新值，而不是使用当前线程的本地内存中的值。</p><p>例如，我们声明一个 volatile 变量 volatile int x &#x3D; 0，线程A修改x&#x3D;1，修改完之后就会把新的值刷新回主内存，线程B读取x的时候，就会清空本地内存变量，然后再从主内存获取最新值。</p><p><img src="https://s2.loli.net/2023/03/26/p6bTIgM1WmSnrxs.png" alt="volatile内存可见性"></p><center>volatile内存可见性</center><blockquote><p>volatile怎么保证有序性的呢？</p></blockquote><p>重排序可以分为编译器重排序和处理器重排序，valatile保证有序性，就是通过分别限制这两种类型的重排序。</p><p><img src="https://s2.loli.net/2023/03/26/2XbULc6k4gMHqDi.png" alt="volatile重排序规则表"></p><center>volatile重排序规则表</center><p>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</p><ol><li>在每个volatile写操作的前面插入一个<code>StoreStore</code>屏障</li><li>在每个volatile写操作的后面插入一个<code>StoreLoad</code>屏障</li><li>在每个volatile读操作的后面插入一个<code>LoadLoad</code>屏障</li><li>在每个volatile读操作的后面插入一个<code>LoadStore</code>屏障</li></ol><p><img src="https://s2.loli.net/2023/03/26/qS6s3b7nHefrwu2.png" alt="volatile写插入内存屏障后生成的指令序列示意图"></p><center>volatile写插入内存屏障后生成的指令序列示意图</center><p><img src="https://s2.loli.net/2023/03/26/GCTwgqhloIjiYU9.png" alt="volatile写插入内存屏障后生成的指令序列示意图"></p><center>volatile写插入内存屏障后生成的指令序列示意图</center><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="synchronized用过吗？怎么使用？"><a href="#synchronized用过吗？怎么使用？" class="headerlink" title="synchronized用过吗？怎么使用？"></a>synchronized用过吗？怎么使用？</h2><p>synchronized经常用的，用来保证代码的原子性。</p><p>synchronized主要有三种用法：</p><ul><li><strong>修饰实例方法:</strong> 作用于当前对象实例加锁，进入同步代码前要获得 <strong>当前对象实例的锁</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>修饰静态方法</strong>：也就是给当前类加锁，会作⽤于类的所有对象实例 ，进⼊同步代码前要获得当前 class 的锁。因为静态成员不属于任何⼀个实例对象，是类成员（ static 表明这是该类的⼀个静态资源，不管 new 了多少个对象，只有⼀份）。</p><p>如果⼀个线程 A 调⽤⼀个实例对象的⾮静态 synchronized ⽅法，⽽线程 B 需要调⽤这个实例对象所属类的静态 synchronized ⽅法，是允许的，不会发⽣互斥现象，因为访问静态 synchronized ⽅法占⽤的锁是当前类的锁，⽽访问⾮静态 synchronized ⽅法占⽤的锁是当前实例对象锁。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> staic <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>修饰代码块</strong> ：指定加锁对象，对给定对象&#x2F;类加锁。 synchronized(this|object) 表示进⼊同步代码库前要获得给定对象的锁。 synchronized(类.class) 表示进⼊同步代码前要获得 当前 <strong>class</strong> 的锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line"> <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="synchronized的实现原理？"><a href="#synchronized的实现原理？" class="headerlink" title="synchronized的实现原理？"></a>synchronized的实现原理？</h2><blockquote><p>synchronized是怎么加锁的呢？</p></blockquote><p>我们使用synchronized的时候，发现不用自己去lock和unlock，是因为JVM帮我们把这个事情做了。</p><ol><li><p>synchronized修饰代码块时，JVM采用<code>monitorenter</code>、<code>monitorexit</code>两个指令来实现同步，<code>monitorenter</code> 指令指向同步代码块的开始位置， <code>monitorexit</code> 指令则指向同步代码块的结束位置。</p><p>反编译一段synchronized修饰代码块代码，<code>javap -c -s -v -l SynchronizedDemo.class</code>，可以看到相应的字节码指令。</p></li></ol><p><img src="https://s2.loli.net/2023/03/26/51u82TWZePpq9nm.png" alt="monitorenter和monitorexit"></p><center>monitorenter和monitorexit</center><ol><li>synchronized修饰同步方法时，JVM采用<code>ACC_SYNCHRONIZED</code>标记符来实现同步，这个标识指明了该方法是一个同步方法。</li></ol><p>同样可以写段代码反编译看一下。</p><p><img src="https://s2.loli.net/2023/03/26/LXhMeTPonutjzx9.png" alt="synchronized修饰同步方法"></p><center>synchronized修饰同步方法</center><blockquote><p>synchronized锁住的是什么呢？</p></blockquote><p>monitorenter、monitorexit或者ACC_SYNCHRONIZED都是<strong>基于Monitor实现</strong>的。</p><p>实例对象结构里有对象头，对象头里面有一块结构叫Mark Word，Mark Word指针指向了<strong>monitor</strong>。</p><p>所谓的Monitor其实是一种<strong>同步工具</strong>，也可以说是一种<strong>同步机制</strong>。在Java虚拟机（HotSpot）中，Monitor是由<strong>ObjectMonitor实现</strong>的，可以叫做内部锁，或者Monitor锁。</p><p>ObjectMonitor的工作原理：</p><ul><li>ObjectMonitor有两个队列：_WaitSet、_EntryList，用来保存ObjectWaiter 对象列表。</li><li>_owner，获取 Monitor 对象的线程进入 _owner 区时， _count + 1。如果线程调用了 wait() 方法，此时会释放 Monitor 对象， _owner 恢复为空， _count - 1。同时该等待线程进入 _WaitSet 中，等待被唤醒。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _header       = NULL;</span><br><span class="line">    _count        = <span class="number">0</span>; <span class="comment">// 记录线程获取锁的次数</span></span><br><span class="line">    _waiters      = <span class="number">0</span>,</span><br><span class="line">    _recursions   = <span class="number">0</span>;  <span class="comment">//锁的重入次数</span></span><br><span class="line">    _object       = NULL;</span><br><span class="line">    _owner        = NULL;  <span class="comment">// 指向持有ObjectMonitor对象的线程</span></span><br><span class="line">    _WaitSet      = NULL;  <span class="comment">// 处于wait状态的线程，会被加入到_WaitSet</span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = NULL ;</span><br><span class="line">    _succ         = NULL ;</span><br><span class="line">    _cxq          = NULL ;</span><br><span class="line">    FreeNext      = NULL ;</span><br><span class="line">    _EntryList    = NULL ;  <span class="comment">// 处于等待锁block状态的线程，会被加入到该列表</span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>可以类比一个去医院就诊的例子：</p><ul><li>首先，患者在<strong>门诊大厅</strong>前台或自助挂号机<strong>进行挂号</strong>；</li><li>随后，挂号结束后患者找到对应的<strong>诊室就诊</strong>：<ul><li>诊室每次只能有一个患者就诊；</li><li>如果此时诊室空闲，直接进入就诊；</li><li>如果此时诊室内有其它患者就诊，那么当前患者进入<strong>候诊室</strong>，等待叫号；</li></ul></li><li>就诊结束后，<strong>走出就诊室</strong>，候诊室的<strong>下一位候诊患者</strong>进入就诊室。</li></ul><p><img src="https://s2.loli.net/2023/03/26/XYkKIZyhF4QprN8.png" alt="就诊"></p><center>就诊</center><p>这个过程就和Monitor机制比较相似：</p><ul><li><strong>门诊大厅</strong>：所有待进入的线程都必须先在<strong>入口Entry Set</strong>挂号才有资格；</li><li><strong>就诊室</strong>：就诊室**_Owner**里里只能有一个线程就诊，就诊完线程就自行离开</li><li><strong>候诊室</strong>：就诊室繁忙时，进入<strong>等待区（Wait Set）</strong>，就诊室空闲的时候就从<strong>等待区（Wait Set）</strong>叫新的线程</li></ul><p><img src="https://s2.loli.net/2023/03/26/le1u93rt8bMNnWT.png" alt="Java Montior机制"></p><center>Java Montior机制</center><p>所以我们就知道了，同步是锁住的什么东西：</p><ul><li>monitorenter，在判断拥有同步标识 ACC_SYNCHRONIZED 抢先进入此方法的线程会优先拥有 Monitor 的 owner ，此时计数器 +1。</li><li>monitorexit，当执行完退出后，计数器 -1，归 0 后被其他进入的线程获得。</li></ul><h2 id="除了原子性，synchronized可见性，有序性，可重入性怎么实现？"><a href="#除了原子性，synchronized可见性，有序性，可重入性怎么实现？" class="headerlink" title="除了原子性，synchronized可见性，有序性，可重入性怎么实现？"></a>除了原子性，synchronized可见性，有序性，可重入性怎么实现？</h2><blockquote><p>synchronized怎么保证可见性？</p></blockquote><ul><li>线程加锁前，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值。</li><li>线程加锁后，其它线程无法获取主内存中的共享变量。</li><li>线程解锁前，必须把共享变量的最新值刷新到主内存中。</li></ul><blockquote><p>synchronized怎么保证有序性？</p></blockquote><p>synchronized同步的代码块，具有排他性，一次只能被一个线程拥有，所以synchronized保证同一时刻，代码是单线程执行的。</p><p>因为as-if-serial语义的存在，单线程的程序能保证最终结果是有序的，但是不保证不会指令重排。</p><p>所以synchronized保证的有序是执行结果的有序性，而不是防止指令重排的有序性。</p><blockquote><p>synchronized怎么实现可重入的呢？</p></blockquote><p>synchronized 是可重入锁，也就是说，允许一个线程二次请求自己持有对象锁的临界资源，这种情况称为可重入锁。</p><p>synchronized 锁对象的时候有个计数器，他会记录下线程获取锁的次数，在执行完对应的代码块之后，计数器就会-1，直到计数器清零，就释放锁了。</p><p>之所以，是可重入的。是因为 synchronized 锁对象有个计数器，会随着线程获取锁后 +1 计数，当线程执行完毕后 -1，直到清零释放锁。</p><h2 id="锁升级？synchronized优化了解吗？"><a href="#锁升级？synchronized优化了解吗？" class="headerlink" title="锁升级？synchronized优化了解吗？"></a>锁升级？synchronized优化了解吗？</h2><p>了解锁升级，得先知道，不同锁的状态是什么样的。这个状态指的是什么呢？</p><p>Java对象头里，有一块结构，叫<code>Mark Word</code>标记字段，这块结构会随着锁的状态变化而变化。</p><p>64 位虚拟机 Mark Word 是 64bit，我们来看看它的状态变化：</p><p><img src="https://s2.loli.net/2023/03/26/5pcLUMj6KWbmfuz.png" alt="Mark Word变化"></p><center>Mark Word变化</center><p>Mark Word存储对象自身的运行数据，如<strong>哈希码、GC分代年龄、锁状态标志、偏向时间戳（Epoch）</strong> 等。</p><blockquote><p>synchronized做了哪些优化？</p></blockquote><p>在JDK1.6之前，synchronized的实现直接调用ObjectMonitor的enter和exit，这种锁被称之为<strong>重量级锁</strong>。从JDK6开始，HotSpot虚拟机开发团队对Java中的锁进行优化，如增加了适应性自旋、锁消除、锁粗化、轻量级锁和偏向锁等优化策略，提升了synchronized的性能。</p><ul><li>偏向锁：在无竞争的情况下，只是在Mark Word里存储当前线程指针，CAS操作都不做。</li><li>轻量级锁：在没有多线程竞争时，相对重量级锁，减少操作系统互斥量带来的性能消耗。但是，如果存在锁竞争，除了互斥量本身开销，还额外有CAS操作的开销。</li><li>自旋锁：减少不必要的CPU上下文切换。在轻量级锁升级为重量级锁时，就使用了自旋加锁的方式</li><li>锁粗化：将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。</li><li>锁消除：虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。</li></ul><blockquote><p>锁升级的过程是什么样的？</p></blockquote><p>锁升级方向：无锁–&gt;偏向锁—&gt; 轻量级锁—-&gt;重量级锁，这个方向基本上是不可逆的。</p><p><img src="https://s2.loli.net/2023/03/26/eFwIOpCza6k4vi1.png" alt="锁升级方向"></p><center>锁升级方向</center><p>我们看一下升级的过程：</p><h3 id="偏向锁："><a href="#偏向锁：" class="headerlink" title="偏向锁："></a>偏向锁：</h3><p><strong>偏向锁的获取：</strong></p><ol><li>判断是否为可偏向状态–MarkWord中锁标志是否为‘01’，是否偏向锁是否为‘1’</li><li>如果是可偏向状态，则查看线程ID是否为当前线程，如果是，则进入步骤’5’，否则进入步骤‘3’</li><li>通过CAS操作竞争锁，如果竞争成功，则将MarkWord中线程ID设置为当前线程ID，然后执行‘5’；竞争失败，则执行‘4’</li><li>CAS获取偏向锁失败表示有竞争。当达到safepoint时获得偏向锁的线程被挂起，<strong>偏向锁升级为轻量级锁</strong>，然后被阻塞在安全点的线程继续往下执行同步代码块</li><li>执行同步代码</li></ol><p><strong>偏向锁的撤销：</strong></p><ol><li>偏向锁不会主动释放(撤销)，只有遇到其他线程竞争时才会执行撤销，由于撤销需要知道当前持有该偏向锁的线程栈状态，因此要等到safepoint时执行，此时持有该偏向锁的线程（T）有‘2’，‘3’两种情况；</li><li>撤销—-T线程已经退出同步代码块，或者已经不再存活，则直接撤销偏向锁，变成无锁状态—-该状态达到阈值20则执行批量重偏向</li><li>升级—-T线程还在同步代码块中，则将T线程的偏向锁<strong>升级为轻量级锁</strong>，当前线程执行轻量级锁状态下的锁获取步骤—-该状态达到阈值40则执行批量撤销</li></ol><h3 id="轻量级锁："><a href="#轻量级锁：" class="headerlink" title="轻量级锁："></a>轻量级锁：</h3><p><strong>轻量级锁的获取：</strong></p><ol><li>进行加锁操作时，jvm会判断是否已经时重量级锁，如果不是，则会在当前线程栈帧中划出一块空间，作为该锁的锁记录，并且将锁对象MarkWord复制到该锁记录中</li><li>复制成功之后，jvm使用CAS操作将对象头MarkWord更新为指向锁记录的指针，并将锁记录里的owner指针指向对象头的MarkWord。如果成功，则执行‘3’，否则执行‘4’</li><li>更新成功，则当前线程持有该对象锁，并且对象MarkWord锁标志设置为‘00’，即表示此对象处于轻量级锁状态</li><li>更新失败，jvm先检查对象MarkWord是否指向当前线程栈帧中的锁记录，如果是则执行‘5’，否则执行‘4’</li><li>表示锁重入；然后当前线程栈帧中增加一个锁记录第一部分（Displaced Mark Word）为null，并指向Mark Word的锁对象，起到一个重入计数器的作用。</li><li>表示该锁对象已经被其他线程抢占，则进行<strong>自旋等待</strong>（默认10次），等待次数达到阈值仍未获取到锁，则<strong>升级为重量级锁</strong></li></ol><p>大体上省简的升级过程：</p><p><img src="https://s2.loli.net/2023/03/26/FzXEH57hVQtW4Rg.png" alt="锁升级简略过程"></p><center>锁升级简略过程</center><p>完整的升级过程：</p><p><img src="https://s2.loli.net/2023/03/26/oCg32zsUHqJX4rN.png" alt="synchronized 锁升级过程"></p><center>synchronized</center><h2 id="说说synchronized和ReentrantLock的区别？"><a href="#说说synchronized和ReentrantLock的区别？" class="headerlink" title="说说synchronized和ReentrantLock的区别？"></a>说说synchronized和ReentrantLock的区别？</h2><p>可以从锁的实现、功能特点、性能等几个维度去回答这个问题：</p><ul><li><p><strong>锁的实现：</strong> synchronized是Java语言的关键字，基于JVM实现。而ReentrantLock是基于JDK的API层面实现的（一般是lock()和unlock()方法配合try&#x2F;finally 语句块来完成。）</p></li><li><p><strong>性能：</strong> 在JDK1.6锁优化以前，synchronized的性能比ReenTrantLock差很多。但是JDK6开始，增加了适应性自旋、锁消除等，两者性能就差不多了。</p></li><li><p>功能特点：</p><p>ReentrantLock 比 synchronized 增加了一些高级功能，如等待可中断、可实现公平锁、可实现选择性通知。</p><ul><li>ReentrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制</li><li>ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。</li><li>synchronized与wait()和notify()&#x2F;notifyAll()方法结合实现等待&#x2F;通知机制，ReentrantLock类借助Condition接口与newCondition()方法实现。</li><li>ReentrantLock需要手工声明来加锁和释放锁，一般跟finally配合释放锁。而synchronized不用手动释放锁。</li></ul></li></ul><p>下面的表格列出出了两种锁之间的区别：</p><p><img src="https://s2.loli.net/2023/03/26/sY21ycaQFXemr3z.png" alt="synchronized和ReentrantLock的区别"></p><center>synchronized和ReentrantLock的区别</center><h2 id="AQS了解多少？"><a href="#AQS了解多少？" class="headerlink" title="AQS了解多少？"></a>AQS了解多少？</h2><p>AbstractQueuedSynchronizer 抽象同步队列，简称 AQS ，它是Java并发包的根基，并发包中的锁就是基于AQS实现的。</p><ul><li>AQS是基于一个FIFO的双向队列，其内部定义了一个节点类Node，Node 节点内部的 SHARED 用来标记该线程是获取共享资源时被阻挂起后放入AQS 队列的， EXCLUSIVE 用来标记线程是 取独占资源时被挂起后放入AQS 队列</li><li>AQS 使用一个 volatile 修饰的 int 类型的成员变量 state 来表示同步状态，修改同步状态成功即为获得锁，volatile 保证了变量在多线程之间的可见性，修改 State 值时通过 CAS 机制来保证修改的原子性</li><li>获取state的方式分为两种，独占方式和共享方式，一个线程使用独占方式获取了资源，其它线程就会在获取失败后被阻塞。一个线程使用共享方式获取了资源，另外一个线程还可以通过CAS的方式进行获取。</li><li>如果共享资源被占用，需要一定的阻塞等待唤醒机制来保证锁的分配，AQS 中会将竞争共享资源失败的线程添加到一个变体的 CLH 队列中。</li></ul><p><img src="https://s2.loli.net/2023/03/26/7S2ATmYhrUNHVy3.png" alt="AQS抽象队列同步器"></p><center>AQS抽象队列同步器</center><p><img src="https://s2.loli.net/2023/03/26/KuedXmCB2zntpP8.png" alt="CLH队列"></p><center>CLH队列</center><p>AQS 中的队列是 CLH 变体的虚拟双向队列，通过将每条请求共享资源的线程封装成一个节点来实现锁的分配：</p><p><img src="https://s2.loli.net/2023/03/26/HSAFk7iyhzwbr8v.png" alt="AQS变种CLH队列"></p><center>AQS变种CLH队列</center><p>AQS 中的 CLH 变体等待队列拥有以下特性：</p><ul><li>AQS 中队列是个双向链表，也是 FIFO 先进先出的特性</li><li>通过 Head、Tail 头尾两个节点来组成队列结构，通过 volatile 修饰保证可见性</li><li>Head 指向节点为已获得锁的节点，是一个虚拟节点，节点本身不持有具体线程</li><li>获取不到同步状态，会将节点进行自旋获取锁，自旋一定次数失败后会将线程阻塞，相对于 CLH 队列性能较好</li></ul><p>ps:AQS源码里面有很多细节可问，建议有时间好好看看AQS源码。</p><h2 id="ReentrantLock实现原理？"><a href="#ReentrantLock实现原理？" class="headerlink" title="ReentrantLock实现原理？"></a><strong>ReentrantLock</strong>实现原理？</h2><p>ReentrantLock 是可重入的独占锁，只能有一个线程可以获取该锁，其它获取该锁的线程会被阻塞而被放入该锁的阻塞队列里面。</p><p>看看ReentrantLock的加锁操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建非公平锁</span></span><br><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">// 获取锁操作</span></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行代码逻辑</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 解锁操作</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>new ReentrantLock() </code>构造函数默认创建的是非公平锁 NonfairSync。</p><p><strong>公平锁 FairSync</strong></p><ol><li>公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁</li><li>公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU 唤醒阻塞线程的开销比非公平锁大</li></ol><p><strong>非公平锁 NonfairSync</strong></p><ul><li>非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁</li><li>非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU 不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁</li></ul><p>默认创建的对象lock()的时候：</p><ul><li>如果锁当前没有被其它线程占用，并且当前线程之前没有获取过该锁，则当前线程会获取到该锁，然后设置当前锁的拥有者为当前线程，并设置 AQS 的状态值为1 ，然后直接返回。如果当前线程之前己经获取过该锁，则这次只是简单地把 AQS 的状态值加1后返回。</li><li>如果该锁己经被其他线程持有，非公平锁会尝试去获取锁，获取失败的话，则调用该方法线程会被放入 AQS 队列阻塞挂起。</li></ul><p><img src="https://s2.loli.net/2023/03/26/HDdG572KFVafikJ.png" alt="ReentrantLock 非公平锁加锁流程简图"></p><center>ReentrantLock 非公平锁加锁流程简图</center><h2 id="ReentrantLock怎么实现公平锁的？"><a href="#ReentrantLock怎么实现公平锁的？" class="headerlink" title="ReentrantLock怎么实现公平锁的？"></a>ReentrantLock怎么实现公平锁的？</h2><p><code>new ReentrantLock() </code>构造函数默认创建的是非公平锁 NonfairSync</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时也可以在创建锁构造函数中传入具体参数创建公平锁 FairSync</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br><span class="line">--- ReentrantLock</span><br><span class="line"><span class="comment">// true 代表公平锁，false 代表非公平锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FairSync、NonfairSync 代表公平锁和非公平锁，两者都是 ReentrantLock 静态内部类，只不过实现不同锁语义。</p><p><strong>非公平锁和公平锁的两处不同：</strong></p><ol><li>非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。</li><li>非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state &#x3D;&#x3D; 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。</li></ol><p><img src="https://s2.loli.net/2023/03/26/Jgkf2lTRUhW5HYa.png" alt="公平锁tryAcquire"></p><center>公平锁tryAcquire</center><p>相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。</p><h2 id="CAS呢？CAS了解多少？"><a href="#CAS呢？CAS了解多少？" class="headerlink" title="CAS呢？CAS了解多少？"></a>CAS呢？CAS了解多少？</h2><p>CAS叫做CompareAndSwap，⽐较并交换，主要是通过处理器的指令来保证操作的原⼦性的。</p><p>CAS 指令包含 3 个参数：共享变量的内存地址 A、预期的值 B 和共享变量的新值 C。</p><p>只有当内存中地址 A 处的值等于 B 时，才能将内存中地址 A 处的值更新为新值 C。作为一条 CPU 指令，CAS 指令本身是能够保证原子性的 。</p><h2 id="CAS-有什么问题？如何解决？"><a href="#CAS-有什么问题？如何解决？" class="headerlink" title="CAS 有什么问题？如何解决？"></a>CAS 有什么问题？如何解决？</h2><p>CAS的经典三大问题：</p><p><img src="https://s2.loli.net/2023/03/26/KH9mrZtPI4bWDuM.png" alt="CAS三大问题"></p><center>CAS三大问题</center><h3 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h3><p>并发环境下，假设初始条件是A，去修改数据时，发现是A就会执行修改。但是看到的虽然是A，中间可能发生了A变B，B又变回A的情况。此时A已经非彼A，数据即使成功修改，也可能有问题。</p><blockquote><p>怎么解决ABA问题？</p></blockquote><ul><li>加版本号</li></ul><p>每次修改变量，都在这个变量的版本号上加1，这样，刚刚A-&gt;B-&gt;A，虽然A的值没变，但是它的版本号已经变了，再判断版本号就会发现此时的A已经被改过了。参考乐观锁的版本号，这种做法可以给数据带上了一种实效性的检验。</p><p>Java提供了AtomicStampReference类，它的compareAndSet方法首先检查当前的对象引用值是否等于预期引用，并且当前印戳（Stamp）标志是否等于预期标志，如果全部相等，则以原子方式将引用值和印戳标志的值更新为给定的更新值。</p><h3 id="循环性能开销"><a href="#循环性能开销" class="headerlink" title="循环性能开销"></a>循环性能开销</h3><p>自旋CAS，如果一直循环执行，一直不成功，会给CPU带来非常大的执行开销。</p><blockquote><p>怎么解决循环性能开销问题？</p></blockquote><p>在Java中，很多使用自旋CAS的地方，会有一个自旋次数的限制，超过一定次数，就停止自旋。</p><h3 id="只能保证一个变量的原子操作"><a href="#只能保证一个变量的原子操作" class="headerlink" title="只能保证一个变量的原子操作"></a>只能保证一个变量的原子操作</h3><p>CAS 保证的是对一个变量执行操作的原子性，如果对多个变量操作时，CAS 目前无法直接保证操作的原子性的。</p><blockquote><p>怎么解决只能保证一个变量的原子操作问题？</p></blockquote><ul><li>可以考虑改用锁来保证操作的原子性</li><li>可以考虑合并多个变量，将多个变量封装成一个对象，通过AtomicReference来保证原子性。</li></ul><h2 id="Java有哪些保证原子性的方法？如何保证多线程下i-结果正确？"><a href="#Java有哪些保证原子性的方法？如何保证多线程下i-结果正确？" class="headerlink" title="Java有哪些保证原子性的方法？如何保证多线程下i++ 结果正确？"></a>Java有哪些保证原子性的方法？如何保证多线程下i++ 结果正确？</h2><p><img src="https://s2.loli.net/2023/03/26/kNo54ueiszTJ17g.png" alt="Java保证原子性方法"></p><center>Java保证原子性方法</center><ul><li>使用循环原子类，例如AtomicInteger，实现i++原子操作</li><li>使用juc包下的锁，如ReentrantLock ，对i++操作加锁lock.lock()来实现原子性</li><li>使用synchronized，对i++操作加锁</li></ul><h2 id="原子操作类了解多少？"><a href="#原子操作类了解多少？" class="headerlink" title="原子操作类了解多少？"></a>原子操作类了解多少？</h2><p>当程序更新一个变量时，如果多线程同时更新这个变量，可能得到期望之外的值，比如变量i&#x3D;1，A线程更新i+1，B线程也更新i+1，经过两个线程操作之后可能i不等于3，而是等于2。因为A和B线程在更新变量i的时候拿到的i都是1，这就是线程不安全的更新操作，一般我们会使用synchronized来解决这个问题，synchronized会保证多线程不会同时更新变量i。</p><p>其实除此之外，还有更轻量级的选择，Java从JDK 1.5开始提供了java.util.concurrent.atomic包，这个包中的原子操作类提供了一种用法简单、性能高效、线程安全地更新一个变量的方式。</p><p>因为变量的类型有很多种，所以在Atomic包里一共提供了13个类，属于4种类型的原子更新方式，分别是原子更新基本类型、原子更新数组、原子更新引用和原子更新属性（字段）。</p><p><img src="https://s2.loli.net/2023/03/26/SPnU751ovyINHt4.png" alt="原子操作类"></p><center>原子操作类</center><p>Atomic包里的类基本都是使用Unsafe实现的包装类。</p><p>使用原子的方式更新基本类型，Atomic包提供了以下3个类：</p><ul><li>AtomicBoolean：原子更新布尔类型。</li><li>AtomicInteger：原子更新整型。</li><li>AtomicLong：原子更新长整型。</li></ul><p>通过原子的方式更新数组里的某个元素，Atomic包提供了以下4个类：</p><ul><li>AtomicIntegerArray：原子更新整型数组里的元素。</li><li>AtomicLongArray：原子更新长整型数组里的元素。</li><li>AtomicReferenceArray：原子更新引用类型数组里的元素。</li><li>AtomicIntegerArray类主要是提供原子的方式更新数组里的整型</li></ul><p>原子更新基本类型的AtomicInteger，只能更新一个变量，如果要原子更新多个变量，就需要使用这个原子更新引用类型提供的类。Atomic包提供了以下3个类：</p><ul><li>AtomicReference：原子更新引用类型。</li><li>AtomicReferenceFieldUpdater：原子更新引用类型里的字段。</li><li>AtomicMarkableReference：原子更新带有标记位的引用类型。可以原子更新一个布尔类型的标记位和引用类型。构造方法是AtomicMarkableReference（V initialRef，boolean initialMark）。</li></ul><p>如果需原子地更新某个类里的某个字段时，就需要使用原子更新字段类，Atomic包提供了以下3个类进行原子字段更新：</p><ul><li>AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。</li><li>AtomicLongFieldUpdater：原子更新长整型字段的更新器。</li><li>AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于原子的更新数据和数据的版本号，可以解决使用CAS进行原子更新时可能出现的 ABA问题。</li></ul><h2 id="AtomicInteger-的原理？"><a href="#AtomicInteger-的原理？" class="headerlink" title="AtomicInteger 的原理？"></a>AtomicInteger 的原理？</h2><p>一句话概括：<strong>使用CAS实现</strong>。</p><p>以AtomicInteger的添加方法为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="built_in">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>Unsafe</code>类的实例来进行添加操作，来看看具体的CAS操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4)</span> &#123;</span><br><span class="line">    <span class="type">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>compareAndSwapInt 是一个native方法，基于CAS来操作int类型变量。其它的原子操作类基本都是大同小异。</p><h2 id="线程死锁了解吗？该如何避免？"><a href="#线程死锁了解吗？该如何避免？" class="headerlink" title="线程死锁了解吗？该如何避免？"></a>线程死锁了解吗？该如何避免？</h2><p>死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的互相等待的现象，在无外力作用的情况下，这些线程会一直相互等待而无法继续运行下去。</p><p><img src="https://s2.loli.net/2023/03/26/ind5RNyVPKgBC3T.png" alt="死锁示意图"></p><center>死锁示意图</center><p>那么为什么会产生死锁呢？ 死锁的产生必须具备以下四个条件：</p><p><img src="https://s2.loli.net/2023/03/26/kUiqQ3vr97LMDXZ.png" alt="死锁产生必备四条件"></p><center>死锁产生必备四条件</center><ul><li>互斥条件：指线程对己经获取到的资源进行它性使用，即该资源同时只由一个线程占用。如果此时还有其它线程请求获取获取该资源，则请求者只能等待，直至占有资源的线程释放该资源。</li><li>请求并持有条件：指一个 线程己经持有了至少一个资源，但又提出了新的资源请求，而新资源己被其它线程占有，所以当前线程会被阻塞，但阻塞 的同时并不释放自己已经获取的资源。</li><li>不可剥夺条件：指线程获取到的资源在自己使用完之前不能被其它线程抢占，只有在自己使用完毕后才由自己释放该资源。</li><li>环路等待条件：指在发生死锁时，必然存在一个线程——资源的环形链，即线程集合 {T0，T1，T2,…… ，Tn} 中 T0 正在等待一 T1 占用的资源，Tl1正在等待 T2用的资源，…… Tn 在等待己被 T0占用的资源。</li></ul><p>该如何避免死锁呢？答案是<strong>至少破坏死锁发生的一个条件</strong>。</p><ul><li>其中，互斥这个条件我们没有办法破坏，因为用锁为的就是互斥。不过其他三个条件都是有办法破坏掉的，到底如何做呢？</li><li>对于“请求并持有”这个条件，可以一次性请求所有的资源。</li><li>对于“不可剥夺”这个条件，占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源，这样不可抢占这个条件就破坏掉了。</li><li>对于“环路等待”这个条件，可以靠按序申请资源来预防。所谓按序申请，是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后就不存在环路了。</li></ul><h2 id="那死锁问题怎么排查呢？"><a href="#那死锁问题怎么排查呢？" class="headerlink" title="那死锁问题怎么排查呢？"></a>那死锁问题怎么排查呢？</h2><p>可以使用jdk自带的命令行工具排查：</p><ol><li>使用jps查找运行的Java进程：jps -l</li><li>使用jstack查看线程堆栈信息：jstack -l 进程id</li></ol><p>基本就可以看到死锁的信息。</p><p>还可以利用图形化工具，比如JConsole。出现线程死锁以后，点击JConsole线程面板的<code>检测到死锁</code>按钮，将会看到线程的死锁信息。</p><p><img src="https://s2.loli.net/2023/03/26/8ujerlpaCb4dmzy.png" alt="线程死锁检测"></p><center>线程死锁检测</center><h1 id="并发工具类"><a href="#并发工具类" class="headerlink" title="并发工具类"></a>并发工具类</h1><h2 id="CountDownLatch（倒计数器）了解吗？"><a href="#CountDownLatch（倒计数器）了解吗？" class="headerlink" title="CountDownLatch（倒计数器）了解吗？"></a>CountDownLatch（倒计数器）了解吗？</h2><p>CountDownLatch，倒计数器，有两个常见的应用场景：</p><p><strong>场景1：协调子线程结束动作：等待所有子线程运行结束</strong></p><p>CountDownLatch允许一个或多个线程等待其他线程完成操作。</p><p>例如，我们很多人喜欢玩的王者荣耀，开黑的时候，得等所有人都上线之后，才能开打。</p><p><img src="https://s2.loli.net/2023/03/26/Cn5ezkEwGx3fMsQ.jpg" alt="王者荣耀等待玩家确认"></p><center>王者荣耀等待玩家确认</center><p>CountDownLatch模仿这个场景：</p><p>创建大乔、兰陵王、安其拉、哪吒和铠等五个玩家，主线程必须在他们都完成确认后，才可以继续运行。</p><p>在这段代码中，<code>new CountDownLatch(5)</code>用户创建初始的latch数量，各玩家通过<code>countDownLatch.countDown()</code>完成状态确认，主线程通过<code>countDownLatch.await()</code>等待。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    Thread 大乔 = <span class="keyword">new</span> <span class="title class_">Thread</span>(countDownLatch::countDown);</span><br><span class="line">    Thread 兰陵王 = <span class="keyword">new</span> <span class="title class_">Thread</span>(countDownLatch::countDown);</span><br><span class="line">    Thread 安其拉 = <span class="keyword">new</span> <span class="title class_">Thread</span>(countDownLatch::countDown);</span><br><span class="line">    Thread 哪吒 = <span class="keyword">new</span> <span class="title class_">Thread</span>(countDownLatch::countDown);</span><br><span class="line">    Thread 铠 = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 稍等，上个卫生间，马上到...</span></span><br><span class="line">            Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;&#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    大乔.start();</span><br><span class="line">    兰陵王.start();</span><br><span class="line">    安其拉.start();</span><br><span class="line">    哪吒.start();</span><br><span class="line">    铠.start();</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    System.out.println(<span class="string">&quot;所有玩家已经就位！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>场景2. 协调子线程开始动作：统一各线程动作开始的时机</strong></p><p>王者游戏中也有类似的场景，游戏开始时，各玩家的初始状态必须一致。不能有的玩家都出完装了，有的才降生。</p><p>所以大家得一块出生，在</p><p><img src="https://s2.loli.net/2023/03/26/eipTF51MqSGgUfI.jpg" alt="王者荣耀"></p><center>王者荣耀</center><p>在这个场景中，仍然用五个线程代表大乔、兰陵王、安其拉、哪吒和铠等五个玩家。需要注意的是，各玩家虽然都调用了<code>start()</code>线程，但是它们在运行时都在等待<code>countDownLatch</code>的信号，在信号未收到前，它们不会往下执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    Thread 大乔 = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; waitToFight(countDownLatch));</span><br><span class="line">    Thread 兰陵王 = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; waitToFight(countDownLatch));</span><br><span class="line">    Thread 安其拉 = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; waitToFight(countDownLatch));</span><br><span class="line">    Thread 哪吒 = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; waitToFight(countDownLatch));</span><br><span class="line">    Thread 铠 = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; waitToFight(countDownLatch));</span><br><span class="line"></span><br><span class="line">    大乔.start();</span><br><span class="line">    兰陵王.start();</span><br><span class="line">    安其拉.start();</span><br><span class="line">    哪吒.start();</span><br><span class="line">    铠.start();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    countDownLatch.countDown();</span><br><span class="line">    System.out.println(<span class="string">&quot;敌方还有5秒达到战场，全军出击！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">waitToFight</span><span class="params">(CountDownLatch countDownLatch)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        countDownLatch.await(); <span class="comment">// 在此等待信号再继续</span></span><br><span class="line">        System.out.println(<span class="string">&quot;收到，发起进攻！&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CountDownLatch的<strong>核心方法</strong>也不多：</p><ul><li><code>await()</code>：等待latch降为0；</li><li><code>boolean await(long timeout, TimeUnit unit)</code>：等待latch降为0，但是可以设置超时时间。比如有玩家超时未确认，那就重新匹配，总不能为了某个玩家等到天荒地老。</li><li><code>countDown()</code>：latch数量减1；</li><li><code>getCount()</code>：获取当前的latch数量。</li></ul><h2 id="CyclicBarrier（同步屏障）了解吗？"><a href="#CyclicBarrier（同步屏障）了解吗？" class="headerlink" title="CyclicBarrier（同步屏障）了解吗？"></a>CyclicBarrier（同步屏障）了解吗？</h2><p>CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一 组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。</p><p>它和CountDownLatch类似，都可以协调多线程的结束动作，在它们结束后都可以执行特定动作，但是为什么要有CyclicBarrier，自然是它有和CountDownLatch不同的地方。</p><p>不知道你听没听过一个新人UP主小约翰可汗，小约翰生平有两大恨——“想结衣结衣不依,迷爱理爱理不理。”我们来还原一下事情的经过：小约翰在亲政后认识了新垣结衣，于是决定第一次选妃，向结衣表白，等待回应。然而新垣结衣回应嫁给了星野源，小约翰伤心欲绝，发誓生平不娶，突然发现了铃木爱理，于是小约翰决定第二次选妃，求爱理搭理，等待回应。</p><p><img src="https://s2.loli.net/2023/03/26/Jx1TeFtXCHwOnQA.png" alt="想结衣结衣不依,迷爱理爱理不理。"></p><center>想结衣结衣不依,迷爱理爱理不理。</center><p>我们拿代码模拟这一场景，发现CountDownLatch无能为力了，因为CountDownLatch的使用是一次性的，无法重复利用，而这里等待了两次。此时，我们用CyclicBarrier就可以实现，因为它可以重复利用。</p><p><img src="https://s2.loli.net/2023/03/26/nAVkJg2ufEXq6FC.png" alt="小约翰可汗选妃模拟代码"></p><center>小约翰可汗选妃模拟代码</center><p>运行结果：</p><p><img src="https://s2.loli.net/2023/03/26/1tusx7Y8Prlwzgm.png" alt="运行结果"></p><center>运行结果</center><p>CyclicBarrier最最核心的方法，仍然是await()：</p><ul><li>如果当前线程不是第一个到达屏障的话，它将会进入等待，直到其他线程都到达，除非发生<strong>被中断</strong>、<strong>屏障被拆除</strong>、<strong>屏障被重设</strong>等情况；</li></ul><p>上面的例子抽象一下，本质上它的流程就是这样就是这样：</p><p><img src="https://s2.loli.net/2023/03/26/2ZpSHzjlcBh3Xsu.png" alt="CyclicBarrier工作流程"></p><center>CyclicBarrier工作流程</center><h2 id="CyclicBarrier和CountDownLatch有什么区别？"><a href="#CyclicBarrier和CountDownLatch有什么区别？" class="headerlink" title="CyclicBarrier和CountDownLatch有什么区别？"></a>CyclicBarrier和CountDownLatch有什么区别？</h2><p>两者最核心的区别：</p><ul><li>CountDownLatch是一次性的，而CyclicBarrier则可以多次设置屏障，实现重复利用；</li><li>CountDownLatch中的各个子线程不可以等待其他线程，只能完成自己的任务；而CyclicBarrier中的各个线程可以等待其他线程</li></ul><p>它们区别用一个表格整理：</p><table><thead><tr><th>CyclicBarrier</th><th>CountDownLatch</th></tr></thead><tbody><tr><td>CyclicBarrier是可重用的，其中的线程会等待所有的线程完成任务。届时，屏障将被拆除，并可以选择性地做一些特定的动作。</td><td>CountDownLatch是一次性的，不同的线程在同一个计数器上工作，直到计数器为0.</td></tr><tr><td>CyclicBarrier面向的是线程数</td><td>CountDownLatch面向的是任务数</td></tr><tr><td>在使用CyclicBarrier时，你必须在构造中指定参与协作的线程数，这些线程必须调用await()方法</td><td>使用CountDownLatch时，则必须要指定任务数，至于这些任务由哪些线程完成无关紧要</td></tr><tr><td>CyclicBarrier可以在所有的线程释放后重新使用</td><td>CountDownLatch在计数器为0时不能再使用</td></tr><tr><td>在CyclicBarrier中，如果某个线程遇到了中断、超时等问题时，则处于await的线程都会出现问题</td><td>在CountDownLatch中，如果某个线程出现问题，其他线程不受影响</td></tr></tbody></table><h2 id="Semaphore（信号量）了解吗？"><a href="#Semaphore（信号量）了解吗？" class="headerlink" title="Semaphore（信号量）了解吗？"></a>Semaphore（信号量）了解吗？</h2><p>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。</p><p>听起来似乎很抽象，现在汽车多了，开车出门在外的一个老大难问题就是停车 。停车场的车位是有限的，只能允许若干车辆停泊，如果停车场还有空位，那么显示牌显示的就是绿灯和剩余的车位，车辆就可以驶入；如果停车场没位了，那么显示牌显示的就是绿灯和数字0，车辆就得等待。如果满了的停车场有车离开，那么显示牌就又变绿，显示空车位数量，等待的车辆就能进停车场。</p><p><img src="https://s2.loli.net/2023/03/26/PY6dnHbSQAmpoFD.jpg" alt="停车场空闲车位提示"></p><center>停车场空闲车位提示</center><p>我们把这个例子类比一下，车辆就是线程，进入停车场就是线程在执行，离开停车场就是线程执行完毕，看见红灯就表示线程被阻塞，不能执行，Semaphore的本质就是<strong>协调多个线程对共享资源的获取</strong>。</p><p><img src="https://s2.loli.net/2023/03/26/TcMiWKwL2Fx3Cfz.jpg" alt="Semaphore许可获取"></p><center>Semaphore许可获取</center><p>我们再来看一个Semaphore的用途：它可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接。</p><p>假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发地读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有10个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。这个时候，就可以使用Semaphore来做流量控制，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THREAD_COUNT</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(THREAD_COUNT);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Semaphore</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; THREAD_COUNT; i++) &#123;</span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        s.acquire();</span><br><span class="line">                        System.out.println(<span class="string">&quot;save data&quot;</span>);</span><br><span class="line">                        s.release();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码中，虽然有30个线程在执行，但是只允许10个并发执行。Semaphore的构造方法<code> Semaphore（int permits</code>）接受一个整型的数字，表示可用的许可证数量。<code>Semaphore（10）</code>表示允许10个线程获取许可证，也就是最大并发数是10。Semaphore的用法也很简单，首先线程使用 Semaphore的acquire()方法获取一个许可证，使用完之后调用release()方法归还许可证。还可以用tryAcquire()方法尝试获取许可证。</p><h2 id="Exchanger-了解吗？"><a href="#Exchanger-了解吗？" class="headerlink" title="Exchanger 了解吗？"></a>Exchanger 了解吗？</h2><p>Exchanger（交换者）是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。</p><p><img src="https://s2.loli.net/2023/03/26/1Laer9toDBgYnpl.jpg" alt="英雄交换猎物"></p><center>英雄交换猎物</center><p>这两个线程通过 exchange方法交换数据，如果第一个线程先执行exchange()方法，它会一直等待第二个线程也执行exchange方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。</p><p>Exchanger可以用于遗传算法，遗传算法里需要选出两个人作为交配对象，这时候会交换两人的数据，并使用交叉规则得出2个交配结果。Exchanger也可以用于校对工作，比如我们需要将纸制银行流水通过人工的方式录入成电子银行流水，为了避免错误，采用AB岗两人进行录入，录入到Excel之后，系统需要加载这两个Excel，并对两个Excel数据进行校对，看看是否录入一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExchangerTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Exchanger&lt;String&gt; exgr = <span class="keyword">new</span> <span class="title class_">Exchanger</span>&lt;String&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">A</span> <span class="operator">=</span> <span class="string">&quot;银行流水A&quot;</span>; <span class="comment">// A录入银行流水数据 </span></span><br><span class="line">                    exgr.exchange(A);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">B</span> <span class="operator">=</span> <span class="string">&quot;银行流水B&quot;</span>; <span class="comment">// B录入银行流水数据 </span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">A</span> <span class="operator">=</span> exgr.exchange(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;A和B数据是否一致：&quot;</span> + A.equals(B) + <span class="string">&quot;，A录入的是：&quot;</span></span><br><span class="line">                            + A + <span class="string">&quot;，B录入是：&quot;</span> + B);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如两个线程有一个没有执行exchange()方法，则会一直等待，如果担心有特殊情况发生，避免一直等待，可以使用<code>exchange(V x, long timeOut, TimeUnit unit) </code>设置最大等待时长。</p><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="什么是线程池？"><a href="#什么是线程池？" class="headerlink" title="什么是线程池？"></a>什么是线程池？</h2><p><strong>线程池：</strong> 简单理解，它就是一个管理线程的池子。</p><p><img src="https://s2.loli.net/2023/03/26/IY24cEqVv8TnjLM.png" alt="管理线程的池子"></p><center>管理线程的池子</center><ul><li><strong>它帮我们管理线程，避免增加创建线程和销毁线程的资源损耗</strong>。因为线程其实也是一个对象，创建一个对象，需要经过类加载过程，销毁一个对象，需要走GC垃圾回收流程，都是需要资源开销的。</li><li><strong>提高响应速度。</strong> 如果任务到达了，相对于从线程池拿线程，重新去创建一条线程执行，速度肯定慢很多。</li><li><strong>重复利用。</strong> 线程用完，再放回池子，可以达到重复利用的效果，节省资源。</li></ul><h2 id="能说说工作中线程池的应用吗？"><a href="#能说说工作中线程池的应用吗？" class="headerlink" title="能说说工作中线程池的应用吗？"></a>能说说工作中线程池的应用吗？</h2><p>之前我们有一个和第三方对接的需求，需要向第三方推送数据，引入了多线程来提升数据推送的效率，其中用到了线程池来管理线程。</p><p><img src="https://s2.loli.net/2023/03/26/RbGjiAmcleyExnJ.png" alt="业务示例"></p><center>业务示例</center><p>主要代码如下：</p><p><img src="https://s2.loli.net/2023/03/26/xZD9lj1O8GIQaPh.png" alt="主要代码"></p><center>主要代码</center><p>完整可运行代码地址：<a href="https://gitee.com/fighter3/thread-demo.git">https://gitee.com/fighter3/thread-demo.gitopen in new window</a></p><p>线程池的参数如下：</p><ul><li>corePoolSize：线程核心参数选择了CPU数×2</li><li>maximumPoolSize：最大线程数选择了和核心线程数相同</li><li>keepAliveTime：非核心闲置线程存活时间直接置为0</li><li>unit：非核心线程保持存活的时间选择了 TimeUnit.SECONDS 秒</li><li>workQueue：线程池等待队列，使用 LinkedBlockingQueue阻塞队列</li></ul><p>同时还用了synchronized 来加锁，保证数据不会被重复推送：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (PushProcessServiceImpl.class) &#123;&#125;</span><br></pre></td></tr></table></figure><p>ps:这个例子只是简单地进行了数据推送，实际上还可以结合其他的业务，像什么数据清洗啊、数据统计啊，都可以套用。</p><h2 id="能简单说一下线程池的工作流程吗？"><a href="#能简单说一下线程池的工作流程吗？" class="headerlink" title="能简单说一下线程池的工作流程吗？"></a>能简单说一下线程池的工作流程吗？</h2><p>用一个通俗的比喻：</p><p>有一个营业厅，总共有六个窗口，现在开放了三个窗口，现在有三个窗口坐着三个营业员小姐姐在营业。</p><p>老三去办业务，可能会遇到什么情况呢？</p><ol><li>老三发现有空间的在营业的窗口，直接去找小姐姐办理业务。</li></ol><p><img src="https://s2.loli.net/2023/03/26/UqynzW1iH6kYeZX.png" alt="直接办理"></p><center>直接办理</center><ol><li>老三发现没有空闲的窗口，就在排队区排队等。</li></ol><p><img src="https://s2.loli.net/2023/03/26/4IWg8mPLArMYbyi.png" alt="排队等待"></p><center>排队等待</center><ol><li>老三发现没有空闲的窗口，等待区也满了，蚌埠住了，经理一看，就让休息的小姐姐赶紧回来上班，等待区号靠前的赶紧去新窗口办，老三去排队区排队。小姐姐比较辛苦，假如一段时间发现他们可以不用接着营业，经理就让她们接着休息。</li></ol><p><img src="https://s2.loli.net/2023/03/26/BiSQXjUlxL1O9da.png" alt="排队区满"></p><center>排队区满</center><ol><li>老三一看，六个窗口都满了，等待区也没位置了。老三急了，要闹，经理赶紧出来了，经理该怎么办呢？</li></ol><p><img src="https://s2.loli.net/2023/03/26/fpsgicKvBL3j8Eq.png" alt="等待区，排队区都满"></p><center>等待区，排队区都满</center><blockquote><ol><li>我们银行系统已经瘫痪</li><li>谁叫你来办的你找谁去</li><li>看你比较急，去队里加个塞</li><li>今天没办法，不行你看改一天</li></ol></blockquote><p>上面的这个流程几乎就跟 JDK 线程池的大致流程类似，</p><blockquote><ol><li>营业中的 3个窗口对应核心线程池数：corePoolSize</li><li>总的营业窗口数6对应：maximumPoolSize</li><li>打开的临时窗口在多少时间内无人办理则关闭对应：unit</li><li>排队区就是等待队列：workQueue</li><li>无法办理的时候银行给出的解决方法对应：RejectedExecutionHandler</li><li>threadFactory 该参数在 JDK 中是 线程工厂，用来创建线程对象，一般不会动。</li></ol></blockquote><p>所以我们线程池的工作流程也比较好理解了：</p><ol><li>线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。</li><li>当调用 execute() 方法添加一个任务时，线程池会做如下判断：</li></ol><ul><li>如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；</li><li>如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；</li><li>如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；</li><li>如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会根据拒绝策略来对应处理。</li></ul><p><img src="https://s2.loli.net/2023/03/26/6dqwlUYT35A4tus.png" alt="线程池执行流程"></p><center>线程池执行流程</center><ol><li>当一个线程完成任务时，它会从队列中取下一个任务来执行。</li><li>当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。</li></ol><h2 id="线程池主要参数有哪些？"><a href="#线程池主要参数有哪些？" class="headerlink" title="线程池主要参数有哪些？"></a>线程池主要参数有哪些？</h2><p><img src="https://s2.loli.net/2023/03/26/5m2rk9Sbfuvy1wK.png" alt="线程池参数"></p><center>线程池参数</center><p>线程池有七大参数，需要重点关注<code>corePoolSize</code>、<code>maximumPoolSize</code>、<code>workQueue</code>、<code>handler</code>这四个。</p><ol><li>corePoolSize</li></ol><p>此值是用来初始化线程池中核心线程数，当线程池中线程池数&lt; <code>corePoolSize</code>时，系统默认是添加一个任务才创建一个线程池。当线程数 &#x3D; corePoolSize时，新任务会追加到workQueue中。</p><ol><li>maximumPoolSize</li></ol><p><code>maximumPoolSize</code>表示允许的最大线程数 &#x3D; (非核心线程数+核心线程数)，当<code>BlockingQueue</code>也满了，但线程池中总线程数 &lt; <code>maximumPoolSize</code>时候就会再次创建新的线程。</p><ol><li>keepAliveTime</li></ol><p>非核心线程 &#x3D;(maximumPoolSize - corePoolSize ) ,非核心线程闲置下来不干活最多存活时间。</p><ol><li>unit</li></ol><p>线程池中非核心线程保持存活的时间的单位</p><ul><li>TimeUnit.DAYS; 天</li><li>TimeUnit.HOURS; 小时</li><li>TimeUnit.MINUTES; 分钟</li><li>TimeUnit.SECONDS; 秒</li><li>TimeUnit.MILLISECONDS; 毫秒</li><li>TimeUnit.MICROSECONDS; 微秒</li><li>TimeUnit.NANOSECONDS; 纳秒</li></ul><ol><li>workQueue</li></ol><p>线程池等待队列，维护着等待执行的<code>Runnable</code>对象。当运行当线程数&#x3D; corePoolSize时，新的任务会被添加到<code>workQueue</code>中，如果<code>workQueue</code>也满了则尝试用非核心线程执行任务，等待队列应该尽量用有界的。</p><ol><li>threadFactory</li></ol><p>创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等。</p><ol><li>handler</li></ol><p><code>corePoolSize</code>、<code>workQueue</code>、<code>maximumPoolSize</code>都不可用的时候执行的饱和策略。</p><h2 id="线程池的拒绝策略有哪些？"><a href="#线程池的拒绝策略有哪些？" class="headerlink" title="线程池的拒绝策略有哪些？"></a>线程池的拒绝策略有哪些？</h2><p>类比前面的例子，无法办理业务时的处理方式，帮助记忆：</p><p><img src="https://s2.loli.net/2023/03/26/4JRbP67KjDAQmNW.png" alt="四种策略"></p><center>四种策略</center><ul><li>AbortPolicy ：直接抛出异常，默认使用此策略</li><li>CallerRunsPolicy：用调用者所在的线程来执行任务</li><li>DiscardOldestPolicy：丢弃阻塞队列里最老的任务，也就是队列里靠前的任务</li><li>DiscardPolicy ：当前任务直接丢弃</li></ul><p>想实现自己的拒绝策略，实现RejectedExecutionHandler接口即可。</p><h2 id="线程池有哪几种工作队列？"><a href="#线程池有哪几种工作队列？" class="headerlink" title="线程池有哪几种工作队列？"></a>线程池有哪几种工作队列？</h2><p>常用的阻塞队列主要有以下几种：</p><p><img src="https://s2.loli.net/2023/03/26/l25YxcBjPsFOLwz.png" alt="线程池常用阻塞队列"></p><center>线程池常用阻塞队列</center><ul><li>ArrayBlockingQueue：ArrayBlockingQueue（有界队列）是一个用数组实现的有界阻塞队列，按FIFO排序量。</li><li>LinkedBlockingQueue：LinkedBlockingQueue（可设置容量队列）是基于链表结构的阻塞队列，按FIFO排序任务，容量可以选择进行设置，不设置的话，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE，吞吐量通常要高于ArrayBlockingQuene；newFixedThreadPool线程池使用了这个队列</li><li>DelayQueue：DelayQueue（延迟队列）是一个任务定时周期的延迟执行的队列。根据指定的执行时间从小到大排序，否则根据插入到队列的先后排序。newScheduledThreadPool线程池使用了这个队列。</li><li>PriorityBlockingQueue：PriorityBlockingQueue（优先级队列）是具有优先级的无界阻塞队列</li><li>SynchronousQueue：SynchronousQueue（同步队列）是一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene，newCachedThreadPool线程池使用了这个队列。</li></ul><h2 id="线程池提交execute和submit有什么区别？"><a href="#线程池提交execute和submit有什么区别？" class="headerlink" title="线程池提交execute和submit有什么区别？"></a>线程池提交execute和submit有什么区别？</h2><ol><li>execute 用于提交不需要返回值的任务</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">threadsPool.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123; </span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub &#125; </span></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><ol><li>submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个 future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;Object&gt; future = executor.submit(harReturnValuetask); </span><br><span class="line"><span class="keyword">try</span> &#123; <span class="type">Object</span> <span class="variable">s</span> <span class="operator">=</span> future.get(); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line">    <span class="comment">// 处理中断异常 </span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123; </span><br><span class="line">    <span class="comment">// 处理无法执行任务异常 </span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">    <span class="comment">// 关闭线程池 executor.shutdown();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程池怎么关闭知道吗？"><a href="#线程池怎么关闭知道吗？" class="headerlink" title="线程池怎么关闭知道吗？"></a>线程池怎么关闭知道吗？</h2><p>可以通过调用线程池的<code>shutdown</code>或<code>shutdownNow</code>方法来关闭线程池。它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。</p><p><strong>shutdown() 将线程池状态置为shutdown,并不会立即停止</strong>：</p><ol><li>停止接收外部submit的任务</li><li>内部正在跑的任务和队列里等待的任务，会执行完</li><li>等到第二步完成后，才真正停止</li></ol><p><strong>shutdownNow() 将线程池状态置为stop。一般会立即停止，事实上不一定</strong>：</p><ol><li>和shutdown()一样，先停止接收外部提交的任务</li><li>忽略队列里等待的任务</li><li>尝试将正在跑的任务interrupt中断</li><li>返回未执行的任务列表</li></ol><p>shutdown 和shutdownnow简单来说区别如下：</p><ul><li>shutdownNow()能立即停止线程池，正在跑的和正在等待的任务都停下了。这样做立即生效，但是风险也比较大。</li><li>shutdown()只是关闭了提交通道，用submit()是无效的；而内部的任务该怎么跑还是怎么跑，跑完再彻底停止线程池。</li></ul><h2 id="线程池的线程数应该怎么配置？"><a href="#线程池的线程数应该怎么配置？" class="headerlink" title="线程池的线程数应该怎么配置？"></a>线程池的线程数应该怎么配置？</h2><p>线程在Java中属于稀缺资源，线程池不是越大越好也不是越小越好。任务分为计算密集型、IO密集型、混合型。</p><ol><li>计算密集型：大部分都在用CPU跟内存，加密，逻辑操作业务处理等。</li><li>IO密集型：数据库链接，网络通讯传输等。</li></ol><p><img src="https://s2.loli.net/2023/03/26/4AptZETJyow9Ou6.png" alt="常见线程池参数配置方案"></p><center>常见线程池参数配置方案</center><p>一般的经验，不同类型线程池的参数配置：</p><ol><li>计算密集型一般推荐线程池不要过大，一般是CPU数 + 1，+1是因为可能存在<strong>页缺失</strong>(就是可能存在有些数据在硬盘中需要多来一个线程将数据读入内存)。如果线程池数太大，可能会频繁的 进行线程上下文切换跟任务调度。获得当前CPU核心数代码如下：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().availableProcessors();</span><br></pre></td></tr></table></figure><ol><li>IO密集型：线程数适当大一点，机器的Cpu核心数*2。</li><li>混合型：可以考虑根绝情况将它拆分成CPU密集型和IO密集型任务，如果执行时间相差不大，拆分可以提升吞吐量，反之没有必要。</li></ol><p>当然，实际应用中没有固定的公式，需要结合测试和监控来进行调整。</p><h2 id="有哪几种常见的线程池？"><a href="#有哪几种常见的线程池？" class="headerlink" title="有哪几种常见的线程池？"></a>有哪几种常见的线程池？</h2><p>面试常问，主要有四种，都是通过工具类Excutors创建出来的，需要注意，阿里巴巴《Java开发手册》里禁止使用这种方式来创建线程池。</p><p><img src="https://s2.loli.net/2023/03/26/potjK2OXZmeDlYc.png" alt="四大线程池"></p><center>四大线程池</center><ul><li>newFixedThreadPool (固定数目线程的线程池)</li><li>newCachedThreadPool (可缓存线程的线程池)</li><li>newSingleThreadExecutor (单线程的线程池)</li><li>newScheduledThreadPool (定时及周期执行的线程池)</li></ul><h2 id="能说一下四种常见线程池的原理吗？"><a href="#能说一下四种常见线程池的原理吗？" class="headerlink" title="能说一下四种常见线程池的原理吗？"></a>能说一下四种常见线程池的原理吗？</h2><p>前三种线程池的构造直接调用ThreadPoolExecutor的构造方法。</p><h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                threadFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线程池特点</strong></p><ul><li>核心线程数为1</li><li>最大线程数也为1</li><li>阻塞队列是无界队列LinkedBlockingQueue，可能会导致OOM</li><li>keepAliveTime为0</li></ul><p><img src="https://s2.loli.net/2023/03/26/W94ymBIwoD57znQ.png" alt="SingleThreadExecutor运行流程"></p><center>SingleThreadExecutor运行流程</center><p>工作流程：</p><ul><li>提交任务</li><li>线程池是否有一条线程在，如果没有，新建线程执行任务</li><li>如果有，将任务加到阻塞队列</li><li>当前的唯一线程，从队列取任务，执行完一个，再继续取，一个线程执行任务。</li></ul><p><strong>适用场景</strong></p><p>适用于串行执行任务的场景，一个任务一个任务地执行。</p><h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads, ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线程池特点：</strong></p><ul><li>核心线程数和最大线程数大小一样</li><li>没有所谓的非空闲时间，即keepAliveTime为0</li><li>阻塞队列为无界队列LinkedBlockingQueue，可能会导致OOM</li></ul><p><img src="https://s2.loli.net/2023/03/26/12HCd8xoTA7UpBF.png" alt="FixedThreadPool"></p><center>FixedThreadPool</center><p>工作流程：</p><ul><li>提交任务</li><li>如果线程数少于核心线程，创建核心线程执行任务</li><li>如果线程数等于核心线程，把任务添加到LinkedBlockingQueue阻塞队列</li><li>如果线程执行完任务，去阻塞队列取任务，继续执行。</li></ul><p><strong>使用场景</strong></p><p>FixedThreadPool 适用于处理CPU密集型的任务，确保CPU在长期被工作线程使用的情况下，尽可能的少的分配线程，即适用执行长期的任务。</p><h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线程池特点：</strong></p><ul><li>核心线程数为0</li><li>最大线程数为Integer.MAX_VALUE，即无限大，可能会因为无限创建线程，导致OOM</li><li>阻塞队列是SynchronousQueue</li><li>非核心线程空闲存活时间为60秒</li></ul><p>当提交任务的速度大于处理任务的速度时，每次提交一个任务，就必然会创建一个线程。极端情况下会创建过多的线程，耗尽 CPU 和内存资源。由于空闲 60 秒的线程会被终止，长时间保持空闲的 CachedThreadPool 不会占用任何资源。</p><p><img src="https://s2.loli.net/2023/03/26/PE3VsAaBSDQyuCZ.png" alt="CachedThreadPool执行流程"></p><center>CachedThreadPool执行流程</center><p>工作流程：</p><ul><li>提交任务</li><li>因为没有核心线程，所以任务直接加到SynchronousQueue队列。</li><li>判断是否有空闲线程，如果有，就去取出任务执行。</li><li>如果没有空闲线程，就新建一个线程执行。</li><li>执行完任务的线程，还可以存活60秒，如果在这期间，接到任务，可以继续活下去；否则，被销毁。</li></ul><p><strong>适用场景</strong></p><p>用于并发执行大量短期的小任务。</p><h3 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线程池特点</strong></p><ul><li>最大线程数为Integer.MAX_VALUE，也有OOM的风险</li><li>阻塞队列是DelayedWorkQueue</li><li>keepAliveTime为0</li><li>scheduleAtFixedRate() ：按某种速率周期执行</li><li>scheduleWithFixedDelay()：在某个延迟后执行</li></ul><p><img src="https://s2.loli.net/2023/03/26/9npDkPX2zdrcGoB.png" alt="ScheduledThreadPool执行流程"></p><center>ScheduledThreadPool执行流程</center><p><strong>工作机制</strong></p><ul><li>线程从DelayQueue中获取已到期的ScheduledFutureTask（DelayQueue.take()）。到期任务是指ScheduledFutureTask的time大于等于当前时间。</li><li>线程执行这个ScheduledFutureTask。</li><li>线程修改ScheduledFutureTask的time变量为下次将要被执行的时间。</li><li>线程把这个修改time之后的ScheduledFutureTask放回DelayQueue中（DelayQueue.add()）。</li></ul><p><img src="https://s2.loli.net/2023/03/26/ehF8TKWuwLka96g.png" alt="ScheduledThreadPoolExecutor执行流程"></p><center>ScheduledThreadPoolExecutor执行流程</center><p><strong>使用场景</strong></p><p>周期性执行任务的场景，需要限制线程数量的场景</p><blockquote><p>使用无界队列的线程池会导致什么问题吗？</p></blockquote><p>例如newFixedThreadPool使用了无界的阻塞队列LinkedBlockingQueue，如果线程获取一个任务后，任务的执行时间比较长，会导致队列的任务越积越多，导致机器内存使用不停飙升，最终导致OOM。</p><h2 id="线程池异常怎么处理知道吗？"><a href="#线程池异常怎么处理知道吗？" class="headerlink" title="线程池异常怎么处理知道吗？"></a>线程池异常怎么处理知道吗？</h2><p>在使用线程池处理任务的时候，任务代码可能抛出RuntimeException，抛出异常后，线程池可能捕获它，也可能创建一个新的线程来代替异常的线程，我们可能无法感知任务出现了异常，因此我们需要考虑线程池异常情况。</p><p>常见的异常处理方式：</p><p><img src="https://s2.loli.net/2023/03/26/wG7NvFk25j8PVnR.png" alt="线程池异常处理"></p><center>线程池异常处理</center><h2 id="能说一下线程池有几种状态吗？"><a href="#能说一下线程池有几种状态吗？" class="headerlink" title="能说一下线程池有几种状态吗？"></a>能说一下线程池有几种状态吗？</h2><p>线程池有这几个状态：RUNNING,SHUTDOWN,STOP,TIDYING,TERMINATED。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程池状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RUNNING</span>    <span class="operator">=</span> -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHUTDOWN</span>   <span class="operator">=</span>  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STOP</span>       <span class="operator">=</span>  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TIDYING</span>    <span class="operator">=</span>  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TERMINATED</span> <span class="operator">=</span>  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure><p>线程池各个状态切换图：</p><p><img src="https://s2.loli.net/2023/03/26/EQzBUWf46upD19a.png" alt="线程池状态切换图"></p><center>线程池状态切换图</center><p><strong>RUNNING</strong></p><ul><li>该状态的线程池会接收新任务，并处理阻塞队列中的任务;</li><li>调用线程池的shutdown()方法，可以切换到SHUTDOWN状态;</li><li>调用线程池的shutdownNow()方法，可以切换到STOP状态;</li></ul><p><strong>SHUTDOWN</strong></p><ul><li>该状态的线程池不会接收新任务，但会处理阻塞队列中的任务；</li><li>队列为空，并且线程池中执行的任务也为空,进入TIDYING状态;</li></ul><p><strong>STOP</strong></p><ul><li>该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务；</li><li>线程池中执行的任务为空,进入TIDYING状态;</li></ul><p><strong>TIDYING</strong></p><ul><li>该状态表明所有的任务已经运行终止，记录的任务数量为0。</li><li>terminated()执行完毕，进入TERMINATED状态</li></ul><p><strong>TERMINATED</strong></p><ul><li>该状态表示线程池彻底终止</li></ul><h2 id="线程池如何实现参数的动态修改？"><a href="#线程池如何实现参数的动态修改？" class="headerlink" title="线程池如何实现参数的动态修改？"></a>线程池如何实现参数的动态修改？</h2><p>线程池提供了几个 setter方法来设置线程池的参数。</p><p><img src="https://s2.loli.net/2023/03/26/TCqx5Z9UsYufgOL.png" alt="JDK 线程池参数设置接口"></p><center>JDK 线程池参数设置接口</center><p>这里主要有两个思路：</p><p><img src="https://s2.loli.net/2023/03/26/9lSNOPR1pqDusZx.png" alt="动态修改线程池参数"></p><center>动态修改线程池参数</center><ul><li>在我们微服务的架构下，可以利用配置中心如Nacos、Apollo等等，也可以自己开发配置中心。业务服务读取线程池配置，获取相应的线程池实例来修改线程池的参数。</li><li>如果限制了配置中心的使用，也可以自己去扩展<strong>ThreadPoolExecutor</strong>，重写方法，监听线程池参数变化，来动态修改线程池参数。</li></ul><h2 id="线程池调优了解吗？"><a href="#线程池调优了解吗？" class="headerlink" title="线程池调优了解吗？"></a>线程池调优了解吗？</h2><p>线程池配置没有固定的公式，通常事前会对线程池进行一定评估，常见的评估方案如下：</p><p><img src="https://s2.loli.net/2023/03/26/J47znsQ3xkwIifN.png" alt="线程池评估方案"></p><center>线程池评估方案</center><p>上线之前也要进行充分的测试，上线之后要建立完善的线程池监控机制。</p><p>事中结合监控告警机制，分析线程池的问题，或者可优化点，结合线程池动态参数配置机制来调整配置。</p><p>事后要注意仔细观察，随时调整。</p><p><img src="https://s2.loli.net/2023/03/26/Y8xZFCXznNlTAHG.png" alt="线程池调优"></p><center>线程池调优</center><p>具体的调优案例可以查看参考美团技术博客。</p><h2 id="你能设计实现一个线程池吗？"><a href="#你能设计实现一个线程池吗？" class="headerlink" title="你能设计实现一个线程池吗？"></a>你能设计实现一个线程池吗？</h2><p>⭐这道题在阿里的面试中出现频率比较高</p><p>线程池实现原理可以查看 <a href="https://mp.weixin.qq.com/s/Exy7pRGND9TCjRd9TZK4jg">要是以前有人这么讲线程池，我早就该明白了！</a> ，当然，我们自己实现， 只需要抓住线程池的核心流程：</p><p><img src="https://s2.loli.net/2023/03/26/NeQXaLhTOpWr9oJ.png" alt="线程池主要实现流程"></p><center>线程池主要实现流程</center><p>我们自己的实现就是完成这个核心流程：</p><ul><li>线程池中有N个工作线程</li><li>把任务提交给线程池运行</li><li>如果线程池已满，把任务放入队列</li><li>最后当有空闲时，获取队列中任务来执行</li></ul><p>实现代码：</p><p><img src="https://s2.loli.net/2023/03/26/WV5R9gn18YNZGSl.png" alt="自定义线程池"></p><center>自定义线程池</center><p>这样，一个实现了线程池主要流程的类就完成了。</p><h2 id="单机线程池执行断电了应该怎么处理？"><a href="#单机线程池执行断电了应该怎么处理？" class="headerlink" title="单机线程池执行断电了应该怎么处理？"></a>单机线程池执行断电了应该怎么处理？</h2><p>我们可以对正在处理和阻塞队列的任务做事务管理或者对阻塞队列中的任务持久化处理，并且当断电或者系统崩溃，操作无法继续下去的时候，可以通过回溯日志的方式来撤销<code>正在处理</code>的已经执行成功的操作。然后重新执行整个阻塞队列。</p><p>也就是说，对阻塞队列持久化；正在处理任务事务控制；断电之后正在处理任务的回滚，通过日志恢复该次操作；服务器重启后阻塞队列中的数据再加载。</p><h1 id="并发容器和框架"><a href="#并发容器和框架" class="headerlink" title="并发容器和框架"></a>并发容器和框架</h1><p>关于一些并发容器，可以去看看 <a href="https://mp.weixin.qq.com/s/SHkQ7LEOT0itt4bXMoDBPw">面渣逆袭：Java集合连环三十问 open in new window</a>，里面有<code>CopyOnWriteList</code>和<code>ConcurrentHashMap</code>这两种线程安全容器类的问答。。</p><h2 id="Fork-x2F-Join框架了解吗？"><a href="#Fork-x2F-Join框架了解吗？" class="headerlink" title="Fork&#x2F;Join框架了解吗？"></a>Fork&#x2F;Join框架了解吗？</h2><p>Fork&#x2F;Join框架是Java7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。</p><p>要想掌握Fork&#x2F;Join框架，首先需要理解两个点，<strong>分而治之</strong>和<strong>工作窃取算法</strong>。</p><p><strong>分而治之</strong></p><p>Fork&#x2F;Join框架的定义，其实就体现了分治思想：将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。</p><p><img src="https://s2.loli.net/2023/03/26/vJROEiQG4zoW8rl.png" alt="Fork/Join分治算法"></p><center>Fork/Join分治算法</center><p><strong>工作窃取算法</strong></p><p>大任务拆成了若干个小任务，把这些小任务放到不同的队列里，各自创建单独线程来执行队列里的任务。</p><p>那么问题来了，有的线程干活块，有的线程干活慢。干完活的线程不能让它空下来，得让它去帮没干完活的线程干活。它去其它线程的队列里窃取一个任务来执行，这就是所谓的<strong>工作窃取</strong>。</p><p>工作窃取发生的时候，它们会访问同一个队列，为了减少窃取任务线程和被窃取任务线程之间的竞争，通常任务会使用双端队列，被窃取任务线程永远从双端队列的头部拿，而窃取任务的线程永远从双端队列的尾部拿任务执行。</p><p><img src="https://s2.loli.net/2023/03/26/Fa64zyewVAT5Wfm.png" alt="工作窃取"></p><center>工作窃取</center><p>看一个Fork&#x2F;Join框架应用的例子，计算1~n之间的和：1+2+3+…+n</p><ul><li>设置一个分割阈值，任务大于阈值就拆分任务</li><li>任务有结果，所以需要继承RecursiveTask</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THRESHOLD</span> <span class="operator">=</span> <span class="number">16</span>; <span class="comment">// 阈值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CountTask</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果任务足够小就计算任务</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">canCompute</span> <span class="operator">=</span> (end - start) &lt;= THRESHOLD;</span><br><span class="line">        <span class="keyword">if</span> (canCompute) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果任务大于阈值，就分裂成两个子任务计算</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">CountTask</span> <span class="variable">leftTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountTask</span>(start, middle);</span><br><span class="line">            <span class="type">CountTask</span> <span class="variable">rightTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountTask</span>(middle + <span class="number">1</span>, end);</span><br><span class="line">            <span class="comment">// 执行子任务</span></span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork(); <span class="comment">// 等待子任务执行完，并得到其结果</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">leftResult</span> <span class="operator">=</span> leftTask.join();</span><br><span class="line">            <span class="type">int</span> <span class="variable">rightResult</span> <span class="operator">=</span> rightTask.join(); <span class="comment">// 合并子任务</span></span><br><span class="line">            sum = leftResult + rightResult;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">forkJoinPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>(); <span class="comment">// 生成一个计算任务，负责计算1+2+3+4</span></span><br><span class="line">        <span class="type">CountTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountTask</span>(<span class="number">1</span>, <span class="number">100</span>); <span class="comment">// 执行一个任务</span></span><br><span class="line">        Future&lt;Integer&gt; result = forkJoinPool.submit(task);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(result.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ForkJoinTask与一般Task的主要区别在于它需要实现compute方法，在这个方法里，首先需要判断任务是否足够小，如果足够小就直接执行任务。如果比较大，就必须分割成两个子任务，每个子任务在调用fork方法时，又会进compute方法，看看当前子任务是否需要继续分割成子任务，如果不需要继续分割，则执行当前子任务并返回结果。使用join方法会等待子任务执行完并得到其结果。</p>]]></content>
      
      
      <categories>
          
          <category> 面渣逆袭 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面渣逆袭 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面渣逆袭-JVM</title>
      <link href="/Blog/2023/03/22/interview/%E9%9D%A2%E6%B8%A3%E9%80%86%E8%A2%AD-JVM/"/>
      <url>/Blog/2023/03/22/interview/%E9%9D%A2%E6%B8%A3%E9%80%86%E8%A2%AD-JVM/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><h2 id="什么是-JVM"><a href="#什么是-JVM" class="headerlink" title="什么是 JVM?"></a>什么是 JVM?</h2><p>JVM——Java 虚拟机，它是 Java 实现平台无关性的基石。</p><p>Java 程序运行的时候，编译器将 Java 文件编译成平台无关的 Java 字节码文件（.class）,接下来对应平台 JVM 对字节码文件进行解释，翻译成对应平台匹配的机器指令并运行。</p><p><img src="https://s2.loli.net/2023/03/26/cAdiJsZzPDq65xK.png" alt="Java语言编译运行"></p><center>Java语言编译运行</center><p>同时 JVM 也是一个跨语言的平台，和语言无关，只和 class 的文件格式关联，任何语言，只要能翻译成符合规范的字节码文件，都能被 JVM 运行。</p><p><img src="https://s2.loli.net/2023/03/26/CUZDj938SrMxpKA.png" alt="JVM跨语言"></p><center>JVM跨语言</center><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="能说一下-JVM-的内存区域吗？"><a href="#能说一下-JVM-的内存区域吗？" class="headerlink" title="能说一下 JVM 的内存区域吗？"></a>能说一下 JVM 的内存区域吗？</h2><p>JVM 内存区域最粗略的划分可以分为<code>堆</code>和<code>栈</code>，当然，按照虚拟机规范，可以划分为以下几个区域：</p><p><img src="https://s2.loli.net/2023/03/26/LAh2qfwt6XjKH5l.png" alt="Java虚拟机运行时数据区"></p><center>Java虚拟机运行时数据区</center><p>JVM 内存分为线程私有区和线程共享区，其中<code>方法区</code>和<code>堆</code>是线程共享区，<code>虚拟机栈</code>、<code>本地方法栈</code>和<code>程序计数器</code>是线程隔离的数据区。</p><p><strong>1）程序计数器</strong></p><p>程序计数器（Program Counter Register）也被称为 PC 寄存器，是一块较小的内存空间。</p><p>它可以看作是当前线程所执行的字节码的行号指示器。</p><p><strong>2）Java 虚拟机栈</strong></p><p>Java 虚拟机栈（Java Virtual Machine Stack）也是线程私有的，它的生命周期与线程相同。</p><p>Java 虚拟机栈描述的是 Java 方法执行的线程内存模型：方法执行时，JVM 会同步创建一个栈帧，用来存储局部变量表、操作数栈、动态连接等。</p><p><img src="https://s2.loli.net/2023/03/26/xBojKXk4pTuOgvn.png" alt="Java虚拟机栈"></p><center>Java虚拟机栈</center><p><strong>3）本地方法栈</strong></p><p>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。</p><p>Java 虚拟机规范允许本地方法栈被实现成固定大小的或者是根据计算动态扩展和收缩的。</p><p><strong>4）Java 堆</strong></p><p>对于 Java 应用程序来说，Java 堆（Java Heap）是虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，Java 里“<strong>几乎</strong>”所有的对象实例都在这里分配内存。</p><p>Java 堆是垃圾收集器管理的内存区域，因此一些资料中它也被称作“GC 堆”（Garbage Collected Heap，）。从回收内存的角度看，由于现代垃圾收集器大部分都是基于分代收集理论设计的，所以 Java 堆中经常会出现<code>新生代</code>、<code>老年代</code>、<code>Eden空间</code>、<code>From Survivor空间</code>、<code>To Survivor空间</code>等名词，需要注意的是这种划分只是根据垃圾回收机制来进行的划分，不是 Java 虚拟机规范本身制定的。</p><p><img src="https://s2.loli.net/2023/03/26/M4DNj3SsrgaYWU2.png" alt="Java 堆内存结构"></p><center>Java 堆内存结构</center><p><strong>5）方法区</strong></p><p>方法区是比较特别的一块区域，和堆类似，它也是各个线程共享的内存区域，用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p><p>它特别在 Java 虚拟机规范对它的约束非常宽松，所以方法区的具体实现历经了许多变迁，例如 jdk1.7 之前使用永久代作为方法区的实现。</p><h2 id="说一下-JDK1-6、1-7、1-8-内存区域的变化？"><a href="#说一下-JDK1-6、1-7、1-8-内存区域的变化？" class="headerlink" title="说一下 JDK1.6、1.7、1.8 内存区域的变化？"></a>说一下 JDK1.6、1.7、1.8 内存区域的变化？</h2><p>JDK1.6、1.7&#x2F;1.8 内存区域发生了变化，主要体现在方法区的实现：</p><ul><li>JDK1.6 使用永久代实现方法区：</li></ul><p><img src="https://s2.loli.net/2023/03/26/F1AMGgnuNtbkK69.png" alt="JDK 1.6内存区域"></p><center>JDK 1.6内存区域</center><ul><li>JDK1.7 时发生了一些变化，将字符串常量池、静态变量，存放在堆上</li></ul><p><img src="https://s2.loli.net/2023/03/26/l4nBg35JoC6wrWy.png" alt="JDK 1.7内存区域"></p><center>JDK 1.7内存区域</center><ul><li>在 JDK1.8 时彻底干掉了永久代，而在直接内存中划出一块区域作为<strong>元空间</strong>，运行时常量池、类常量池都移动到元空间。</li></ul><p><img src="https://s2.loli.net/2023/03/26/JPevM8b5dTnKtlR.png" alt="JDK 1.8内存区域"></p><center>JDK 1.8内存区域</center><h2 id="为什么使用元空间替代永久代作为方法区的实现？"><a href="#为什么使用元空间替代永久代作为方法区的实现？" class="headerlink" title="为什么使用元空间替代永久代作为方法区的实现？"></a>为什么使用元空间替代永久代作为方法区的实现？</h2><p>Java 虚拟机规范规定的方法区只是换种方式实现。有客观和主观两个原因。</p><ul><li>客观上使用永久代来实现方法区的决定的设计导致了 Java 应用更容易遇到内存溢出的问题（永久代有-XX：MaxPermSize 的上限，即使不设置也有默认大小，而 J9 和 JRockit 只要没有触碰到进程可用内存的上限，例如 32 位系统中的 4GB 限制，就不会出问题），而且有极少数方法 （例如 String::intern()）会因永久代的原因而导致不同虚拟机下有不同的表现。</li><li>主观上当 Oracle 收购 BEA 获得了 JRockit 的所有权后，准备把 JRockit 中的优秀功能，譬如 Java Mission Control 管理工具，移植到 HotSpot 虚拟机时，但因为两者对方法区实现的差异而面临诸多困难。考虑到 HotSpot 未来的发展，在 JDK 6 的 时候 HotSpot 开发团队就有放弃永久代，逐步改为采用本地内存（Native Memory）来实现方法区的计划了，到了 JDK 7 的 HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出，而到了 JDK 8，终于完全废弃了永久代的概念，改用与 JRockit、J9 一样在本地内存中实现的元空间（Meta-space）来代替，把 JDK 7 中永久代还剩余的内容（主要是类型信息）全部移到元空间中。</li></ul><h2 id="对象创建的过程了解吗？"><a href="#对象创建的过程了解吗？" class="headerlink" title="对象创建的过程了解吗？"></a>对象创建的过程了解吗？</h2><p>在 JVM 中对象的创建，我们从一个 new 指令开始：</p><ul><li>首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用</li><li>检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，就先执行相应的类加载过程</li><li>类加载检查通过后，接下来虚拟机将为新生对象分配内存。</li><li>内存分配完成之后，虚拟机将分配到的内存空间（但不包括对象头）都初始化为零值。</li><li>接下来设置对象头，请求头里包含了对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。</li></ul><p>这个过程大概图示如下：</p><p><img src="https://s2.loli.net/2023/03/26/xwpLb3G96Cne7WR.png" alt="对象创建过程"></p><center>对象创建过程</center><h2 id="什么是指针碰撞？什么是空闲列表？"><a href="#什么是指针碰撞？什么是空闲列表？" class="headerlink" title="什么是指针碰撞？什么是空闲列表？"></a>什么是指针碰撞？什么是空闲列表？</h2><p>内存分配有两种方式，<strong>指针碰撞</strong>（Bump The Pointer）、<strong>空闲列表</strong>（Free List）。</p><p><img src="https://s2.loli.net/2023/03/26/1nGJK4xfAEbVYa9.png" alt="指针碰撞和空闲列表"></p><center>指针碰撞和空闲列表</center><ul><li>指针碰撞：假设 Java 堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”。</li><li>空闲列表：如果 Java 堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”。</li><li>两种方式的选择由 Java 堆是否规整决定，Java 堆是否规整是由选择的垃圾收集器是否具有压缩整理能力决定的。</li></ul><h2 id="JVM-里-new-对象时，堆会发生抢占吗？JVM-是怎么设计来保证线程安全的？"><a href="#JVM-里-new-对象时，堆会发生抢占吗？JVM-是怎么设计来保证线程安全的？" class="headerlink" title="JVM 里 new 对象时，堆会发生抢占吗？JVM 是怎么设计来保证线程安全的？"></a>JVM 里 new 对象时，堆会发生抢占吗？JVM 是怎么设计来保证线程安全的？</h2><p>会，假设 JVM 虚拟机上，每一次 new 对象时，指针就会向右移动一个对象 size 的距离，一个线程正在给 A 对象分配内存，指针还没有来的及修改，另一个为 B 对象分配内存的线程，又引用了这个指针来分配内存，这就发生了抢占。</p><p>有两种可选方案来解决这个问题：</p><p><img src="https://s2.loli.net/2023/03/26/GSwMIWPciLnZXNJ.png" alt="堆抢占和解决方案"></p><center>堆抢占和解决方案</center><ul><li><p>采用 CAS 分配重试的方式来保证更新操作的原子性</p></li><li><p>每个线程在 Java 堆中预先分配一小块内存，也就是本地线程分配缓冲（Thread Local Allocation</p><p>Buffer，TLAB），要分配内存的线程，先在本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。</p></li></ul><h2 id="能说一下对象的内存布局吗？"><a href="#能说一下对象的内存布局吗？" class="headerlink" title="能说一下对象的内存布局吗？"></a>能说一下对象的内存布局吗？</h2><p>在 HotSpot 虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p><p><img src="https://s2.loli.net/2023/03/26/3JFS9fx7anMGtmU.png" alt="对象的存储布局"></p><center>对象的存储布局</center><p><strong>对象头</strong>主要由两部分组成：</p><ul><li>第一部分存储对象自身的运行时数据：哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等，官方称它为 Mark Word，它是个动态的结构，随着对象状态变化。</li><li>第二部分是类型指针，指向对象的类元数据类型（即对象代表哪个类）。</li><li>此外，如果对象是一个 Java 数组，那还应该有一块用于记录数组长度的数据</li></ul><p><strong>实例数据</strong>用来存储对象真正的有效信息，也就是我们在程序代码里所定义的各种类型的字段内容，无论是从父类继承的，还是自己定义的。</p><p><strong>对齐填充</strong>不是必须的，没有特别含义，仅仅起着占位符的作用。</p><h2 id="对象怎么访问定位？"><a href="#对象怎么访问定位？" class="headerlink" title="对象怎么访问定位？"></a>对象怎么访问定位？</h2><p>Java 程序会通过栈上的 reference 数据来操作堆上的具体对象。由于 reference 类型在《Java 虚拟机规范》里面只规定了它是一个指向对象的引用，并没有定义这个引用应该通过什么方式去定位、访问到堆中对象的具体位置，所以对象访问方式也是由虚拟机实现而定的，主流的访问方式主要有使用句柄和直接指针两种：</p><ul><li>如果使用句柄访问的话，Java 堆中将可能会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息，其结构如图所示：</li></ul><p><img src="https://s2.loli.net/2023/03/26/RVG8XdSp5cWKFe2.png" alt="通过句柄访问对象"></p><center>通过句柄访问对象</center><ul><li>如果使用直接指针访问的话，Java 堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference 中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销，如图所示：</li></ul><p><img src="https://s2.loli.net/2023/03/26/SGMne2byCBYfgIp.png" alt="通过直接指针访问对象"></p><center>通过直接指针访问对象</center><p>这两种对象访问方式各有优势，使用句柄来访问的最大好处就是 reference 中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference 本身不需要被修改。</p><p>使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问在 Java 中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本。</p><p>HotSpot 虚拟机主要使用直接指针来进行对象访问。</p><h2 id="内存溢出和内存泄漏是什么意思？"><a href="#内存溢出和内存泄漏是什么意思？" class="headerlink" title="内存溢出和内存泄漏是什么意思？"></a>内存溢出和内存泄漏是什么意思？</h2><p>内存泄露就是申请的内存空间没有被正确释放，导致内存被白白占用。</p><p>内存溢出就是申请的内存超过了可用内存，内存不够了。</p><p>两者关系：内存泄露可能会导致内存溢出。</p><p>用一个有味道的比喻，内存溢出就是排队去蹲坑，发现没坑位了，内存泄漏，就是有人占着茅坑不拉屎，占着茅坑不拉屎的多了可能会导致坑位不够用。</p><p><img src="https://s2.loli.net/2023/03/26/zlcNIHLw7mP38Av.png" alt="内存泄漏、内存溢出"></p><center>内存泄漏、内存溢出</center><h2 id="能手写内存溢出的例子吗？"><a href="#能手写内存溢出的例子吗？" class="headerlink" title="能手写内存溢出的例子吗？"></a>能手写内存溢出的例子吗？</h2><p>在 JVM 的几个内存区域中，除了程序计数器外，其他几个运行时区域都有发生内存溢出（OOM）异常的可能，重点关注堆和栈。</p><ul><li>Java 堆溢出</li></ul><p>Java 堆用于储存对象实例，只要不断创建不可被回收的对象，比如静态对象，那么随着对象数量的增加，总容量触及最大堆的容量限制后就会产生内存溢出异常（OutOfMemoryError）。</p><p>这就相当于一个房子里，不断堆积不能被收走的杂物，那么房子很快就会被堆满了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM参数： -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapOOM</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OOMObject</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;OOMObject&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;OOMObject&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">OOMObject</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>虚拟机栈.OutOfMemoryError</li></ul><p>JDK 使用的 HotSpot 虚拟机的栈内存大小是固定的，我们可以把栈的内存设大一点，然后不断地去创建线程，因为操作系统给每个进程分配的内存是有限的，所以到最后，也会发生 OutOfMemoryError 异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * vm参数：-Xss2M</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaVMStackOOM</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dontStop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stackLeakByThread</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    dontStop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">JavaVMStackOOM</span> <span class="variable">oom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JavaVMStackOOM</span>();</span><br><span class="line">        oom.stackLeakByThread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内存泄漏可能由哪些原因导致呢？"><a href="#内存泄漏可能由哪些原因导致呢？" class="headerlink" title="内存泄漏可能由哪些原因导致呢？"></a>内存泄漏可能由哪些原因导致呢？</h2><p>内存泄漏可能的原因有很多种：</p><p><img src="https://s2.loli.net/2023/03/26/du4fmS8XgeWzIh6.png" alt="内存泄漏可能原因"></p><center>内存泄漏可能原因</center><p><strong>静态集合类引起内存泄漏</strong></p><p>静态集合的生命周期和 JVM 一致，所以静态集合引用的对象不能被释放。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OOM</span> &#123;</span><br><span class="line"> <span class="keyword">static</span> <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">oomTests</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">   list.add(obj);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>单例模式</strong></p><p>和上面的例子原理类似，单例对象在初始化后会以静态变量的方式在 JVM 的整个生命周期中存在。如果单例对象持有外部的引用，那么这个外部对象将不能被 GC 回收，导致内存泄漏。</p><p><strong>数据连接、IO、Socket 等连接</strong></p><p>创建的连接不再使用时，需要调用 <strong>close</strong> 方法关闭连接，只有连接被关闭后，GC 才会回收对应的对象（Connection，Statement，ResultSet，Session）。忘记关闭这些资源会导致持续占有内存，无法被 GC 回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">    conn = DriverManager.getConnection(<span class="string">&quot;url&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(<span class="string">&quot;....&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//不关闭连接</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>变量不合理的作用域</strong></p><p>一个变量的定义作用域大于其使用范围，很可能存在内存泄漏；或不再使用对象没有及时将对象设置为 null，很可能导致内存泄漏的发生。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Simple</span> &#123;</span><br><span class="line">    Object object;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">        object = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="comment">//...其他代码</span></span><br><span class="line">        <span class="comment">//由于作用域原因，method1执行完成之后，object 对象所分配的内存不会马上释放</span></span><br><span class="line">        object = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>hash 值发生变化</strong></p><p>对象 Hash 值改变，使用 HashMap、HashSet 等容器中时候，由于对象修改之后的 Hah 值和存储进容器时的 Hash 值不同，所以无法找到存入的对象，自然也无法单独删除了，这也会造成内存泄漏。说句题外话，这也是为什么 String 类型被设置成了不可变类型。</p><p><strong>ThreadLocal 使用不当</strong></p><p>ThreadLocal 的弱引用导致内存泄漏也是个老生常谈的话题了，使用完 ThreadLocal 一定要记得使用 remove 方法来进行清除。</p><h2 id="如何判断对象仍然存活？"><a href="#如何判断对象仍然存活？" class="headerlink" title="如何判断对象仍然存活？"></a>如何判断对象仍然存活？</h2><p>有两种方式，<strong>引用计数算法（reference counting）</strong>和可达性分析算法。</p><ul><li><strong>引用计数算法</strong></li></ul><p>引用计数器的算法是这样的：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。</p><p><img src="https://s2.loli.net/2023/03/26/43vcCTglxYJXAbz.png" alt="引用计数算法"></p><center>引用计数算法</center><ul><li><strong>可达性分析算法</strong></li></ul><p>目前 Java 虚拟机的主流垃圾回收器采取的是可达性分析算法。这个算法的实质在于将一系列 GC Roots 作为初始的存活对象合集（Gc Root Set），然后从该合集出发，探索所有能够被该集合引用到的对象，并将其加入到该集合中，这个过程我们也称之为标记（mark）。最终，未被探索到的对象便是死亡的，是可以回收的。 <img src="https://s2.loli.net/2023/03/26/fTBikoHaVAyJYzP.png" alt="GC Root"></p><h2 id="Java-中可作为-GC-Roots-的对象有哪几种？"><a href="#Java-中可作为-GC-Roots-的对象有哪几种？" class="headerlink" title="Java 中可作为 GC Roots 的对象有哪几种？"></a>Java 中可作为 GC Roots 的对象有哪几种？</h2><p>可以作为 GC Roots 的主要有四种对象：</p><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中 JNI 引用的对象</li></ul><h2 id="说一下对象有哪几种引用？"><a href="#说一下对象有哪几种引用？" class="headerlink" title="说一下对象有哪几种引用？"></a>说一下对象有哪几种引用？</h2><p>Java 中的引用有四种，分为强引用（Strongly Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）4 种，这 4 种引用强度依次逐渐减弱。</p><ul><li>强引用是最传统的<code>引用</code>的定义，是指在程序代码之中普遍存在的引用赋值，无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure><ul><li>软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存， 才会抛出内存溢出异常。在 JDK 1.2 版之后提供了 SoftReference 类来实现软引用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="type">ReferenceQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>();</span><br><span class="line"><span class="type">SoftReference</span> <span class="variable">reference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SoftReference</span>(obj, queue);</span><br><span class="line"><span class="comment">//强引用对象滞空，保留软引用</span></span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><ul><li>弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在 JDK 1.2 版之后提供了 WeakReference 类来实现弱引用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="type">ReferenceQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>();</span><br><span class="line"><span class="type">WeakReference</span> <span class="variable">reference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeakReference</span>(obj, queue);</span><br><span class="line"><span class="comment">//强引用对象滞空，保留软引用</span></span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><ul><li>虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在 JDK 1.2 版之后提供了 PhantomReference 类来实现虚引用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="type">ReferenceQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>();</span><br><span class="line"><span class="type">PhantomReference</span> <span class="variable">reference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhantomReference</span>(obj, queue);</span><br><span class="line"><span class="comment">//强引用对象滞空，保留软引用</span></span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/03/26/G2gysbCfkAaclYD.png" alt="四种引用总结"></p><center>四种引用总结</center><h2 id="finalize-方法了解吗？有什么作用？"><a href="#finalize-方法了解吗？有什么作用？" class="headerlink" title="finalize()方法了解吗？有什么作用？"></a>finalize()方法了解吗？有什么作用？</h2><p>用一个不太贴切的比喻，垃圾回收就是古代的秋后问斩，finalize()就是刀下留人，在人犯被处决之前，还要做最后一次审计，青天大老爷看看有没有什么冤情，需不需要刀下留人。</p><p><img src="https://s2.loli.net/2023/03/26/q1MX7cumiEgLp9I.png" alt="刀下留人"></p><center>刀下留人</center><p>如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行 finalize()方法。如果对象在在 finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己 （this 关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它就”逃过一劫“；但是如果没有抓住这个机会，那么对象就真的要被回收了。</p><h2 id="Java-堆的内存分区了解吗？"><a href="#Java-堆的内存分区了解吗？" class="headerlink" title="Java 堆的内存分区了解吗？"></a>Java 堆的内存分区了解吗？</h2><p>按照垃圾收集，将 Java 堆划分为<strong>新生代 （Young Generation）</strong>和<strong>老年代（Old Generation）</strong>两个区域，新生代存放存活时间短的对象，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放。</p><p>而新生代又可以分为三个区域，eden、from、to，比例是 8：1：1，而新生代的内存分区同样是从垃圾收集的角度来分配的。</p><p><img src="https://s2.loli.net/2023/03/26/28htC4LOumpq6Xs.png" alt="Java堆内存划分"></p><center>Java堆内存划分</center><h2 id="垃圾收集算法了解吗？"><a href="#垃圾收集算法了解吗？" class="headerlink" title="垃圾收集算法了解吗？"></a>垃圾收集算法了解吗？</h2><p>垃圾收集算法主要有三种：</p><ol><li><strong>标记-清除算法</strong></li></ol><p>见名知义，<code>标记-清除</code>（Mark-Sweep）算法分为两个阶段：</p><ul><li><strong>标记</strong> : 标记出所有需要回收的对象</li><li><strong>清除</strong>：回收所有被标记的对象</li></ul><p><img src="https://s2.loli.net/2023/03/26/A8ctxWieMPmHaFL.png" alt="标记-清除算法"></p><center>标记-清除算法</center><p>标记-清除算法比较基础，但是主要存在两个缺点：</p><ul><li>执行效率不稳定，如果 Java 堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低。</li><li>内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li></ul><ol><li><strong>标记-复制算法</strong></li></ol><p>标记-复制算法解决了标记-清除算法面对大量可回收对象时执行效率低的问题。</p><p>过程也比较简单：将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p><p><img src="https://s2.loli.net/2023/03/26/5KIfyEmoMzN8AHs.png" alt="标记-复制算法"></p><center>标记-复制算法</center><p>这种算法存在一个明显的缺点：一部分空间没有使用，存在空间的浪费。</p><p>新生代垃圾收集主要采用这种算法，因为新生代的存活对象比较少，每次复制的只是少量的存活对象。当然，实际新生代的收集不是按照这个比例。</p><ol><li><strong>标记-整理算法</strong></li></ol><p>为了降低内存的消耗，引入一种针对性的算法：<code>标记-整理</code>（Mark-Compact）算法。</p><p>其中的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。</p><p><img src="https://s2.loli.net/2023/03/26/e2janCh4UKuMdVr.png" alt="标记-整理算法"></p><center>标记-整理算法</center><p>标记-整理算法主要用于老年代，移动存活对象是个极为负重的操作，而且这种操作需要 Stop The World 才能进行，只是从整体的吞吐量来考量，老年代使用标记-整理算法更加合适。</p><h2 id="说一下新生代的区域划分？"><a href="#说一下新生代的区域划分？" class="headerlink" title="说一下新生代的区域划分？"></a>说一下新生代的区域划分？</h2><p>新生代的垃圾收集主要采用标记-复制算法，因为新生代的存活对象比较少，每次复制少量的存活对象效率比较高。</p><p>基于这种算法，虚拟机将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次分配内存只使用 Eden 和其中一块 Survivor。发生垃圾收集时，将 Eden 和 Survivor 中仍然存活的对象一次性复制到另外一块 Survivor 空间上，然后直接清理掉 Eden 和已用过的那块 Survivor 空间。默认 Eden 和 Survivor 的大小比例是 8∶1。</p><p><img src="https://s2.loli.net/2023/03/26/cvAYte1bWNRXLP6.png" alt="新生代内存划分"></p><center>新生代内存划分</center><h2 id="Minor-GC-x2F-Young-GC、Major-GC-x2F-Old-GC、Mixed-GC、Full-GC-都是什么意思？"><a href="#Minor-GC-x2F-Young-GC、Major-GC-x2F-Old-GC、Mixed-GC、Full-GC-都是什么意思？" class="headerlink" title="Minor GC&#x2F;Young GC、Major GC&#x2F;Old GC、Mixed GC、Full GC 都是什么意思？"></a>Minor GC&#x2F;Young GC、Major GC&#x2F;Old GC、Mixed GC、Full GC 都是什么意思？</h2><p><strong>部分收集</strong>（Partial GC）：指目标不是完整收集整个 Java 堆的垃圾收集，其中又分为：</p><ul><li>新生代收集（Minor GC&#x2F;Young GC）：指目标只是新生代的垃圾收集。</li><li>老年代收集（Major GC&#x2F;Old GC）：指目标只是老年代的垃圾收集。目前<strong>只有</strong>CMS 收集器会有单独收集老年代的行为。</li><li>混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有 G1 收集器会有这种行为。</li></ul><p><strong>整堆收集</strong>（Full GC）：收集整个 Java 堆和方法区的垃圾收集。</p><h2 id="Minor-GC-x2F-Young-GC-什么时候触发？"><a href="#Minor-GC-x2F-Young-GC-什么时候触发？" class="headerlink" title="Minor GC&#x2F;Young GC 什么时候触发？"></a>Minor GC&#x2F;Young GC 什么时候触发？</h2><p>新创建的对象优先在新生代 Eden 区进行分配，如果 Eden 区没有足够的空间时，就会触发 Young GC 来清理新生代。</p><h2 id="什么时候会触发-Full-GC？"><a href="#什么时候会触发-Full-GC？" class="headerlink" title="什么时候会触发 Full GC？"></a>什么时候会触发 Full GC？</h2><p>这个触发条件稍微有点多，往下看：</p><p><img src="https://s2.loli.net/2023/03/26/1dH7DSvXTaw3C28.png" alt="Full GC触发条件"></p><center>Full GC触发条件</center><ul><li><strong>Young GC 之前检查老年代</strong>：在要进行 Young GC 的时候，发现<code>老年代可用的连续内存空间</code> &lt; <code>新生代历次Young GC后升入老年代的对象总和的平均大小</code>，说明本次 Young GC 后可能升入老年代的对象大小，可能超过了老年代当前可用内存空间,那就会触发 Full GC。</li><li><strong>Young GC 之后老年代空间不足</strong>：执行 Young GC 之后有一批对象需要放入老年代，此时老年代就是没有足够的内存空间存放这些对象了，此时必须立即触发一次 Full GC</li><li><strong>老年代空间不足</strong>，老年代内存使用率过高，达到一定比例，也会触发 Full GC。</li><li><strong>空间分配担保失败</strong>（ Promotion Failure），新生代的 To 区放不下从 Eden 和 From 拷贝过来对象，或者新生代对象 GC 年龄到达阈值需要晋升这两种情况，老年代如果放不下的话都会触发 Full GC。</li><li><strong>方法区内存空间不足</strong>：如果方法区由永久代实现，永久代空间不足 Full GC。</li><li><strong>System.gc()等命令触发</strong>：System.gc()、jmap -dump 等命令会触发 full gc。</li></ul><h2 id="对象什么时候会进入老年代？"><a href="#对象什么时候会进入老年代？" class="headerlink" title="对象什么时候会进入老年代？"></a>对象什么时候会进入老年代？</h2><p><img src="https://s2.loli.net/2023/03/26/jPvhpJgHc9M3Nl6.png" alt="对象进入老年代"></p><center>对象进入老年代</center><p><strong>长期存活的对象将进入老年代</strong></p><p>在对象的对象头信息中存储着对象的迭代年龄,迭代年龄会在每次 YoungGC 之后对象的移区操作中增加,每一次移区年龄加一.当这个年龄达到 15(默认)之后,这个对象将会被移入老年代。</p><p>可以通过这个参数设置这个年龄值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- XX:MaxTenuringThreshold</span><br></pre></td></tr></table></figure><p><strong>大对象直接进入老年代</strong></p><p>有一些占用大量连续内存空间的对象在被加载就会直接进入老年代.这样的大对象一般是一些数组,长字符串之类的对。</p><p>HotSpot 虚拟机提供了这个参数来设置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX：PretenureSizeThreshold</span><br></pre></td></tr></table></figure><p><strong>动态对象年龄判定</strong></p><p>为了能更好地适应不同程序的内存状况，HotSpot 虚拟机并不是永远要求对象的年龄必须达到- XX：MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。</p><p><strong>空间分配担保</strong></p><p>假如在 Young GC 之后，新生代仍然有大量对象存活，就需要老年代进行分配担保，把 Survivor 无法容纳的对象直接送入老年代。</p><h2 id="知道有哪些垃圾收集器吗？"><a href="#知道有哪些垃圾收集器吗？" class="headerlink" title="知道有哪些垃圾收集器吗？"></a>知道有哪些垃圾收集器吗？</h2><p>主要垃圾收集器如下，图中标出了它们的工作区域、垃圾收集算法，以及配合关系。</p><p><img src="https://s2.loli.net/2023/03/26/oKXHhcTf8YqrNBE.png" alt="HotSpot虚拟机垃圾收集器"></p><center>HotSpot虚拟机垃圾收集器</center><p>这些收集器里，面试的重点是两个——<strong>CMS</strong>和<strong>G1</strong>。</p><ul><li>Serial 收集器</li></ul><p>Serial 收集器是最基础、历史最悠久的收集器。</p><p>如同它的名字（串行），它是一个单线程工作的收集器，使用一个处理器或一条收集线程去完成垃圾收集工作。并且进行垃圾收集时，必须暂停其他所有工作线程，直到垃圾收集结束——这就是所谓的“Stop The World”。</p><p>Serial&#x2F;Serial Old 收集器的运行过程如图：</p><p><img src="https://s2.loli.net/2023/03/26/ywiR4eLFTxgBzro.png" alt="Serial/Serial Old收集器运行示意图"></p><center>Serial/Serial Old收集器运行示意图</center><ul><li>ParNew</li></ul><p>ParNew 收集器实质上是 Serial 收集器的多线程并行版本，使用多条线程进行垃圾收集。</p><p>ParNew&#x2F;Serial Old 收集器运行示意图如下：</p><p><img src="https://s2.loli.net/2023/03/26/9TQ14uHKx7BgO8o.png" alt="ParNew/Serial Old收集器运行示意图"></p><center>ParNew/Serial Old收集器运行示意图</center><ul><li>Parallel Scavenge</li></ul><p>Parallel Scavenge 收集器是一款新生代收集器，基于标记-复制算法实现，也能够并行收集。和 ParNew 有些类似，但 Parallel Scavenge 主要关注的是垃圾收集的吞吐量——所谓吞吐量，就是 CPU 用于运行用户代码的时间和总消耗时间的比值，比值越大，说明垃圾收集的占比越小。</p><p><img src="https://s2.loli.net/2023/03/26/YCSOrvFhBa1wexI.png" alt="吞吐量"></p><center>吞吐量</center><ul><li>Serial Old</li></ul><p>Serial Old 是 Serial 收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。</p><ul><li>Parallel Old</li></ul><p>Parallel Old 是 Parallel Scavenge 收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。</p><p><img src="https://s2.loli.net/2023/03/26/VKC91lt7YbN283Z.png" alt="Parallel Scavenge/Parallel Old收集器运行示意图"></p><center>Parallel Scavenge/Parallel Old收集器运行示意图</center><ul><li>CMS 收集器</li></ul><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，同样是老年代的收集器，采用标记-清除算法。</p><ul><li>Garbage First 收集器</li></ul><p>Garbage First（简称 G1）收集器是垃圾收集器的一个颠覆性的产物，它开创了局部收集的设计思路和基于 Region 的内存布局形式。</p><h2 id="什么是-Stop-The-World-什么是-OopMap-？什么是安全点？"><a href="#什么是-Stop-The-World-什么是-OopMap-？什么是安全点？" class="headerlink" title="什么是 Stop The World ? 什么是 OopMap ？什么是安全点？"></a>什么是 Stop The World ? 什么是 OopMap ？什么是安全点？</h2><p>进行垃圾回收的过程中，会涉及对象的移动。为了保证对象引用更新的正确性，必须暂停所有的用户线程，像这样的停顿，虚拟机设计者形象描述为<code>Stop The World</code>。也简称为 STW。</p><p>在 HotSpot 中，有个数据结构（映射表）称为<code>OopMap</code>。一旦类加载动作完成的时候，HotSpot 就会把对象内什么偏移量上是什么类型的数据计算出来，记录到 OopMap。在即时编译过程中，也会在<code>特定的位置</code>生成 OopMap，记录下栈上和寄存器里哪些位置是引用。</p><p>这些特定的位置主要在：</p><ul><li>1.循环的末尾（非 counted 循环）</li><li>2.方法临返回前 &#x2F; 调用方法的 call 指令后</li><li>3.可能抛异常的位置</li></ul><p>这些位置就叫作<strong>安全点(safepoint)。</strong> 用户程序执行时并非在代码指令流的任意位置都能够在停顿下来开始垃圾收集，而是必须是执行到安全点才能够暂停。</p><p>用通俗的比喻，假如老王去拉车，车上东西很重，老王累的汗流浃背，但是老王不能在上坡或者下坡休息，只能在平地上停下来擦擦汗，喝口水。</p><p><img src="https://s2.loli.net/2023/03/26/oXZthnSVxKsEuNf.png" alt="老王拉车只能在平路休息"></p><center>老王拉车只能在平路休息</center><h2 id="能详细说一下-CMS-收集器的垃圾收集过程吗？"><a href="#能详细说一下-CMS-收集器的垃圾收集过程吗？" class="headerlink" title="能详细说一下 CMS 收集器的垃圾收集过程吗？"></a>能详细说一下 CMS 收集器的垃圾收集过程吗？</h2><p>CMS 收集齐的垃圾收集分为四步：</p><ul><li><strong>初始标记</strong>（CMS initial mark）：单线程运行，需要 Stop The World，标记 GC Roots 能直达的对象。</li><li><strong>并发标记</strong>（（CMS concurrent mark）：无停顿，和用户线程同时运行，从 GC Roots 直达对象开始遍历整个对象图。</li><li><strong>重新标记</strong>（CMS remark）：多线程运行，需要 Stop The World，标记并发标记阶段产生对象。</li><li><strong>并发清除</strong>（CMS concurrent sweep）：无停顿，和用户线程同时运行，清理掉标记阶段标记的死亡的对象。</li></ul><p>Concurrent Mark Sweep 收集器运行示意图如下：</p><p><img src="https://s2.loli.net/2023/03/26/rkBMfip25HytXGw.png" alt="Concurrent Mark Sweep收集器运行示意图"></p><center>Concurrent Mark Sweep收集器运行示意图</center><h2 id="G1-垃圾收集器了解吗？"><a href="#G1-垃圾收集器了解吗？" class="headerlink" title="G1 垃圾收集器了解吗？"></a>G1 垃圾收集器了解吗？</h2><p>Garbage First（简称 G1）收集器是垃圾收集器的一个颠覆性的产物，它开创了局部收集的设计思路和基于 Region 的内存布局形式。</p><p>虽然 G1 也仍是遵循分代收集理论设计的，但其堆内存的布局与其他收集器有非常明显的差异。以前的收集器分代是划分新生代、老年代、持久代等。</p><p>G1 把连续的 Java 堆划分为多个大小相等的独立区域（Region），每一个 Region 都可以根据需要，扮演新生代的 Eden 空间、Survivor 空间，或者老年代空间。收集器能够对扮演不同角色的 Region 采用不同的策略去处理。</p><p><img src="https://s2.loli.net/2023/03/26/xfTDzVuEUQKXJpO.png" alt="G1 Heap Regions"></p><center>G1 Heap Regions</center><p>这样就避免了收集整个堆，而是按照若干个 Region 集进行收集，同时维护一个优先级列表，跟踪各个 Region 回收的“价值，优先收集价值高的 Region。</p><p>G1 收集器的运行过程大致可划分为以下四个步骤：</p><ul><li><strong>初始标记</strong>（initial mark），标记了从 GC Root 开始直接关联可达的对象。STW（Stop the World）执行。</li><li><strong>并发标记</strong>（concurrent marking），和用户线程并发执行，从 GC Root 开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象、</li><li><strong>最终标记</strong>（Remark），STW，标记再并发标记过程中产生的垃圾。</li><li><strong>筛选回收</strong>（Live Data Counting And Evacuation），制定回收计划，选择多个 Region 构成回收集，把回收集中 Region 的存活对象复制到空的 Region 中，再清理掉整个旧 Region 的全部空间。需要 STW。</li></ul><p><img src="https://s2.loli.net/2023/03/26/kwbDEHvyeu8VznQ.png" alt="G1收集器运行示意图"></p><center>G1收集器运行示意图</center><h2 id="有了-CMS，为什么还要引入-G1？"><a href="#有了-CMS，为什么还要引入-G1？" class="headerlink" title="有了 CMS，为什么还要引入 G1？"></a>有了 CMS，为什么还要引入 G1？</h2><p>优点：CMS 最主要的优点在名字上已经体现出来——并发收集、低停顿。</p><p>缺点：CMS 同样有三个明显的缺点。</p><ul><li>Mark Sweep 算法会导致内存碎片比较多</li><li>CMS 的并发能力比较依赖于 CPU 资源，并发回收时垃圾收集线程可能会抢占用户线程的资源，导致用户程序性能下降。</li><li>并发清除阶段，用户线程依然在运行，会产生所谓的理“浮动垃圾”（Floating Garbage），本次垃圾收集无法处理浮动垃圾，必须到下一次垃圾收集才能处理。如果浮动垃圾太多，会触发新的垃圾回收，导致性能降低。</li></ul><p>G1 主要解决了内存碎片过多的问题。</p><h2 id="你们线上用的什么垃圾收集器？为什么要用它？"><a href="#你们线上用的什么垃圾收集器？为什么要用它？" class="headerlink" title="你们线上用的什么垃圾收集器？为什么要用它？"></a>你们线上用的什么垃圾收集器？为什么要用它？</h2><p>怎么说呢，虽然调优说的震天响，但是我们一般都是用默认。管你 Java 怎么升，我用 8，那么 JDK1.8 默认用的是什么呢？</p><p>可以使用命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintCommandLineFlags -version</span><br></pre></td></tr></table></figure><p>可以看到有这么一行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC</span><br></pre></td></tr></table></figure><p><code>UseParallelGC</code> &#x3D; <code>Parallel Scavenge + Parallel Old</code>，表示的是新生代用的<code>Parallel Scavenge</code>收集器，老年代用的是<code>Parallel Old</code> 收集器。</p><p>那为什么要用这个呢？默认的呗。</p><p>当然面试肯定不能这么答。</p><p>Parallel Scavenge 的特点是什么？</p><p>高吞吐，我们可以回答：因为我们系统是业务相对复杂，但并发并不是非常高，所以希望尽可能的利用处理器资源，出于提高吞吐量的考虑采用<code>Parallel Scavenge + Parallel Old</code>的组合。</p><p>当然，这个默认虽然也有说法，但不太讨喜。</p><p>还可以说：</p><p>采用<code>Parallel New</code>+<code>CMS</code>的组合，我们比较关注服务的响应速度，所以采用了 CMS 来降低停顿时间。</p><p>或者一步到位：</p><p>我们线上采用了设计比较优秀的 G1 垃圾收集器，因为它不仅满足我们低停顿的要求，而且解决了 CMS 的浮动垃圾问题、内存碎片问题。</p><h2 id="垃圾收集器应该如何选择？"><a href="#垃圾收集器应该如何选择？" class="headerlink" title="垃圾收集器应该如何选择？"></a>垃圾收集器应该如何选择？</h2><p>垃圾收集器的选择需要权衡的点还是比较多的——例如运行应用的基础设施如何？使用 JDK 的发行商是什么？等等……</p><p>这里简单地列一下上面提到的一些收集器的适用场景：</p><ul><li>Serial ：如果应用程序有一个很小的内存空间（大约 100 MB）亦或它在没有停顿时间要求的单线程处理器上运行。</li><li>Parallel：如果优先考虑应用程序的峰值性能，并且没有时间要求要求，或者可以接受 1 秒或更长的停顿时间。</li><li>CMS&#x2F;G1：如果响应时间比吞吐量优先级高，或者垃圾收集暂停必须保持在大约 1 秒以内。</li><li>ZGC：如果响应时间是高优先级的，或者堆空间比较大。</li></ul><h2 id="对象一定分配在堆中吗？有没有了解逃逸分析技术？"><a href="#对象一定分配在堆中吗？有没有了解逃逸分析技术？" class="headerlink" title="对象一定分配在堆中吗？有没有了解逃逸分析技术？"></a>对象一定分配在堆中吗？有没有了解逃逸分析技术？</h2><p><strong>对象一定分配在堆中吗？</strong> 不一定的。</p><p>随着 JIT 编译期的发展与逃逸分析技术逐渐成熟，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。其实，在编译期间，JIT 会对代码做很多优化。其中有一部分优化的目的就是减少内存堆分配压力，其中一种重要的技术叫做逃逸分析。</p><p><strong>什么是逃逸分析？</strong></p><p><strong>逃逸分析</strong>是指分析指针动态范围的方法，它同编译器优化原理的指针分析和外形分析相关联。当变量（或者对象）在方法中分配后，其指针有可能被返回或者被全局引用，这样就会被其他方法或者线程所引用，这种现象称作指针（或者引用）的逃逸(Escape)。</p><p>通俗点讲，当一个对象被 new 出来之后，它可能被外部所调用，如果是作为参数传递到外部了，就称之为方法逃逸。</p><p><img src="https://s2.loli.net/2023/03/26/JLy9NFkO6xvhdTm.png" alt="逃逸"></p><center>逃逸</center><p>除此之外，如果对象还有可能被外部线程访问到，例如赋值给可以在其它线程中访问的实例变量，这种就被称为线程逃逸。</p><p><img src="https://s2.loli.net/2023/03/26/BjHRV87Lzg6FU3p.png" alt="逃逸强度"></p><center>逃逸强度</center><p><strong>逃逸分析的好处</strong></p><ul><li>栈上分配</li></ul><p>如果确定一个对象不会逃逸到线程之外，那么久可以考虑将这个对象在栈上分配，对象占用的内存随着栈帧出栈而销毁，这样一来，垃圾收集的压力就降低很多。</p><ul><li><strong>同步消除</strong></li></ul><p>线程同步本身是一个相对耗时的过程，如果逃逸分析能够确定一个变量不会逃逸出线程，无法被其他线程访问，那么这个变量的读写肯定就不会有竞争， 对这个变量实施的同步措施也就可以安全地消除掉。</p><ul><li><strong>标量替换</strong></li></ul><p>如果一个数据是基本数据类型，不可拆分，它就被称之为标量。把一个 Java 对象拆散，将其用到的成员变量恢复为原始类型来访问，这个过程就称为标量替换。假如逃逸分析能够证明一个对象不会被方法外部访问，并且这个对象可以被拆散，那么可以不创建对象，直接用创建若干个成员变量代替，可以让对象的成员变量在栈上分配和读写。</p><h1 id="JVM-调优"><a href="#JVM-调优" class="headerlink" title="JVM 调优"></a>JVM 调优</h1><h2 id="有哪些常用的命令行性能监控和故障处理工具？"><a href="#有哪些常用的命令行性能监控和故障处理工具？" class="headerlink" title="有哪些常用的命令行性能监控和故障处理工具？"></a>有哪些常用的命令行性能监控和故障处理工具？</h2><ul><li>操作系统工具<ul><li>top：显示系统整体资源使用情况</li><li>vmstat：监控内存和 CPU</li><li>iostat：监控 IO 使用</li><li>netstat：监控网络使用</li></ul></li><li>JDK 性能监控工具<ul><li>jps：虚拟机进程查看</li><li>jstat：虚拟机运行时信息查看</li><li>jinfo：虚拟机配置查看</li><li>jmap：内存映像（导出）</li><li>jhat：堆转储快照分析</li><li>jstack：Java 堆栈跟踪</li><li>jcmd：实现上面除了 jstat 外所有命令的功能</li></ul></li></ul><h2 id="了解哪些可视化的性能监控和故障处理工具？"><a href="#了解哪些可视化的性能监控和故障处理工具？" class="headerlink" title="了解哪些可视化的性能监控和故障处理工具？"></a>了解哪些可视化的性能监控和故障处理工具？</h2><p>以下是一些 JDK 自带的可视化性能监控和故障处理工具：</p><ul><li>JConsole</li></ul><p><img src="https://s2.loli.net/2023/03/26/zVutLrKichUaCWH.png" alt="JConsole概览"></p><center>JConsole概览</center><ul><li>VisualVM</li></ul><p><img src="https://s2.loli.net/2023/03/27/cz1ErnQmS78dVT3.png" alt="VisualVM安装插件"></p><center>VisualVM安装插件</center><ul><li>Java Mission Control</li></ul><p><img src="https://s2.loli.net/2023/03/26/Mjgsm75NOhoucqZ.png" alt="JMC主要界面"></p><center>JMC主要界面</center><p>除此之外，还有一些第三方的工具：</p><ul><li><strong>MAT</strong></li></ul><p>Java 堆内存分析工具。</p><ul><li><strong>GChisto</strong></li></ul><p>GC 日志分析工具。</p><ul><li><strong>GCViewer</strong></li></ul><p><code>GC</code> 日志分析工具。</p><ul><li><strong>JProfiler</strong></li></ul><p>商用的性能分析利器。</p><ul><li><strong>arthas</strong></li></ul><p>阿里开源诊断工具。</p><ul><li><strong>async-profiler</strong></li></ul><p>Java 应用性能分析工具，开源、火焰图、跨平台。</p><h2 id="JVM-的常见参数配置知道哪些？"><a href="#JVM-的常见参数配置知道哪些？" class="headerlink" title="JVM 的常见参数配置知道哪些？"></a>JVM 的常见参数配置知道哪些？</h2><p>一些常见的参数配置：</p><p><strong>堆配置：</strong></p><ul><li>-Xms:初始堆大小</li><li>-Xms：最大堆大小</li><li>-XX:NewSize&#x3D;n:设置年轻代大小</li><li>-XX:NewRatio&#x3D;n:设置年轻代和年老代的比值。如：为 3 表示年轻代和年老代比值为 1：3，年轻代占整个年轻代年老代和的 1&#x2F;4</li><li>-XX:SurvivorRatio&#x3D;n:年轻代中 Eden 区与两个 Survivor 区的比值。注意 Survivor 区有两个。如 3 表示 Eden： 3 Survivor：2，一个 Survivor 区占整个年轻代的 1&#x2F;5</li><li>-XX:MaxPermSize&#x3D;n:设置持久代大小</li></ul><p><strong>收集器设置：</strong></p><ul><li>-XX:+UseSerialGC:设置串行收集器</li><li>-XX:+UseParallelGC:设置并行收集器</li><li>-XX:+UseParalledlOldGC:设置并行年老代收集器</li><li>-XX:+UseConcMarkSweepGC:设置并发收集器</li></ul><p><strong>并行收集器设置</strong></p><ul><li>-XX:ParallelGCThreads&#x3D;n:设置并行收集器收集时使用的 CPU 数。并行收集线程数</li><li>-XX:MaxGCPauseMillis&#x3D;n:设置并行收集最大的暂停时间（如果到这个时间了，垃圾回收器依然没有回收完，也会停止回收）</li><li>-XX:GCTimeRatio&#x3D;n:设置垃圾回收时间占程序运行时间的百分比。公式为：1&#x2F;(1+n)</li><li>-XX:+CMSIncrementalMode:设置为增量模式。适用于单 CPU 情况</li><li>-XX:ParallelGCThreads&#x3D;n:设置并发收集器年轻代手机方式为并行收集时，使用的 CPU 数。并行收集线程数</li></ul><p><strong>打印 GC 回收的过程日志信息</strong></p><ul><li>-XX:+PrintGC</li><li>-XX:+PrintGCDetails</li><li>-XX:+PrintGCTimeStamps</li><li>-Xloggc:filename</li></ul><h2 id="有做过-JVM-调优吗？"><a href="#有做过-JVM-调优吗？" class="headerlink" title="有做过 JVM 调优吗？"></a>有做过 JVM 调优吗？</h2><p>JVM 调优是一件很严肃的事情，不是拍脑门就开始调优的，需要有严密的分析和监控机制，大概的一个 JVM 调优流程图：</p><p><img src="https://s2.loli.net/2023/03/27/h2ntMVNgqpX4bx9.png" alt="JVM调优大致流程图"></p><center>JVM调优大致流程图</center><p>实际上，JVM 调优是不得已而为之，有那功夫，好好把烂代码重构一下不比瞎调 JVM 强。</p><p>但是，面试官非要问怎么办？可以从处理问题的角度来回答（对应图中事后），这是一个中规中矩的案例：电商公司的运营后台系统，偶发性的引发 OOM 异常，堆内存溢出。</p><p>1）因为是偶发性的，所以第一次简单的认为就是堆内存不足导致，单方面的加大了堆内存从 4G 调整到 8G -Xms8g。</p><p>2）但是问题依然没有解决，只能从堆内存信息下手，通过开启了-XX:+HeapDumpOnOutOfMemoryError 参数 获得堆内存的 dump 文件。</p><p>3）用 JProfiler 对 堆 dump 文件进行分析，通过 JProfiler 查看到占用内存最大的对象是 String 对象，本来想跟踪着 String 对象找到其引用的地方，但 dump 文件太大，跟踪进去的时候总是卡死，而 String 对象占用比较多也比较正常，最开始也没有认定就是这里的问题，于是就从线程信息里面找突破点。</p><p>4）通过线程进行分析，先找到了几个正在运行的业务线程，然后逐一跟进业务线程看了下代码，有个方法引起了我的注意，<code>导出订单信息</code>。</p><p>5）因为订单信息导出这个方法可能会有几万的数据量，首先要从数据库里面查询出来订单信息，然后把订单信息生成 excel，这个过程会产生大量的 String 对象。</p><p>6）为了验证自己的猜想，于是准备登录后台去测试下，结果在测试的过程中发现导出订单的按钮前端居然没有做点击后按钮置灰交互事件，后端也没有做防止重复提交，因为导出订单数据本来就非常慢，使用的人员可能发现点击后很久后页面都没反应，然后就一直点，结果就大量的请求进入到后台，堆内存产生了大量的订单对象和 EXCEL 对象，而且方法执行非常慢，导致这一段时间内这些对象都无法被回收，所以最终导致内存溢出。</p><p>7）知道了问题就容易解决了，最终没有调整任何 JVM 参数，只是做了两个处理：</p><ul><li>在前端的导出订单按钮上加上了置灰状态，等后端响应之后按钮才可以进行点击</li><li>后端代码加分布式锁，做防重处理</li></ul><p>这样双管齐下，保证导出的请求不会一直打到服务端，问题解决！</p><h2 id="线上服务-CPU-占用过高怎么排查？"><a href="#线上服务-CPU-占用过高怎么排查？" class="headerlink" title="线上服务 CPU 占用过高怎么排查？"></a>线上服务 CPU 占用过高怎么排查？</h2><p>问题分析：CPU 高一定是某个程序长期占用了 CPU 资源。</p><p><img src="https://s2.loli.net/2023/03/27/Qj7k85OaJScAPr2.png" alt="CPU飙高"></p><center>CPU飙高</center><p>1）所以先需要找出那个进程占用 CPU 高。</p><ul><li>top 列出系统各个进程的资源占用情况。</li></ul><p>2）然后根据找到对应进行里哪个线程占用 CPU 高。</p><ul><li>top -Hp 进程 ID 列出对应进程里面的线程占用资源情况</li></ul><p>3）找到对应线程 ID 后，再打印出对应线程的堆栈信息</p><ul><li>printf “%x\n” PID 把线程 ID 转换为 16 进制。</li><li>jstack PID 打印出进程的所有线程信息，从打印出来的线程信息中找到上一步转换为 16 进制的线程 ID 对应的线程信息。</li></ul><p>4）最后根据线程的堆栈信息定位到具体业务方法,从代码逻辑中找到问题所在。</p><p>查看是否有线程长时间的 watting 或 blocked，如果线程长期处于 watting 状态下， 关注 watting on xxxxxx，说明线程在等待这把锁，然后根据锁的地址找到持有锁的线程。</p><h2 id="内存飙高问题怎么排查？"><a href="#内存飙高问题怎么排查？" class="headerlink" title="内存飙高问题怎么排查？"></a>内存飙高问题怎么排查？</h2><p>分析： 内存飚高如果是发生在 java 进程上，一般是因为创建了大量对象所导致，持续飚高说明垃圾回收跟不上对象创建的速度，或者内存泄露导致对象无法回收。</p><p>1）先观察垃圾回收的情况</p><ul><li>jstat -gc PID 1000 查看 GC 次数，时间等信息，每隔一秒打印一次。</li><li>jmap -histo PID | head -20 查看堆内存占用空间最大的前 20 个对象类型,可初步查看是哪个对象占用了内存。</li></ul><p>如果每次 GC 次数频繁，而且每次回收的内存空间也正常，那说明是因为对象创建速度快导致内存一直占用很高；如果每次回收的内存非常少，那么很可能是因为内存泄露导致内存一直无法被回收。</p><p>2）导出堆内存文件快照</p><ul><li>jmap -dump:live,format&#x3D;b,file&#x3D;&#x2F;home&#x2F;myheapdump.hprof PID dump 堆内存信息到文件。</li></ul><p>3）使用 visualVM 对 dump 文件进行离线分析，找到占用内存高的对象，再找到创建该对象的业务代码位置，从代码和业务场景中定位具体问题。</p><h2 id="频繁-minor-gc-怎么办？"><a href="#频繁-minor-gc-怎么办？" class="headerlink" title="频繁 minor gc 怎么办？"></a>频繁 minor gc 怎么办？</h2><p>优化 Minor GC 频繁问题：通常情况下，由于新生代空间较小，Eden 区很快被填满，就会导致频繁 Minor GC，因此可以通过增大新生代空间<code>-Xmn</code>来降低 Minor GC 的频率。</p><h2 id="频繁-Full-GC-怎么办？"><a href="#频繁-Full-GC-怎么办？" class="headerlink" title="频繁 Full GC 怎么办？"></a>频繁 Full GC 怎么办？</h2><p>Full GC 的排查思路大概如下：</p><p>1）清楚从程序角度，有哪些原因导致 FGC？</p><ul><li><strong>大对象</strong>：系统一次性加载了过多数据到内存中（比如 SQL 查询未做分页），导致大对象进入了老年代。</li><li><strong>内存泄漏</strong>：频繁创建了大量对象，但是无法被回收（比如 IO 对象使用完后未调用 close 方法释放资源），先引发 FGC，最后导致 OOM.</li><li>程序频繁生成一些<strong>长生命周期的对象</strong>，当这些对象的存活年龄超过分代年龄时便会进入老年代，最后引发 FGC. （即本文中的案例）</li><li><strong>程序 BUG</strong></li><li>代码中<strong>显式调用了 gc</strong>方法，包括自己的代码甚至框架中的代码。</li><li>JVM 参数设置问题：包括总内存大小、新生代和老年代的大小、Eden 区和 S 区的大小、元空间大小、垃圾回收算法等等。</li></ul><p>2）清楚排查问题时能使用哪些工具</p><ul><li>公司的监控系统：大部分公司都会有，可全方位监控 JVM 的各项指标。</li><li>JDK 的自带工具，包括 jmap、jstat 等常用命令：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看堆内存各区域的使用率以及GC情况</span></span><br><span class="line">jstat -gcutil -h20 pid 1000</span><br><span class="line"><span class="comment"># 查看堆内存中的存活对象，并按空间排序</span></span><br><span class="line">jmap -histo pid | <span class="built_in">head</span> -n20</span><br><span class="line"><span class="comment"># dump堆内存文件</span></span><br><span class="line">jmap -dump:format=b,file=heap pid</span><br></pre></td></tr></table></figure><ul><li>可视化的堆内存分析工具：JVisualVM、MAT 等</li></ul><p>3）排查指南</p><ul><li>查看监控，以了解出现问题的时间点以及当前 FGC 的频率（可对比正常情况看频率是否正常）</li><li>了解该时间点之前有没有程序上线、基础组件升级等情况。</li><li>了解 JVM 的参数设置，包括：堆空间各个区域的大小设置，新生代和老年代分别采用了哪些垃圾收集器，然后分析 JVM 参数设置是否合理。</li><li>再对步骤 1 中列出的可能原因做排除法，其中元空间被打满、内存泄漏、代码显式调用 gc 方法比较容易排查。</li><li>针对大对象或者长生命周期对象导致的 FGC，可通过 jmap -histo 命令并结合 dump 堆内存文件作进一步分析，需要先定位到可疑对象。</li><li>通过可疑对象定位到具体代码再次分析，这时候要结合 GC 原理和 JVM 参数设置，弄清楚可疑对象是否满足了进入到老年代的条件才能下结论。</li></ul><h2 id="有没有处理过内存泄漏问题？是如何定位的？"><a href="#有没有处理过内存泄漏问题？是如何定位的？" class="headerlink" title=".有没有处理过内存泄漏问题？是如何定位的？"></a>.有没有处理过内存泄漏问题？是如何定位的？</h2><p>内存泄漏是内在病源，外在病症表现可能有：</p><ul><li>应用程序长时间连续运行时性能严重下降</li><li>CPU 使用率飙升，甚至到 100%</li><li>频繁 Full GC，各种报警，例如接口超时报警等</li><li>应用程序抛出 <code>OutOfMemoryError</code> 错误</li><li>应用程序偶尔会耗尽连接对象</li></ul><p>严重<strong>内存泄漏</strong>往往伴随频繁的 <strong>Full GC</strong>，所以分析排查内存泄漏问题首先还得从查看 Full GC 入手。主要有以下操作步骤：</p><p>1）使用 <code>jps</code> 查看运行的 Java 进程 ID</p><p>2）使用<code>top -p [pid]</code> 查看进程使用 CPU 和 MEM 的情况</p><p>3）使用 <code>top -Hp [pid]</code> 查看进程下的所有线程占 CPU 和 MEM 的情况</p><p>4）将线程 ID 转换为 16 进制：<code>printf &quot;%x\n&quot; [pid]</code>，输出的值就是线程栈信息中的 <strong>nid</strong>。</p><p>例如：<code>printf &quot;%x\n&quot; 29471</code>，换行输出 <strong>731f</strong>。</p><p>5）抓取线程栈：<code>jstack 29452 &gt; 29452.txt</code>，可以多抓几次做个对比。</p><p>在线程栈信息中找到对应线程号的 16 进制值，如下是 <strong>731f</strong> 线程的信息。线程栈分析可使用 Visualvm 插件 <strong>TDA</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Service Thread&quot;</span> #<span class="number">7</span> daemon prio=<span class="number">9</span> os_prio=<span class="number">0</span> tid=<span class="number">0x00007fbe2c164000</span> nid=<span class="number">0x731f</span> runnable [<span class="number">0x0000000000000000</span>]</span><br><span class="line">  java.lang.Thread.State: RUNNABLE</span><br></pre></td></tr></table></figure><p>6）使用<code>jstat -gcutil [pid] 5000 10</code> 每隔 5 秒输出 GC 信息，输出 10 次，查看 <strong>YGC</strong> 和 <strong>Full GC</strong> 次数。通常会出现 YGC 不增加或增加缓慢，而 Full GC 增加很快。</p><p>或使用 <code>jstat -gccause [pid] 5000</code> ，同样是输出 GC 摘要信息。</p><p>或使用 <code>jmap -heap [pid]</code> 查看堆的摘要信息，关注老年代内存使用是否达到阀值，若达到阀值就会执行 Full GC。</p><p>7）如果发现 <code>Full GC</code> 次数太多，就很大概率存在内存泄漏了</p><p>8）使用 <code>jmap -histo:live [pid]</code> 输出每个类的对象数量，内存大小(字节单位)及全限定类名。</p><p>9）生成 <code>dump</code> 文件，借助工具分析哪 个对象非常多，基本就能定位到问题在那了</p><p>使用 jmap 生成 dump 文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># jmap -dump:live,format=b,file=<span class="number">29471.</span>dump <span class="number">29471</span></span><br><span class="line">Dumping heap to /root/dump ...</span><br><span class="line">Heap dump file created</span><br></pre></td></tr></table></figure><p>10）dump 文件分析</p><p>可以使用 <strong>jhat</strong> 命令分析：<code>jhat -port 8000 29471.dump</code>，浏览器访问 jhat 服务，端口是 8000。</p><p>通常使用图形化工具分析，如 JDK 自带的 <strong>jvisualvm</strong>，从菜单 &gt; 文件 &gt; 装入 dump 文件。</p><p>或使用第三方式具分析的，如 <strong>JProfiler</strong> 也是个图形化工具，<strong>GCViewer</strong> 工具。Eclipse 或以使用 MAT 工具查看。或使用在线分析平台 <strong>GCEasy</strong>。</p><p><strong>注意</strong>：如果 dump 文件较大的话，分析会占比较大的内存。</p><p>11）在 dump 文析结果中查找存在大量的对象，再查对其的引用。</p><p>基本上就可以定位到代码层的逻辑了。</p><h2 id="有没有处理过内存溢出问题？"><a href="#有没有处理过内存溢出问题？" class="headerlink" title="有没有处理过内存溢出问题？"></a>有没有处理过内存溢出问题？</h2><p>内存泄漏和内存溢出二者关系非常密切，内存溢出可能会有很多原因导致，内存泄漏最可能的罪魁祸首之一。</p><p>排查过程和排查内存泄漏过程类似。</p><h1 id="虚拟机执行"><a href="#虚拟机执行" class="headerlink" title="虚拟机执行"></a>虚拟机执行</h1><h2 id="能说一下类的生命周期吗？"><a href="#能说一下类的生命周期吗？" class="headerlink" title="能说一下类的生命周期吗？"></a>能说一下类的生命周期吗？</h2><p>一个类从被加载到虚拟机内存中开始，到从内存中卸载，整个生命周期需要经过七个阶段：加载 （Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化 （Initialization）、使用（Using）和卸载（Unloading），其中验证、准备、解析三个部分统称为连接（Linking）。</p><p><img src="https://s2.loli.net/2023/03/27/UwvshDIuMXbK4rE.png" alt="类的生命周期"></p><center>类的生命周期</center><h2 id="类加载的过程知道吗？"><a href="#类加载的过程知道吗？" class="headerlink" title="类加载的过程知道吗？"></a>类加载的过程知道吗？</h2><p>加载是 JVM 加载的起点，具体什么时候开始加载，《Java 虚拟机规范》中并没有进行强制约束，可以交给虚拟机的具体实现来自由把握。</p><p>在加载过程，JVM 要做三件事情：</p><p><img src="https://s2.loli.net/2023/03/27/pAI7Rd5F6M3o2ix.png" alt="加载"></p><center>加载</center><ul><li>1）通过一个类的全限定名来获取定义此类的二进制字节流。</li><li>2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>3）在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。</li></ul><p>加载阶段结束后，Java 虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区之中了，方法区中的数据存储格式完全由虚拟机实现自行定义，《Java 虚拟机规范》未规定此区域的具体数据结构。</p><p>类型数据妥善安置在方法区之后，会在 Java 堆内存中实例化一个 java.lang.Class 类的对象， 这个对象将作为程序访问方法区中的类型数据的外部接口。</p><h2 id="类加载器有哪些？"><a href="#类加载器有哪些？" class="headerlink" title="类加载器有哪些？"></a>类加载器有哪些？</h2><p>主要有四种类加载器:</p><ul><li><strong>启动类加载器</strong>(Bootstrap ClassLoader)用来加载 java 核心类库，无法被 java 程序直接引用。</li><li><strong>扩展类加载器</strong>(extensions class loader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。</li><li><strong>系统类加载器</strong>（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。</li><li><strong>用户自定义类加载器</strong> (user class loader)，用户通过继承 java.lang.ClassLoader 类的方式自行实现的类加载器。</li></ul><h2 id="什么是双亲委派机制？"><a href="#什么是双亲委派机制？" class="headerlink" title="什么是双亲委派机制？"></a>什么是双亲委派机制？</h2><p><img src="https://s2.loli.net/2023/03/27/5m3lAB91XuQaOSj.png" alt="双亲委派模型"></p><center>双亲委派模型</center><p>双亲委派模型的工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去完成加载。</p><h2 id="为什么要用双亲委派机制？"><a href="#为什么要用双亲委派机制？" class="headerlink" title="为什么要用双亲委派机制？"></a>为什么要用双亲委派机制？</h2><p>答案是为了保证应用程序的稳定有序。</p><p>例如类 java.lang.Object，它存放在 rt.jar 之中，通过双亲委派机制，保证最终都是委派给处于模型最顶端的启动类加载器进行加载，保证 Object 的一致。反之，都由各个类加载器自行去加载的话，如果用户自己也编写了一个名为 java.lang.Object 的类，并放在程序的 ClassPath 中，那系统中就会出现多个不同的 Object 类。</p><h2 id="如何破坏双亲委派机制？"><a href="#如何破坏双亲委派机制？" class="headerlink" title="如何破坏双亲委派机制？"></a>如何破坏双亲委派机制？</h2><p>如果不想打破双亲委派模型，就重写 ClassLoader 类中的 fifindClass()方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。而如果想打破双亲委派模型则需要重写 loadClass()方法。</p><h2 id="历史上有哪几次双亲委派机制的破坏？"><a href="#历史上有哪几次双亲委派机制的破坏？" class="headerlink" title="历史上有哪几次双亲委派机制的破坏？"></a>历史上有哪几次双亲委派机制的破坏？</h2><p>双亲委派机制在历史上主要有三次破坏：</p><p><img src="https://s2.loli.net/2023/03/27/WGcqF6UVaQw2EKJ.png" alt="双亲委派模型的三次破坏"></p><center>双亲委派模型的三次破坏</center><blockquote><p><strong>第一次破坏</strong></p></blockquote><p>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即 JDK 1.2 面世以前的“远古”时代。</p><p>由于双亲委派模型在 JDK 1.2 之后才被引入，但是类加载器的概念和抽象类 java.lang.ClassLoader 则在 Java 的第一个版本中就已经存在，为了向下兼容旧代码，所以无法以技术手段避免 loadClass()被子类覆盖的可能性，只能在 JDK 1.2 之后的 java.lang.ClassLoader 中添加一个新的 protected 方法 findClass()，并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在 loadClass()中编写代码。</p><blockquote><p><strong>第二次破坏</strong></p></blockquote><p>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的，如果有基础类型又要调用回用户的代码，那该怎么办呢？</p><p>例如我们比较熟悉的 JDBC:</p><p>各个厂商各有不同的 JDBC 的实现，Java 在核心包<code>\lib</code>里定义了对应的 SPI，那么这个就毫无疑问由<code>启动类加载器</code>加载器加载。</p><p>但是各个厂商的实现，是没办法放在核心包里的，只能放在<code>classpath</code>里，只能被<code>应用类加载器</code>加载。那么，问题来了，启动类加载器它就加载不到厂商提供的 SPI 服务代码。</p><p>为了解决这个问题，引入了一个不太优雅的设计：线程上下文类加载器 （Thread Context ClassLoader）。这个类加载器可以通过 java.lang.Thread 类的 setContext-ClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</p><p>JNDI 服务使用这个线程上下文类加载器去加载所需的 SPI 服务代码，这是一种父类加载器去请求子类加载器完成类加载的行为。</p><blockquote><p><strong>第三次破坏</strong></p></blockquote><p>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的，例如代码热替换（Hot Swap）、模块热部署（Hot Deployment）等。</p><p>OSGi 实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块（OSGi 中称为 Bundle）都有一个自己的类加载器，当需要更换一个 Bundle 时，就把 Bundle 连同类加载器一起换掉以实现代码的热替换。在 OSGi 环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构。</p><h2 id="你觉得应该怎么实现一个热部署功能？"><a href="#你觉得应该怎么实现一个热部署功能？" class="headerlink" title="你觉得应该怎么实现一个热部署功能？"></a>你觉得应该怎么实现一个热部署功能？</h2><p>我们已经知道了 Java 类的加载过程。一个 Java 类文件到虚拟机里的对象，要经过如下过程:首先通过 Java 编译器，将 Java 文件编译成 class 字节码，类加载器读取 class 字节码，再将类转化为实例，对实例 newInstance 就可以生成对象。</p><p>类加载器 ClassLoader 功能，也就是将 class 字节码转换到类的实例。在 Java 应用中，所有的实例都是由类加载器，加载而来。</p><p>一般在系统中，类的加载都是由系统自带的类加载器完成，而且对于同一个全限定名的 java 类（如 com.csiar.soc.HelloWorld），只能被加载一次，而且无法被卸载。</p><p>这个时候问题就来了，如果我们希望将 java 类卸载，并且替换更新版本的 java 类，该怎么做呢？</p><p>既然在类加载器中，Java 类只能被加载一次，并且无法卸载。那么我们是不是可以直接把 Java 类加载器干掉呢？答案是可以的，我们可以自定义类加载器，并重写 ClassLoader 的 findClass 方法。</p><p>想要实现热部署可以分以下三个步骤：</p><ul><li>1）销毁原来的自定义 ClassLoader</li><li>2）更新 class 类文件</li><li>3）创建新的 ClassLoader 去加载更新后的 class 类文件。</li></ul><p>到此，一个热部署的功能就这样实现了。</p><h2 id="Tomcat-的类加载机制了解吗？"><a href="#Tomcat-的类加载机制了解吗？" class="headerlink" title="Tomcat 的类加载机制了解吗？"></a>Tomcat 的类加载机制了解吗？</h2><p>Tomcat 是主流的 Java Web 服务器之一，为了实现一些特殊的功能需求，自定义了一些类加载器。</p><p>Tomcat 类加载器如下：</p><p><img src="https://s2.loli.net/2023/03/27/ewrCyYb1MAZaSO8.png" alt="Tomcat类加载器"></p><center>Tomcat类加载器</center><p>Tomcat 实际上也是破坏了双亲委派模型的。</p><p>Tomact 是 web 容器，可能需要部署多个应用程序。不同的应用程序可能会依赖同一个第三方类库的不同版本，但是不同版本的类库中某一个类的全路径名可能是一样的。如多个应用都要依赖 hollis.jar，但是 A 应用需要依赖 1.0.0 版本，但是 B 应用需要依赖 1.0.1 版本。这两个版本中都有一个类是 com.hollis.Test.class。如果采用默认的双亲委派类加载机制，那么无法加载多个相同的类。</p><p>所以，Tomcat 破坏了<strong>双亲委派原则</strong>，提供隔离的机制，为每个 web 容器单独提供一个 WebAppClassLoader 加载器。每一个 WebAppClassLoader 负责加载本身的目录下的 class 文件，加载不到时再交 CommonClassLoader 加载，这和双亲委派刚好相反。</p>]]></content>
      
      
      <categories>
          
          <category> 面渣逆袭 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面渣逆袭 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面渣逆袭-Spring</title>
      <link href="/Blog/2023/03/21/interview/%E9%9D%A2%E6%B8%A3%E9%80%86%E8%A2%AD-Spring/"/>
      <url>/Blog/2023/03/21/interview/%E9%9D%A2%E6%B8%A3%E9%80%86%E8%A2%AD-Spring/</url>
      
        <content type="html"><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h2 id="Spring-是什么？特性？有哪些模块？"><a href="#Spring-是什么？特性？有哪些模块？" class="headerlink" title="Spring 是什么？特性？有哪些模块？"></a>Spring 是什么？特性？有哪些模块？</h2><p><img src="https://s2.loli.net/2023/03/27/91SX6wkU4GAMDn2.jpg" alt="Spring Logo"></p><center>Spring Logo</center><p>一句话概括：<strong>Spring 是一个轻量级、非入侵式的控制反转 (IoC) 和面向切面 (AOP) 的框架。</strong></p><p>2003 年，一个音乐家 Rod Johnson 决定发展一个轻量级的 Java 开发框架，<code>Spring</code>作为 Java 战场的龙骑兵渐渐崛起，并淘汰了<code>EJB</code>这个传统的重装骑兵。</p><p><img src="https://s2.loli.net/2023/03/27/HEIzUbf8N54tGJR.png" alt="Spring重要版本"></p><center>Spring重要版本</center><p>到了现在，企业级开发的标配基本就是 <strong>Spring5</strong> + <strong>Spring Boot 2</strong> + <strong>JDK 8</strong></p><blockquote><p>Spring 有哪些特性呢？</p></blockquote><p>Spring 有很多优点：</p><p><img src="https://s2.loli.net/2023/03/27/2h3D7abQkIGzJpV.png" alt="Spring特性"></p><center>Spring特性</center><ol><li><strong>IOC</strong> 和 <strong>DI</strong> 的支持</li></ol><p>Spring 的核心就是一个大的工厂容器，可以维护所有对象的创建和依赖关系，Spring 工厂用于生成 Bean，并且管理 Bean 的生命周期，实现<strong>高内聚低耦合</strong>的设计理念。</p><ol start="2"><li>AOP 编程的支持</li></ol><p>Spring 提供了<strong>面向切面编程</strong>，可以方便的实现对程序进行权限拦截、运行监控等切面功能。</p><ol start="3"><li>声明式事务的支持</li></ol><p>支持通过配置就来完成对事务的管理，而不需要通过硬编码的方式，以前重复的一些事务提交、回滚的 JDBC 代码，都可以不用自己写了。</p><ol start="4"><li>快捷测试的支持</li></ol><p>Spring 对 Junit 提供支持，可以通过<strong>注解</strong>快捷地测试 Spring 程序。</p><ol start="5"><li>快速集成功能</li></ol><p>方便集成各种优秀框架，Spring 不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如：Struts、Hibernate、MyBatis、Quartz 等）的直接支持。</p><ol start="6"><li>复杂 API 模板封装</li></ol><p>Spring 对 JavaEE 开发中非常难用的一些 API（JDBC、JavaMail、远程调用等）都提供了模板化的封装，这些封装 API 的提供使得应用难度大大降低。</p><h2 id="Spring-有哪些模块呢？"><a href="#Spring-有哪些模块呢？" class="headerlink" title="Spring 有哪些模块呢？"></a>Spring 有哪些模块呢？</h2><p>Spring 框架是分模块存在，除了最核心的<code>Spring Core Container</code>是必要模块之外，其他模块都是<code>可选</code>，大约有 20 多个模块。</p><p><img src="https://s2.loli.net/2023/03/27/pYzwyaRqUQKVj73.jpg" alt="Spring模块划分"></p><center>Spring模块划分</center><p>最主要的七大模块：</p><ol><li><strong>Spring Core</strong>：Spring 核心，它是框架最基础的部分，提供 IOC 和依赖注入 DI 特性。</li><li><strong>Spring Context</strong>：Spring 上下文容器，它是 BeanFactory 功能加强的一个子接口。</li><li><strong>Spring Web</strong>：它提供 Web 应用开发的支持。</li><li><strong>Spring MVC</strong>：它针对 Web 应用中 MVC 思想的实现。</li><li><strong>Spring DAO</strong>：提供对 JDBC 抽象层，简化了 JDBC 编码，同时，编码更具有健壮性。</li><li><strong>Spring ORM</strong>：它支持用于流行的 ORM 框架的整合，比如：Spring + Hibernate、Spring + iBatis、Spring + JDO 的整合等。</li><li><strong>Spring AOP</strong>：即面向切面编程，它提供了与 AOP 联盟兼容的编程实现。</li></ol><h2 id="Spring-有哪些常用注解呢？"><a href="#Spring-有哪些常用注解呢？" class="headerlink" title="Spring 有哪些常用注解呢？"></a>Spring 有哪些常用注解呢？</h2><p>Spring 有很多模块，甚至广义的 SpringBoot、SpringCloud 也算是 Spring 的一部分，我们来分模块，按功能来看一下一些常用的注解：</p><p><img src="https://s2.loli.net/2023/03/27/pecKy4xYu6Zkidg.png" alt="Spring常用注解"></p><center>Spring常用注解</center><p><strong>Web</strong>:</p><ul><li>@Controller：组合注解（组合了@Component 注解），应用在 MVC 层（控制层）。</li><li>@RestController：该注解为一个组合注解，相当于@Controller 和@ResponseBody 的组合，注解在类上，意味着，该 Controller 的所有方法都默认加上了@ResponseBody。</li><li>@RequestMapping：用于映射 Web 请求，包括访问路径和参数。如果是 Restful 风格接口，还可以根据请求类型使用不同的注解：<ul><li>@GetMapping</li><li>@PostMapping</li><li>@PutMapping</li><li>@DeleteMapping</li></ul></li><li>@ResponseBody：支持将返回值放在 response 内，而不是一个页面，通常用户返回 json 数据。</li><li>@RequestBody：允许 request 的参数在 request 体中，而不是在直接连接在地址后面。</li><li>@PathVariable：用于接收路径参数，比如 <code>@RequestMapping(“/hello/&#123;name&#125;”)</code>申明的路径，将注解放在参数中前，即可获取该值，通常作为 Restful 的接口实现方法。</li><li>@RestController：该注解为一个组合注解，相当于@Controller 和@ResponseBody 的组合，注解在类上，意味着，该 Controller 的所有方法都默认加上了@ResponseBody。</li></ul><p><strong>容器</strong>:</p><ul><li>@Component：表示一个带注释的类是一个“组件”，成为 Spring 管理的 Bean。当使用基于注解的配置和类路径扫描时，这些类被视为自动检测的候选对象。同时@Component 还是一个元注解。</li><li>@Service：组合注解（组合了@Component 注解），应用在 service 层（业务逻辑层）。</li><li>@Repository：组合注解（组合了@Component 注解），应用在 dao 层（数据访问层）。</li><li>@Autowired：Spring 提供的工具（由 Spring 的依赖注入工具（BeanPostProcessor、BeanFactoryPostProcessor）自动注入）。</li><li>@Qualifier：该注解通常跟 @Autowired 一起使用，当想对注入的过程做更多的控制，@Qualifier 可帮助配置，比如两个以上相同类型的 Bean 时 Spring 无法抉择，用到此注解</li><li>@Configuration：声明当前类是一个配置类（相当于一个 Spring 配置的 xml 文件）</li><li>@Value：可用在字段，构造器参数跟方法参数，指定一个默认值，支持 <code>#&#123;&#125; 跟 \$&#123;&#125;</code> 两个方式。一般将 SpringbBoot 中的 application.properties 配置的属性值赋值给变量。</li><li>@Bean：注解在方法上，声明当前方法的返回值为一个 Bean。返回的 Bean 对应的类中可以定义 init()方法和 destroy()方法，然后在<code>@Bean(initMethod=”init”,destroyMethod=”destroy”)</code>定义，在构造之后执行 init，在销毁之前执行 destroy。</li><li>@Scope:定义我们采用什么模式去创建 Bean（方法上，得有@Bean） 其设置类型包括：Singleton 、Prototype、Request 、 Session、GlobalSession。</li></ul><p><strong>AOP</strong>:</p><ul><li>@Aspect:声明一个切面（类上） 使用@After、@Before、@Around 定义建言（advice），可直接将拦截规则（切点）作为参数。<ul><li><code>@After</code> ：在方法执行之后执行（方法上）。</li><li><code>@Before</code>： 在方法执行之前执行（方法上）。</li><li><code>@Around</code>： 在方法执行之前与之后执行（方法上）。</li><li><code>@PointCut</code>： 声明切点 在 java 配置类中使用@EnableAspectJAutoProxy 注解开启 Spring 对 AspectJ 代理的支持（类上）。</li></ul></li></ul><p><strong>事务：</strong></p><ul><li>@Transactional：在要开启事务的方法上使用@Transactional 注解，即可声明式开启事务。</li></ul><h2 id="Spring-中应用了哪些设计模式呢？"><a href="#Spring-中应用了哪些设计模式呢？" class="headerlink" title="Spring 中应用了哪些设计模式呢？"></a>Spring 中应用了哪些设计模式呢？</h2><p>Spring 框架中广泛使用了不同类型的设计模式，下面我们来看看到底有哪些设计模式?</p><p><img src="https://s2.loli.net/2023/03/27/JUPLz1IVN6wvuaY.png" alt="Spring中用到的设计模式"></p><center>Spring中用到的设计模式</center><ol><li><strong>工厂模式</strong> : Spring 容器本质是一个大工厂，使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。</li><li><strong>代理模式</strong> : Spring AOP 功能功能就是通过代理模式来实现的，分为动态代理和静态代理。</li><li><strong>单例模式</strong> : Spring 中的 Bean 默认都是单例的，这样有利于容器对 Bean 的管理。</li><li><strong>模板模式</strong> : Spring 中 JdbcTemplate、RestTemplate 等以 Template 结尾的对数据库、网络等等进行操作的模板类，就使用到了模板模式。</li><li><strong>观察者模式</strong>: Spring 事件驱动模型就是观察者模式很经典的一个应用。</li><li><strong>适配器模式</strong> :Spring AOP 的增强或通知 (Advice) 使用到了适配器模式、Spring MVC 中也是用到了适配器模式适配 Controller。</li><li><strong>策略模式</strong>：Spring 中有一个 Resource 接口，它的不同实现类，会根据不同的策略去访问资源。</li></ol><h1 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h1><h2 id="说一说什么是-IOC？什么是-DI"><a href="#说一说什么是-IOC？什么是-DI" class="headerlink" title="说一说什么是 IOC？什么是 DI?"></a>说一说什么是 IOC？什么是 DI?</h2><p>Java 是面向对象的编程语言，一个个实例对象相互合作组成了业务逻辑，原来，我们都是在代码里创建对象和对象的依赖。</p><p>所谓的<strong>IOC</strong>（控制反转）：就是由容器来负责控制对象的生命周期和对象间的关系。以前是我们想要什么，就自己创建什么，现在是我们需要什么，容器就给我们送来什么。</p><p><img src="https://s2.loli.net/2023/03/27/Sqv4sOj7V1Wkin5.png" alt="引入IOC之前和引入IOC之后"></p><center>引入IOC之前和引入IOC之后</center><p>也就是说，控制对象生命周期的不再是引用它的对象，而是容器。对具体对象，以前是它控制其它对象，现在所有对象都被容器控制，所以这就叫<strong>控制反转</strong>。</p><p><img src="https://s2.loli.net/2023/03/27/SpyhMCYA3cJ1fFi.png" alt="控制反转示意图"></p><center>控制反转示意图</center><p><strong>DI（依赖注入）</strong>：指的是容器在实例化对象的时候把它依赖的类注入给它。有的说法 IOC 和 DI 是一回事，有的说法是 IOC 是思想，DI 是 IOC 的实现。</p><blockquote><p><strong>为什么要使用 IOC 呢？</strong></p></blockquote><p>最主要的是两个字<strong>解耦</strong>，硬编码会造成对象间的过度耦合，使用 IOC 之后，我们可以不用关心对象间的依赖，专心开发应用就行。</p><h2 id="能简单说一下-Spring-IOC-的实现机制吗？"><a href="#能简单说一下-Spring-IOC-的实现机制吗？" class="headerlink" title="能简单说一下 Spring IOC 的实现机制吗？"></a>能简单说一下 Spring IOC 的实现机制吗？</h2><p>PS:这道题老三在面试中被问到过，问法是“<strong>你有自己实现过简单的 Spring 吗？</strong>”</p><p>Spring 的 IOC 本质就是一个大工厂，我们想想一个工厂是怎么运行的呢？</p><p><img src="https://s2.loli.net/2023/03/27/zV34bpSkqgGQTBc.png" alt="工厂运行"></p><center>工厂运行</center><ul><li><p><strong>生产产品</strong>：一个工厂最核心的功能就是生产产品。在 Spring 里，不用 Bean 自己来实例化，而是交给 Spring，应该怎么实现呢？——答案毫无疑问，<strong>反射</strong>。</p><p>那么这个厂子的生产管理是怎么做的？你应该也知道——<strong>工厂模式</strong>。</p></li><li><p><strong>库存产品</strong>：工厂一般都是有库房的，用来库存产品，毕竟生产的产品不能立马就拉走。Spring 我们都知道是一个容器，这个容器里存的就是对象，不能每次来取对象，都得现场来反射创建对象，得把创建出的对象存起来。</p></li><li><p><strong>订单处理</strong>：还有最重要的一点，工厂根据什么来提供产品呢？订单。这些订单可能五花八门，有线上签签的、有到工厂签的、还有工厂销售上门签的……最后经过处理，指导工厂的出货。</p><p>在 Spring 里，也有这样的订单，它就是我们 bean 的定义和依赖关系，可以是 xml 形式，也可以是我们最熟悉的注解形式。</p></li></ul><p>我们简单地实现一个 mini 版的 Spring IOC：</p><p><img src="https://s2.loli.net/2023/03/27/IH6SURijx4V9cWt.png" alt="mini版本Spring IOC"></p><center>mini版本Spring IOC</center><p><strong>Bean 定义：</strong></p><p>Bean 通过一个配置文件定义，把它解析成一个类型。</p><ul><li><p>beans.properties</p><p>偷懒，这里直接用了最方便解析的 properties，这里直接用一个<code>&lt;key,value&gt;</code>类型的配置来代表 Bean 的定义，其中 key 是 beanName，value 是 class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userDao:cn.fighter3.bean.UserDao</span><br></pre></td></tr></table></figure></li><li><p>BeanDefinition.java</p><p>bean 定义类，配置文件中 bean 定义对应的实体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanDefinition</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String beanName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Class beanClass;</span><br><span class="line">     <span class="comment">//省略getter、setter</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>ResourceLoader.java</p><p>资源加载器，用来完成配置文件中配置的加载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResourceLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, BeanDefinition&gt; <span class="title function_">getResource</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> ResourceLoader.class.getResourceAsStream(<span class="string">&quot;/beans.properties&quot;</span>);</span><br><span class="line">            properties.load(inputStream);</span><br><span class="line">            Iterator&lt;String&gt; it = properties.stringPropertyNames().iterator();</span><br><span class="line">            <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> it.next();</span><br><span class="line">                <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> properties.getProperty(key);</span><br><span class="line">                <span class="type">BeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinition</span>();</span><br><span class="line">                beanDefinition.setBeanName(key);</span><br><span class="line">                <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line">                beanDefinition.setBeanClass(clazz);</span><br><span class="line">                beanDefinitionMap.put(key, beanDefinition);</span><br><span class="line">            &#125;</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanDefinitionMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>BeanRegister.java</p><p>对象注册器，这里用于单例 bean 的缓存，我们大幅简化，默认所有 bean 都是单例的。可以看到所谓单例注册，也很简单，不过是往 HashMap 里存对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanRegister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单例Bean缓存</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; singletonMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取单例Bean</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName bean名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getSingletonBean</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> singletonMap.get(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册单例bean</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerSingletonBean</span><span class="params">(String beanName, Object bean)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (singletonMap.containsKey(beanName)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        singletonMap.put(beanName, bean);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>BeanFactory.java</strong></p></li></ul><p><img src="https://s2.loli.net/2023/03/27/v2MYje3GfWOu4UR.png" alt="BeanFactory"></p><center>BeanFactory</center><ul><li><p>对象工厂，我们最<strong>核心</strong>的一个类，在它初始化的时候，创建了 bean 注册器，完成了资源的加载。</p></li><li><p>获取 bean 的时候，先从单例缓存中取，如果没有取到，就创建并注册一个 bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BeanRegister beanRegister;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BeanFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//创建bean注册器</span></span><br><span class="line">        beanRegister = <span class="keyword">new</span> <span class="title class_">BeanRegister</span>();</span><br><span class="line">        <span class="comment">//加载资源</span></span><br><span class="line">        <span class="built_in">this</span>.beanDefinitionMap = <span class="keyword">new</span> <span class="title class_">ResourceLoader</span>().getResource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取bean</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName bean名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">        <span class="comment">//从bean缓存中取</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> beanRegister.getSingletonBean(beanName);</span><br><span class="line">        <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据bean定义，创建bean</span></span><br><span class="line">        <span class="keyword">return</span> createBean(beanDefinitionMap.get(beanName));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建Bean</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanDefinition bean定义</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object <span class="title function_">createBean</span><span class="params">(BeanDefinition beanDefinition)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> beanDefinition.getBeanClass().newInstance();</span><br><span class="line">            <span class="comment">//缓存bean</span></span><br><span class="line">            beanRegister.registerSingletonBean(beanDefinition.getBeanName(), bean);</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试</p><ul><li><p>UserDao.java</p><p>我们的 Bean 类，很简单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryUserInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A good man.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>单元测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_BeanFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建bean工厂(同时完成了加载资源、创建注册单例bean注册器的操作)</span></span><br><span class="line">        <span class="type">BeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanFactory</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.第一次获取bean（通过反射创建bean，缓存bean）</span></span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao1</span> <span class="operator">=</span> (UserDao) beanFactory.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">        userDao1.queryUserInfo();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.第二次获取bean（从缓存中获取bean）</span></span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao2</span> <span class="operator">=</span> (UserDao) beanFactory.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">        userDao2.queryUserInfo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A good man.</span><br><span class="line">A good man.</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>至此，我们一个乞丐+破船版的 Spring 就完成了，代码也比较完整，有条件的可以跑一下。</p><p>PS:因为时间+篇幅的限制，这个 demo 比较简陋，没有面向接口、没有解耦、边界检查、异常处理……健壮性、扩展性都有很大的不足。</p><h2 id="说说-BeanFactory-和-ApplicantContext"><a href="#说说-BeanFactory-和-ApplicantContext" class="headerlink" title="说说 BeanFactory 和 ApplicantContext?"></a>说说 BeanFactory 和 ApplicantContext?</h2><p>可以这么形容，BeanFactory 是 Spring 的“心脏”，ApplicantContext 是完整的“身躯”。</p><p><img src="https://s2.loli.net/2023/03/27/M4r5JS1lNufAaOE.png" alt="BeanFactory和ApplicantContext的比喻"></p><center>BeanFactory和ApplicantContext的比喻</center><ul><li>BeanFactory（Bean 工厂）是 Spring 框架的基础设施，面向 Spring 本身。</li><li>ApplicantContext（应用上下文）建立在 BeanFactoty 基础上，面向使用 Spring 框架的开发者。</li></ul><h3 id="BeanFactory-接口"><a href="#BeanFactory-接口" class="headerlink" title="BeanFactory 接口"></a>BeanFactory 接口</h3><p>BeanFactory 是类的通用工厂，可以创建并管理各种类的对象。</p><p>Spring 为 BeanFactory 提供了很多种实现，最常用的是 XmlBeanFactory，但在 Spring 3.2 中已被废弃，建议使用 XmlBeanDefinitionReader、DefaultListableBeanFactory。</p><p><img src="https://s2.loli.net/2023/03/27/4G7o2irnOxM185Q.png" alt="Spring5 BeanFactory继承体系"></p><center>Spring5 BeanFactory继承体系</center><p>BeanFactory 接口位于类结构树的顶端，它最主要的方法就是 getBean(String var1)，这个方法从容器中返回特定名称的 Bean。</p><p>BeanFactory 的功能通过其它的接口得到了不断的扩展，比如 AbstractAutowireCapableBeanFactory 定义了将容器中的 Bean 按照某种规则（比如按名字匹配、按类型匹配等）进行自动装配的方法。</p><p>这里看一个 XMLBeanFactory（已过期） 获取 bean 的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldApp</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">BeanFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanFactory</span> (<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;beans.xml&quot;</span>));</span><br><span class="line">      <span class="type">HelloWorld</span> <span class="variable">obj</span> <span class="operator">=</span> (HelloWorld) factory.getBean(<span class="string">&quot;helloWorld&quot;</span>);</span><br><span class="line">      obj.getMessage();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ApplicationContext-接口"><a href="#ApplicationContext-接口" class="headerlink" title="ApplicationContext 接口"></a>ApplicationContext 接口</h3><p>ApplicationContext 由 BeanFactory 派生而来，提供了更多面向实际应用的功能。可以这么说，使用 BeanFactory 就是手动档，使用 ApplicationContext 就是自动档。</p><p><img src="https://s2.loli.net/2023/03/27/d4D9BOcasnTWPAV.png" alt="Spring5 ApplicationContext部分体系类图"></p><center>Spring5 ApplicationContext部分体系类图</center><p>ApplicationContext 继承了 HierachicalBeanFactory 和 ListableBeanFactory 接口，在此基础上，还通过其他的接口扩展了 BeanFactory 的功能，包括：</p><ul><li>Bean instantiation&#x2F;wiring</li><li>Bean 的实例化&#x2F;串联</li><li>自动的 BeanPostProcessor 注册</li><li>自动的 BeanFactoryPostProcessor 注册</li><li>方便的 MessageSource 访问（i18n）</li><li>ApplicationEvent 的发布与 BeanFactory 懒加载的方式不同，它是预加载，所以，每一个 bean 都在 ApplicationContext 启动之后实例化</li></ul><p>这是 ApplicationContext 的使用例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldApp</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      ApplicationContext context=<span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">      <span class="type">HelloWorld</span> <span class="variable">obj</span> <span class="operator">=</span> (HelloWorld) context.getBean(<span class="string">&quot;helloWorld&quot;</span>);</span><br><span class="line">      obj.getMessage();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ApplicationContext 包含 BeanFactory 的所有特性，通常推荐使用前者。</p><h2 id="你知道-Spring-容器启动阶段会干什么吗？"><a href="#你知道-Spring-容器启动阶段会干什么吗？" class="headerlink" title="你知道 Spring 容器启动阶段会干什么吗？"></a>你知道 Spring 容器启动阶段会干什么吗？</h2><p>PS：这道题老三面试被问到过</p><p>Spring 的 IOC 容器工作的过程，其实可以划分为两个阶段：<strong>容器启动阶段</strong>和<strong>Bean 实例化阶段</strong>。</p><p>其中容器启动阶段主要做的工作是加载和解析配置文件，保存到对应的 Bean 定义中。</p><p><img src="https://s2.loli.net/2023/03/27/ea2wK6qmGpiQsXJ.png" alt="容器启动和Bean实例化阶段"></p><center>容器启动和Bean实例化阶段</center><p>容器启动开始，首先会通过某种途径加载 Congiguration MetaData，在大部分情况下，容器需要依赖某些工具类（BeanDefinitionReader）对加载的 Congiguration MetaData 进行解析和分析，并将分析后的信息组为相应的 BeanDefinition。</p><p><img src="https://s2.loli.net/2023/03/27/ufjX1vDhzrVabSQ.png" alt="xml配置信息映射注册过程">xml配置信息映射注册过程</p><p>最后把这些保存了 Bean 定义必要信息的 BeanDefinition，注册到相应的 BeanDefinitionRegistry，这样容器启动就完成了。</p><h2 id="能说一下-Spring-Bean-生命周期吗？"><a href="#能说一下-Spring-Bean-生命周期吗？" class="headerlink" title="能说一下 Spring Bean 生命周期吗？"></a>能说一下 Spring Bean 生命周期吗？</h2><p>可以看看：<a href="https://mp.weixin.qq.com/s/zb6eA3Se0gQoqL8PylCPLw">Spring Bean 生命周期，好像人的一生</a></p><p>在 Spring 中，基本容器 BeanFactory 和扩展容器 ApplicationContext 的实例化时机不太一样，BeanFactory 采用的是延迟初始化的方式，也就是只有在第一次 getBean()的时候，才会实例化 Bean；ApplicationContext 启动之后会实例化所有的 Bean 定义。</p><p>Spring IOC 中 Bean 的生命周期大致分为四个阶段：<strong>实例化</strong>（Instantiation）、<strong>属性赋值</strong>（Populate）、<strong>初始化</strong>（Initialization）、<strong>销毁</strong>（Destruction）。</p><p><img src="https://s2.loli.net/2023/03/27/LCKeMmv5YtXwSn7.png" alt="Bean生命周期四个阶段"></p><center>Bean生命周期四个阶段</center><p>我们再来看一个稍微详细一些的过程：</p><ul><li><strong>实例化</strong>：第 1 步，实例化一个 Bean 对象</li><li><strong>属性赋值</strong>：第 2 步，为 Bean 设置相关属性和依赖</li><li><strong>初始化</strong>：初始化的阶段的步骤比较多，5、6 步是真正的初始化，第 3、4 步为在初始化前执行，第 7 步在初始化后执行，初始化完成之后，Bean 就可以被使用了</li><li><strong>销毁</strong>：第 8~10 步，第 8 步其实也可以算到销毁阶段，但不是真正意义上的销毁，而是先在使用前注册了销毁的相关调用接口，为了后面第 9、10 步真正销毁 Bean 时再执行相应的方法</li></ul><p><img src="https://s2.loli.net/2023/03/27/PJO69dbE7gMGVYo.png" alt="SpringBean生命周期">SpringBean生命周期</p><p>简单总结一下，Bean 生命周期里初始化的过程相对步骤会多一些，比如前置、后置的处理。</p><p>最后通过一个实例来看一下具体的细节： <img src="https://s2.loli.net/2023/03/27/MEe7uCXbrIYz5Fx.png" alt="Bean一生实例"></p><ul><li>定义一个<code>PersonBean</code>类，实现<code>DisposableBean</code>,<code>InitializingBean</code>, <code>BeanFactoryAware</code>, <code>BeanNameAware</code>这 4 个接口，同时还有自定义的<code>init-method</code>和<code>destroy-method</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonBean</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span>, BeanFactoryAware, BeanNameAware, DisposableBean &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 身份证号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer no;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 姓名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PersonBean</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1.调用构造方法：我出生了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getNo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNo</span><span class="params">(Integer no)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        System.out.println(<span class="string">&quot;2.设置属性：我的名字叫&quot;</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanName</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;3.调用BeanNameAware#setBeanName方法:我要上学了，起了个学名&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;4.调用BeanFactoryAware#setBeanFactory方法：选好学校了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;6.InitializingBean#afterPropertiesSet方法：入学登记&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;7.自定义init方法：努力上学ing&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;9.DisposableBean#destroy方法：平淡的一生落幕了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroyMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;10.自定义destroy方法:睡了，别想叫醒我&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bean使用中：工作，只有对社会没有用的人才放假。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定义一个<code>MyBeanPostProcessor</code>实现<code>BeanPostProcessor</code>接口。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;5.BeanPostProcessor.postProcessBeforeInitialization方法：到学校报名啦&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;8.BeanPostProcessor#postProcessAfterInitialization方法：终于毕业，拿到毕业证啦！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>配置文件，指定<code>init-method</code>和<code>destroy-method</code>属性</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean name=<span class="string">&quot;myBeanPostProcessor&quot;</span> class=<span class="string">&quot;cn.fighter3.spring.life.MyBeanPostProcessor&quot;</span> /&gt;</span><br><span class="line">    &lt;bean name=<span class="string">&quot;personBean&quot;</span> class=<span class="string">&quot;cn.fighter3.spring.life.PersonBean&quot;</span></span><br><span class="line">          init-method=<span class="string">&quot;init&quot;</span> destroy-method=<span class="string">&quot;destroyMethod&quot;</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;idNo&quot;</span> value= <span class="string">&quot;80669865&quot;</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;name&quot;</span> value=<span class="string">&quot;张铁钢&quot;</span> /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;spring-config.xml&quot;</span>);</span><br><span class="line">        <span class="type">PersonBean</span> <span class="variable">personBean</span> <span class="operator">=</span> (PersonBean) context.getBean(<span class="string">&quot;personBean&quot;</span>);</span><br><span class="line">        personBean.work();</span><br><span class="line">        ((ClassPathXmlApplicationContext) context).destroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行结果：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>调用构造方法：我出生了！</span><br><span class="line"><span class="number">2.</span>设置属性：我的名字叫张铁钢</span><br><span class="line"><span class="number">3.</span>调用BeanNameAware#setBeanName方法:我要上学了，起了个学名</span><br><span class="line"><span class="number">4.</span>调用BeanFactoryAware#setBeanFactory方法：选好学校了</span><br><span class="line"><span class="number">5.</span>BeanPostProcessor#postProcessBeforeInitialization方法：到学校报名啦</span><br><span class="line"><span class="number">6.</span>InitializingBean#afterPropertiesSet方法：入学登记</span><br><span class="line"><span class="number">7.</span>自定义init方法：努力上学ing</span><br><span class="line"><span class="number">8.</span>BeanPostProcessor#postProcessAfterInitialization方法：终于毕业，拿到毕业证啦！</span><br><span class="line">Bean使用中：工作，只有对社会没有用的人才放假。。</span><br><span class="line"><span class="number">9.</span>DisposableBean#destroy方法：平淡的一生落幕了</span><br><span class="line"><span class="number">10.</span>自定义destroy方法:睡了，别想叫醒我</span><br></pre></td></tr></table></figure><p>关于源码，Bean 创建过程可以查看<code>AbstractBeanFactory#doGetBean</code>方法，在这个方法里可以看到 Bean 的实例化，赋值、初始化的过程，至于最终的销毁，可以看看<code>ConfigurableApplicationContext#close()</code>。</p><p><img src="https://s2.loli.net/2023/03/27/NSVY29lyzkq3phj.png" alt="Bean生命周期源码追踪"></p><center>Bean生命周期源码追踪</center><h2 id="Bean-定义和依赖定义有哪些方式？"><a href="#Bean-定义和依赖定义有哪些方式？" class="headerlink" title="Bean 定义和依赖定义有哪些方式？"></a>Bean 定义和依赖定义有哪些方式？</h2><p>有三种方式：<strong>直接编码方式</strong>、<strong>配置文件方式</strong>、<strong>注解方式</strong>。</p><p><img src="https://s2.loli.net/2023/03/27/Ee1nIlLBOXisqaz.png" alt="Bean依赖配置方式"></p><center>Bean依赖配置方式</center><ul><li>直接编码方式：我们一般接触不到直接编码的方式，但其实其它的方式最终都要通过直接编码来实现。</li><li>配置文件方式：通过 xml、propreties 类型的配置文件，配置相应的依赖关系，Spring 读取配置文件，完成依赖关系的注入。</li><li>注解方式：注解方式应该是我们用的最多的一种方式了，在相应的地方使用注解修饰，Spring 会扫描注解，完成依赖关系的注入。</li></ul><h2 id="有哪些依赖注入的方法？"><a href="#有哪些依赖注入的方法？" class="headerlink" title="有哪些依赖注入的方法？"></a>有哪些依赖注入的方法？</h2><p>Spring 支持<strong>构造方法注入</strong>、<strong>属性注入</strong>、<strong>工厂方法注入</strong>,其中工厂方法注入，又可以分为<strong>静态工厂方法注入</strong>和<strong>非静态工厂方法注入</strong>。</p><p><img src="https://s2.loli.net/2023/03/27/QwBShAFLsyUEVYJ.png" alt="Spring依赖注入方法"></p><center>Spring依赖注入方法</center><ul><li><p><strong>构造方法注入</strong></p><p>通过调用类的构造方法，将接口实现类通过构造方法变量传入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CatDaoImpl</span><span class="params">(String message)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>. message = message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;CatDaoImpl&quot;</span> class=<span class="string">&quot;com.CatDaoImpl&quot;</span>&gt;</span><br><span class="line">  &lt;constructor-arg value=<span class="string">&quot; message &quot;</span>&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>属性注入</strong></p><p>通过 Setter 方法完成调用类所需依赖的注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Id</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123; <span class="keyword">return</span> id; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123; <span class="built_in">this</span>.id = id; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;id&quot;</span> class=<span class="string">&quot;com.id &quot;</span>&gt;</span><br><span class="line">  &lt;property name=<span class="string">&quot;id&quot;</span> value=<span class="string">&quot;123&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>工厂方法注入</strong></p><ul><li><p><strong>静态工厂注入</strong></p><p>静态工厂顾名思义，就是通过调用静态工厂的方法来获取自己需要的对象，为了让 Spring 管理所有对象，我们不能直接通过”工程类.静态方法()”来获取对象，而是依然通过 Spring 注入的形式获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaoFactory</span> &#123; <span class="comment">//静态工厂</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> FactoryDao <span class="title function_">getStaticFactoryDaoImpl</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StaticFacotryDaoImpl</span>();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringAction</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//注入对象</span></span><br><span class="line"> <span class="keyword">private</span> FactoryDao staticFactoryDao;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//注入对象的 set 方法</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStaticFactoryDao</span><span class="params">(FactoryDao staticFactoryDao)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.staticFactoryDao = staticFactoryDao;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//factory-method=&quot;getStaticFactoryDaoImpl&quot;指定调用哪个工厂方法</span></span><br><span class="line"> &lt;bean name=<span class="string">&quot;springAction&quot;</span> class=<span class="string">&quot; SpringAction&quot;</span> &gt;</span><br><span class="line">   &lt;!--使用静态工厂的方法注入对象,对应下面的配置文件--&gt;</span><br><span class="line">   &lt;property name=<span class="string">&quot;staticFactoryDao&quot;</span> ref=<span class="string">&quot;staticFactoryDao&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line"> &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line"> &lt;!--此处获取对象的方式是从工厂类中获取静态方法--&gt;</span><br><span class="line">&lt;bean name=<span class="string">&quot;staticFactoryDao&quot;</span> class=<span class="string">&quot;DaoFactory&quot;</span></span><br><span class="line">  factory-method=<span class="string">&quot;getStaticFactoryDaoImpl&quot;</span>&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>非静态工厂注入</strong></p><p>非静态工厂，也叫实例工厂，意思是工厂方法不是静态的，所以我们需要首先 new 一个工厂实例，再调用普通的实例方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非静态工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaoFactory</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> FactoryDao <span class="title function_">getFactoryDaoImpl</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FactoryDaoImpl</span>();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringAction</span> &#123;</span><br><span class="line">  <span class="comment">//注入对象</span></span><br><span class="line">  <span class="keyword">private</span> FactoryDao factoryDao;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFactoryDao</span><span class="params">(FactoryDao factoryDao)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.factoryDao = factoryDao;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> &lt;bean name=<span class="string">&quot;springAction&quot;</span> class=<span class="string">&quot;SpringAction&quot;</span>&gt;</span><br><span class="line">   &lt;!--使用非静态工厂的方法注入对象,对应下面的配置文件--&gt;</span><br><span class="line">   &lt;property name=<span class="string">&quot;factoryDao&quot;</span> ref=<span class="string">&quot;factoryDao&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line"> &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line"> &lt;!--此处获取对象的方式是从工厂类中获取实例方法--&gt;</span><br><span class="line"> &lt;bean name=<span class="string">&quot;daoFactory&quot;</span> class=<span class="string">&quot;com.DaoFactory&quot;</span>&gt;&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean name=<span class="string">&quot;factoryDao&quot;</span> factory-bean=<span class="string">&quot;daoFactory&quot;</span> factory-method=<span class="string">&quot;getFactoryDaoImpl&quot;</span>&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="Spring-有哪些自动装配的方式？"><a href="#Spring-有哪些自动装配的方式？" class="headerlink" title="Spring 有哪些自动装配的方式？"></a>Spring 有哪些自动装配的方式？</h2><blockquote><p><strong>什么是自动装配？</strong></p></blockquote><p>Spring IOC 容器知道所有 Bean 的配置信息，此外，通过 Java 反射机制还可以获知实现类的结构信息，如构造方法的结构、属性等信息。掌握所有 Bean 的这些信息后，Spring IOC 容器就可以按照某种规则对容器中的 Bean 进行自动装配，而无须通过显式的方式进行依赖配置。</p><p>Spring 提供的这种方式，可以按照某些规则进行 Bean 的自动装配，<code>&lt;bean&gt;</code>元素提供了一个指定自动装配类型的属性：<code>autowire=&quot;&lt;自动装配类型&gt;&quot;</code></p><blockquote><p><strong>Spring 提供了哪几种自动装配类型？</strong></p></blockquote><p>Spring 提供了 4 种自动装配类型：</p><p><img src="https://s2.loli.net/2023/03/27/CVQ6HkXRrEsz5LZ.png" alt="Spring四种自动装配类型"></p><center>Spring四种自动装配类型</center><ul><li><strong>byName</strong>：根据名称进行自动匹配，假设 Boss 又一个名为 car 的属性，如果容器中刚好有一个名为 car 的 bean，Spring 就会自动将其装配给 Boss 的 car 属性</li><li><strong>byType</strong>：根据类型进行自动匹配，假设 Boss 有一个 Car 类型的属性，如果容器中刚好有一个 Car 类型的 Bean，Spring 就会自动将其装配给 Boss 这个属性</li><li><strong>constructor</strong>：与 byType 类似， 只不过它是针对构造函数注入而言的。如果 Boss 有一个构造函数，构造函数包含一个 Car 类型的入参，如果容器中有一个 Car 类型的 Bean，则 Spring 将自动把这个 Bean 作为 Boss 构造函数的入参；如果容器中没有找到和构造函数入参匹配类型的 Bean，则 Spring 将抛出异常。</li><li><strong>autodetect</strong>：根据 Bean 的自省机制决定采用 byType 还是 constructor 进行自动装配，如果 Bean 提供了默认的构造函数，则采用 byType，否则采用 constructor。</li></ul><h2 id="Spring-中的-Bean-的作用域有哪些"><a href="#Spring-中的-Bean-的作用域有哪些" class="headerlink" title="Spring 中的 Bean 的作用域有哪些?"></a>Spring 中的 Bean 的作用域有哪些?</h2><p>Spring 的 Bean 主要支持五种作用域：</p><p><img src="https://s2.loli.net/2023/03/27/ZuD37CWz8lNsOrK.png" alt="Spring Bean支持作用域"></p><center>Spring Bean支持作用域</center><ul><li><strong>singleton</strong> : 在 Spring 容器仅存在一个 Bean 实例，Bean 以单实例的方式存在，是 Bean 默认的作用域。</li><li><strong>prototype</strong> : 每次从容器重调用 Bean 时，都会返回一个新的实例。</li></ul><p>以下三个作用域于只在 Web 应用中适用：</p><ul><li><strong>request</strong> : 每一次 HTTP 请求都会产生一个新的 Bean，该 Bean 仅在当前 HTTP Request 内有效。</li><li><strong>session</strong> : 同一个 HTTP Session 共享一个 Bean，不同的 HTTP Session 使用不同的 Bean。</li><li><strong>globalSession</strong>：同一个全局 Session 共享一个 Bean，只用于基于 Protlet 的 Web 应用，Spring5 中已经不存在了。</li></ul><h2 id="Spring-中的单例-Bean-会存在线程安全问题吗？"><a href="#Spring-中的单例-Bean-会存在线程安全问题吗？" class="headerlink" title="Spring 中的单例 Bean 会存在线程安全问题吗？"></a>Spring 中的单例 Bean 会存在线程安全问题吗？</h2><p>首先结论在这：Spring 中的单例 Bean<strong>不是线程安全的</strong>。</p><p>因为单例 Bean，是全局只有一个 Bean，所有线程共享。如果说单例 Bean，是一个无状态的，也就是线程中的操作不会对 Bean 中的成员变量执行<strong>查询</strong>以外的操作，那么这个单例 Bean 是线程安全的。比如 Spring mvc 的 Controller、Service、Dao 等，这些 Bean 大多是无状态的，只关注于方法本身。</p><p>假如这个 Bean 是有状态的，也就是会对 Bean 中的成员变量进行写操作，那么可能就存在线程安全的问题。</p><p><img src="https://s2.loli.net/2023/03/27/Lm7PSqB2dVcuHrW.png" alt="Spring单例Bean线程安全问题"></p><center>Spring单例Bean线程安全问题</center><blockquote><p><strong>单例 Bean 线程安全问题怎么解决呢？</strong></p></blockquote><p>常见的有这么些解决办法：</p><ol><li><p>将 Bean 定义为多例</p><p>这样每一个线程请求过来都会创建一个新的 Bean，但是这样容器就不好管理 Bean，不能这么办。</p></li><li><p>在 Bean 对象中尽量避免定义可变的成员变量</p><p>削足适履了属于是，也不能这么干。</p></li><li><p>将 Bean 中的成员变量保存在 ThreadLocal 中 ⭐</p><p>我们知道 ThredLoca 能保证多线程下变量的隔离，可以在类中定义一个 ThreadLocal 成员变量，将需要的可变成员变量保存在 ThreadLocal 里，这是推荐的一种方式。</p></li></ol><h2 id="说说循环依赖"><a href="#说说循环依赖" class="headerlink" title="说说循环依赖?"></a>说说循环依赖?</h2><blockquote><p><strong>什么是循环依赖？</strong></p></blockquote><p><img src="https://s2.loli.net/2023/03/27/hCObNqEDaloKXwL.png" alt="Spring循环依赖"></p><center>Spring循环依赖</center><p>Spring 循环依赖：简单说就是自己依赖自己，或者和别的 Bean 相互依赖。</p><p><img src="https://s2.loli.net/2023/03/27/sLr5TUaK8Fzd73b.png" alt="鸡和蛋"></p><center>鸡和蛋</center><p>只有单例的 Bean 才存在循环依赖的情况，<strong>原型</strong>(Prototype)情况下，Spring 会直接抛出异常。原因很简单，AB 循环依赖，A 实例化的时候，发现依赖 B，创建 B 实例，创建 B 的时候发现需要 A，创建 A1 实例……无限套娃，直接把系统干垮。</p><blockquote><p><strong>Spring 可以解决哪些情况的循环依赖？</strong></p></blockquote><p>Spring 不支持基于构造器注入的循环依赖，但是假如 AB 循环依赖，如果一个是构造器注入，一个是 setter 注入呢？</p><p>看看几种情形：</p><p><img src="https://s2.loli.net/2023/03/27/r7XQWBcNuniCEDo.png" alt="循环依赖的几种情形"></p><center>循环依赖的几种情形</center><p>第四种可以而第五种不可以的原因是 Spring 在创建 Bean 时默认会根据自然排序进行创建，所以 A 会先于 B 进行创建。</p><p>所以简单总结，当循环依赖的实例都采用 setter 方法注入的时候，Spring 可以支持，都采用构造器注入的时候，不支持，构造器注入和 setter 注入同时存在的时候，看天。</p><h2 id="那-Spring-怎么解决循环依赖的呢？"><a href="#那-Spring-怎么解决循环依赖的呢？" class="headerlink" title="那 Spring 怎么解决循环依赖的呢？"></a>那 Spring 怎么解决循环依赖的呢？</h2><blockquote><p>PS：其实正确答案是开发人员做好设计，别让 Bean 循环依赖，但是没办法，面试官不想听这个。</p></blockquote><p>我们都知道，单例 Bean 初始化完成，要经历三步：</p><p><img src="https://s2.loli.net/2023/03/27/qNodguwrAeLpOjl.png" alt="Bean初始化步骤"></p><center>Bean初始化步骤</center><p>注入就发生在第二步，<strong>属性赋值</strong>，结合这个过程，Spring 通过<strong>三级缓存</strong>解决了循环依赖：</p><ol><li>一级缓存 : <code>Map&lt;String,Object&gt;</code> <strong>singletonObjects</strong>，单例池，用于保存实例化、属性赋值（注入）、初始化完成的 bean 实例</li><li>二级缓存 : <code>Map&lt;String,Object&gt;</code> <strong>earlySingletonObjects</strong>，早期曝光对象，用于保存实例化完成的 bean 实例</li><li>三级缓存 : <code>Map&lt;String,ObjectFactory&lt;?&gt;&gt;</code> <strong>singletonFactories</strong>，早期曝光对象工厂，用于保存 bean 创建工厂，以便于后面扩展有机会创建代理对象。</li></ol><p><img src="https://s2.loli.net/2023/03/27/OjgBUhkKSqQ4XAF.png" alt="三级缓存"></p><center>三级缓存</center><p>我们来看一下三级缓存解决循环依赖的过程：</p><p>当 A、B 两个类发生循环依赖时： <img src="https://s2.loli.net/2023/03/27/pXi4nKaVFO3bLer.png" alt="循环依赖"></p><p>A 实例的初始化过程：</p><ol><li>创建 A 实例，实例化的时候把 A 对象⼯⼚放⼊三级缓存，表示 A 开始实例化了，虽然我这个对象还不完整，但是先曝光出来让大家知道</li></ol><p><img src="https://s2.loli.net/2023/03/27/6TIb7NQetwdZnY3.png" alt="1"></p><center>1</center><ol start="2"><li>A 注⼊属性时，发现依赖 B，此时 B 还没有被创建出来，所以去实例化 B</li><li>同样，B 注⼊属性时发现依赖 A，它就会从缓存里找 A 对象。依次从⼀级到三级缓存查询 A，从三级缓存通过对象⼯⼚拿到 A，发现 A 虽然不太完善，但是存在，把 A 放⼊⼆级缓存，同时删除三级缓存中的 A，此时，B 已经实例化并且初始化完成，把 B 放入⼀级缓存。</li></ol><p><img src="https://s2.loli.net/2023/03/27/uIwsRNtK5XL3O28.png" alt="2"></p><center>2</center><ol start="4"><li>接着 A 继续属性赋值，顺利从⼀级缓存拿到实例化且初始化完成的 B 对象，A 对象创建也完成，删除⼆级缓存中的 A，同时把 A 放⼊⼀级缓存</li><li>最后，⼀级缓存中保存着实例化、初始化都完成的 A、B 对象</li></ol><p><img src="https://s2.loli.net/2023/03/27/Fc4IWqnBUJN6SRZ.png" alt="5"></p><center>5</center><p>所以，我们就知道为什么 Spring 能解决 setter 注入的循环依赖了，因为实例化和属性赋值是分开的，所以里面有操作的空间。如果都是构造器注入的化，那么都得在实例化这一步完成注入，所以自然是无法支持了。</p><h2 id="为什么要三级缓存？⼆级不⾏吗？"><a href="#为什么要三级缓存？⼆级不⾏吗？" class="headerlink" title="为什么要三级缓存？⼆级不⾏吗？"></a>为什么要三级缓存？⼆级不⾏吗？</h2><p>不行，主要是为了<strong>⽣成代理对象</strong>。如果是没有代理的情况下，使用二级缓存解决循环依赖也是 OK 的。但是如果存在代理，三级没有问题，二级就不行了。</p><p>因为三级缓存中放的是⽣成具体对象的匿名内部类，获取 Object 的时候，它可以⽣成代理对象，也可以返回普通对象。使⽤三级缓存主要是为了保证不管什么时候使⽤的都是⼀个对象。</p><p>假设只有⼆级缓存的情况，往⼆级缓存中放的显示⼀个普通的 Bean 对象，Bean 初始化过程中，通过 BeanPostProcessor 去⽣成代理对象之后，覆盖掉⼆级缓存中的普通 Bean 对象，那么可能就导致取到的 Bean 对象不一致了。</p><p><img src="https://s2.loli.net/2023/03/27/BkZKHnAR6U1JSzW.png" alt="二级缓存不行的原因">二级缓存不行的原因</p><h2 id="Autowired-的实现原理？"><a href="#Autowired-的实现原理？" class="headerlink" title="@Autowired 的实现原理？"></a>@Autowired 的实现原理？</h2><p>实现@Autowired 的关键是：<strong>AutowiredAnnotationBeanPostProcessor</strong></p><p>在 Bean 的初始化阶段，会通过 Bean 后置处理器来进行一些前置和后置的处理。</p><p>实现@Autowired 的功能，也是通过后置处理器来完成的。这个后置处理器就是 AutowiredAnnotationBeanPostProcessor。</p><ul><li>Spring 在创建 bean 的过程中，最终会调用到 doCreateBean()方法，在 doCreateBean()方法中会调用 populateBean()方法，来为 bean 进行属性填充，完成自动装配等工作。</li><li>在 populateBean()方法中一共调用了两次后置处理器，第一次是为了判断是否需要属性填充，如果不需要进行属性填充，那么就会直接进行 return，如果需要进行属性填充，那么方法就会继续向下执行，后面会进行第二次后置处理器的调用，这个时候，就会调用到 AutowiredAnnotationBeanPostProcessor 的 postProcessPropertyValues()方法，在该方法中就会进行@Autowired 注解的解析，然后实现自动装配。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 属性赋值</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> BeanWrapper bw)</span> &#123;</span><br><span class="line">          <span class="comment">//…………</span></span><br><span class="line">          <span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">              <span class="keyword">if</span> (pvs == <span class="literal">null</span>) &#123;</span><br><span class="line">                  pvs = mbd.getPropertyValues();</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              PropertyValues pvsToUse;</span><br><span class="line">              <span class="keyword">for</span>(<span class="type">Iterator</span> <span class="variable">var9</span> <span class="operator">=</span> <span class="built_in">this</span>.getBeanPostProcessorCache().instantiationAware.iterator(); var9.hasNext(); pvs = pvsToUse) &#123;</span><br><span class="line">                  <span class="type">InstantiationAwareBeanPostProcessor</span> <span class="variable">bp</span> <span class="operator">=</span> (InstantiationAwareBeanPostProcessor)var9.next();</span><br><span class="line">                  pvsToUse = bp.postProcessProperties((PropertyValues)pvs, bw.getWrappedInstance(), beanName);</span><br><span class="line">                  <span class="keyword">if</span> (pvsToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">                      <span class="keyword">if</span> (filteredPds == <span class="literal">null</span>) &#123;</span><br><span class="line">                          filteredPds = <span class="built_in">this</span>.filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">                      &#125;</span><br><span class="line">                      <span class="comment">//执行后处理器，填充属性，完成自动装配</span></span><br><span class="line">                      <span class="comment">//调用InstantiationAwareBeanPostProcessor的postProcessPropertyValues()方法</span></span><br><span class="line">                      pvsToUse = bp.postProcessPropertyValues((PropertyValues)pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">                      <span class="keyword">if</span> (pvsToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">                          <span class="keyword">return</span>;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">         <span class="comment">//…………</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>postProcessorPropertyValues()方法的源码如下，在该方法中，会先调用 findAutowiringMetadata()方法解析出 bean 中带有@Autowired 注解、@Inject 和@Value 注解的属性和方法。然后调用 metadata.inject()方法，进行属性填充。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> PropertyValues <span class="title function_">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span> &#123;</span><br><span class="line">    <span class="comment">//@Autowired注解、@Inject和@Value注解的属性和方法</span></span><br><span class="line">    <span class="type">InjectionMetadata</span> <span class="variable">metadata</span> <span class="operator">=</span> <span class="built_in">this</span>.findAutowiringMetadata(beanName, bean.getClass(), pvs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//属性填充</span></span><br><span class="line">        metadata.inject(bean, beanName, pvs);</span><br><span class="line">        <span class="keyword">return</span> pvs;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BeanCreationException var6) &#123;</span><br><span class="line">        <span class="keyword">throw</span> var6;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var7) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(beanName, <span class="string">&quot;Injection of autowired dependencies failed&quot;</span>, var7);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><h2 id="说说什么是-AOP？"><a href="#说说什么是-AOP？" class="headerlink" title="说说什么是 AOP？"></a>说说什么是 AOP？</h2><p>AOP：面向切面编程。简单说，就是把一些业务逻辑中的相同的代码抽取到一个独立的模块中，让业务逻辑更加清爽。</p><p><img src="https://s2.loli.net/2023/03/27/4NVIZLm6bn3dzco.png" alt="横向抽取"></p><center>横向抽取</center><p>具体来说，假如我现在要 crud 写一堆业务，可是如何业务代码前后前后进行打印日志和参数的校验呢？</p><p>我们可以把<code>日志记录</code>和<code>数据校验</code>可重用的功能模块分离出来，然后在程序的执行的合适的地方动态地植入这些代码并执行。这样就简化了代码的书写。</p><p><img src="https://s2.loli.net/2023/03/27/SkgLRVYqMZfGD8m.png" alt="AOP应用示例"></p><center>AOP应用示例</center><p>业务逻辑代码中没有参和通用逻辑的代码，业务模块更简洁，只包含核心业务代码。实现了业务逻辑和通用逻辑的代码分离，便于维护和升级，降低了业务逻辑和通用逻辑的耦合性。</p><p>AOP 可以将遍布应用各处的功能分离出来形成可重用的组件。在编译期间、装载期间或运行期间实现在不修改源代码的情况下给程序动态添加功能。从而实现对业务逻辑的隔离，提高代码的模块化能力。</p><p><img src="https://s2.loli.net/2023/03/27/b9WiwPrvMZkDCdB.png" alt="Java语言执行过程"></p><center>Java语言执行过程</center><p>AOP 的核心其实就是<strong>动态代理</strong>，如果是实现了接口的话就会使用 JDK 动态代理，否则使用 CGLIB 代理，主要应用于处理一些具有横切性质的系统级服务，如日志收集、事务管理、安全检查、缓存、对象池管理等。</p><blockquote><p><strong>AOP 有哪些核心概念？</strong></p></blockquote><ul><li><p><strong>切面</strong>（Aspect）：类是对物体特征的抽象，切面就是对横切关注点的抽象</p></li><li><p><strong>连接点</strong>（Joinpoint）：被拦截到的点，因为 Spring 只支持方法类型的连接点，所以在 Spring 中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器</p></li><li><p><strong>切点</strong>（Pointcut）：对连接点进行拦截的定位</p></li><li><p><strong>通知</strong>（Advice）：所谓通知指的就是指拦截到连接点之后要执行的代码，也可以称作<strong>增强</strong></p></li><li><p><strong>目标对象</strong> （Target）：代理的目标对象</p></li><li><p><strong>织入</strong>（Weabing）：织入是将增强添加到目标类的具体连接点上的过程。</p><ul><li><p>编译期织入：切面在目标类编译时被织入</p></li><li><p>类加载期织入：切面在目标类加载到 JVM 时被织入。需要特殊的类加载器，它可以在目标类被引入应用之前增强该目标类的字节码。</p></li><li><p>运行期织入：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP 容器会为目标对象动态地创建一个代理对象。SpringAOP 就是以这种方式织入切面。</p><p>Spring 采用运行期织入，而 AspectJ 采用编译期织入和类加载器织入。</p></li></ul></li><li><p><strong>引介</strong>（introduction）：引介是一种特殊的增强，可以动态地为类添加一些属性和方法</p></li></ul><blockquote><p><strong>AOP 有哪些环绕方式？</strong></p></blockquote><p>AOP 一般有 <strong>5 种</strong>环绕方式：</p><ul><li>前置通知 (@Before)</li><li>返回通知 (@AfterReturning)</li><li>异常通知 (@AfterThrowing)</li><li>后置通知 (@After)</li><li>环绕通知 (@Around)</li></ul><p><img src="https://s2.loli.net/2023/03/27/y8Rinr7eFt2XkdH.png" alt="环绕方式"></p><center>环绕方式</center><p>多个切面的情况下，可以通过 @Order 指定先后顺序，数字越小，优先级越高。</p><h2 id="说说你平时有用到-AOP-吗？"><a href="#说说你平时有用到-AOP-吗？" class="headerlink" title="说说你平时有用到 AOP 吗？"></a>说说你平时有用到 AOP 吗？</h2><p>PS：这道题老三的同事面试候选人的时候问到了，候选人说了一堆 AOP 原理，同事就势来一句，你能现场写一下 AOP 的应用吗？结果——场面一度很尴尬。虽然我对面试写这种百度就能出来的东西持保留意见，但是还是加上了这一问，毕竟招人最后都是要撸代码的。</p><p>这里给出一个小例子，SpringBoot 项目中，利用 AOP 打印接口的入参和出参日志，以及执行时间，还是比较快捷的。</p><ul><li><p>引入依赖：引入 AOP 依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>自定义注解：自定义一个注解作为切点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> WebLog &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置 AOP 切面：</p><ul><li>@Aspect：标识切面</li><li>@Pointcut：设置切点，这里以自定义注解为切点，定义切点有很多其它种方式，自定义注解是比较常用的一种。</li><li>@Before：在切点之前织入，打印了一些入参信息</li><li>@Around：环绕切点，打印返回参数和接口执行时间</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebLogAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span>         <span class="operator">=</span> LoggerFactory.getLogger(WebLogAspect.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以自定义 <span class="doctag">@WebLog</span> 注解为切点</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(cn.fighter3.spring.aop_demo.WebLog)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">webLog</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在切点之前织入</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before(&quot;webLog()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doBefore</span><span class="params">(JoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 开始打印请求日志</span></span><br><span class="line">        <span class="type">ServletRequestAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> attributes.getRequest();</span><br><span class="line">        <span class="comment">// 打印请求相关参数</span></span><br><span class="line">        logger.info(<span class="string">&quot;========================================== Start ==========================================&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印请求 url</span></span><br><span class="line">        logger.info(<span class="string">&quot;URL            : &#123;&#125;&quot;</span>, request.getRequestURL().toString());</span><br><span class="line">        <span class="comment">// 打印 Http method</span></span><br><span class="line">        logger.info(<span class="string">&quot;HTTP Method    : &#123;&#125;&quot;</span>, request.getMethod());</span><br><span class="line">        <span class="comment">// 打印调用 controller 的全路径以及执行方法</span></span><br><span class="line">        logger.info(<span class="string">&quot;Class Method   : &#123;&#125;.&#123;&#125;&quot;</span>, joinPoint.getSignature().getDeclaringTypeName(), joinPoint.getSignature().getName());</span><br><span class="line">        <span class="comment">// 打印请求的 IP</span></span><br><span class="line">        logger.info(<span class="string">&quot;IP             : &#123;&#125;&quot;</span>, request.getRemoteAddr());</span><br><span class="line">        <span class="comment">// 打印请求入参</span></span><br><span class="line">        logger.info(<span class="string">&quot;Request Args   : &#123;&#125;&quot;</span>,<span class="keyword">new</span> <span class="title class_">ObjectMapper</span>().writeValueAsString(joinPoint.getArgs()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在切点之后织入</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@After(&quot;webLog()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfter</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 结束后打个分隔线，方便查看</span></span><br><span class="line">        logger.info(<span class="string">&quot;=========================================== End ===========================================&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 环绕</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Around(&quot;webLog()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">doAround</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">//开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> proceedingJoinPoint.proceed();</span><br><span class="line">        <span class="comment">// 打印出参</span></span><br><span class="line">        logger.info(<span class="string">&quot;Response Args  : &#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>().writeValueAsString(result));</span><br><span class="line">        <span class="comment">// 执行耗时</span></span><br><span class="line">        logger.info(<span class="string">&quot;Time-Consuming : &#123;&#125; ms&quot;</span>, System.currentTimeMillis() - startTime);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用：只需要在接口上加上自定义注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="meta">@WebLog(desc = &quot;这是一个欢迎接口&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(String name)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello &quot;</span>+name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行结果：可以看到日志打印了入参、出参和执行时间 <img src="https://s2.loli.net/2023/03/27/c7YDtazICgxFGsO.png" alt="执行结果"></p></li></ul><h2 id="说说-JDK-动态代理和-CGLIB-代理-？"><a href="#说说-JDK-动态代理和-CGLIB-代理-？" class="headerlink" title="说说 JDK 动态代理和 CGLIB 代理 ？"></a>说说 JDK 动态代理和 CGLIB 代理 ？</h2><p>Spring 的 AOP 是通过<a href="https://mp.weixin.qq.com/s/aZtfwik0weJN5JzYc-JxYg">动态代理open in new window</a>来实现的，动态代理主要有两种方式 JDK 动态代理和 Cglib 动态代理，这两种动态代理的使用和原理有些不同。</p><p><strong>JDK 动态代理</strong></p><ol><li><strong>Interface</strong>：对于 JDK 动态代理，目标类需要实现一个 Interface。</li><li><strong>InvocationHandler</strong>：InvocationHandler 是一个接口，可以通过实现这个接口，定义横切逻辑，再通过反射机制（invoke）调用目标类的代码，在次过程，可能包装逻辑，对目标方法进行前置后置处理。</li><li><strong>Proxy</strong>：Proxy 利用 InvocationHandler 动态创建一个符合目标类实现的接口的实例，生成目标类的代理对象。</li></ol><p><strong>CgLib 动态代理</strong></p><ol><li>使用 JDK 创建代理有一大限制，它只能为接口创建代理实例，而 CgLib 动态代理就没有这个限制。</li><li>CgLib 动态代理是使用字节码处理框架 <strong>ASM</strong>，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。</li><li><strong>CgLib</strong> 创建的动态代理对象性能比 JDK 创建的动态代理对象的性能高不少，但是 CGLib 在创建代理对象时所花费的时间却比 JDK 多得多，所以对于单例的对象，因为无需频繁创建对象，用 CGLib 合适，反之，使用 JDK 方式要更为合适一些。同时，由于 CGLib 由于是采用动态创建子类的方法，对于 final 方法，无法进行代理。</li></ol><p>我们来看一个常见的小场景，客服中转，解决用户问题：</p><p><img src="https://s2.loli.net/2023/03/27/uyN3ArPcw2BoLXM.png" alt="用户向客服提问题"></p><center>用户向客服提问题</center><p><strong>JDK 动态代理实现：</strong></p><p><img src="https://s2.loli.net/2023/03/27/vOJmi4dqt2EQT95.png" alt="JDK动态代理类图"></p><center>JDK动态代理类图</center><ul><li><p>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ISolver</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>目标类:需要实现对应接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solver</span> <span class="keyword">implements</span> <span class="title class_">ISolver</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;疯狂掉头发解决问题……&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>态代理工厂:ProxyFactory，直接用反射方式生成一个目标对象的代理对象，这里用了一个匿名内部类方式重写 InvocationHandler 方法，实现接口重写也差不多</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 维护一个目标对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxyFactory</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为目标对象生成代理对象</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxyInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;请问有什么可以帮到您？&quot;</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 调用目标对象方法</span></span><br><span class="line">                        <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">&quot;问题已经解决啦！&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>客户端：Client，生成一个代理对象实例，通过代理对象调用目标对象方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//目标对象:程序员</span></span><br><span class="line">        <span class="type">ISolver</span> <span class="variable">developer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solver</span>();</span><br><span class="line">        <span class="comment">//代理：客服小姐姐</span></span><br><span class="line">        <span class="type">ISolver</span> <span class="variable">csProxy</span> <span class="operator">=</span> (ISolver) <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>(developer).getProxyInstance();</span><br><span class="line">        <span class="comment">//目标方法：解决问题</span></span><br><span class="line">        csProxy.solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>Cglib 动态代理实现：</strong></p><p><img src="https://s2.loli.net/2023/03/27/YiatjzFJUpHNE2v.png" alt="Cglib动态代理类图"></p><center>Cglib动态代理类图</center><ul><li><p>目标类：Solver，这里目标类不用再实现接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;疯狂掉头发解决问题……&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>动态代理工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//维护一个目标对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxyFactory</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为目标对象生成代理对象</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxyInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//工具类</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">en</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">//设置父类</span></span><br><span class="line">        en.setSuperclass(target.getClass());</span><br><span class="line">        <span class="comment">//设置回调函数</span></span><br><span class="line">        en.setCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//创建子类对象代理</span></span><br><span class="line">        <span class="keyword">return</span> en.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请问有什么可以帮到您？&quot;</span>);</span><br><span class="line">        <span class="comment">// 执行目标对象的方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;问题已经解决啦！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>客户端：Client</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//目标对象:程序员</span></span><br><span class="line">        <span class="type">Solver</span> <span class="variable">developer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solver</span>();</span><br><span class="line">        <span class="comment">//代理：客服小姐姐</span></span><br><span class="line">        <span class="type">Solver</span> <span class="variable">csProxy</span> <span class="operator">=</span> (Solver) <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>(developer).getProxyInstance();</span><br><span class="line">        <span class="comment">//目标方法：解决问题</span></span><br><span class="line">        csProxy.solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="说说-Spring-AOP-和-AspectJ-AOP-区别"><a href="#说说-Spring-AOP-和-AspectJ-AOP-区别" class="headerlink" title="说说 Spring AOP 和 AspectJ AOP 区别?"></a>说说 Spring AOP 和 AspectJ AOP 区别?</h2><p><strong>Spring AOP</strong></p><p>Spring AOP 属于<code>运行时增强</code>，主要具有如下特点：</p><ol><li>基于动态代理来实现，默认如果使用接口的，用 JDK 提供的动态代理实现，如果是方法则使用 CGLIB 实现</li><li>Spring AOP 需要依赖 IOC 容器来管理，并且只能作用于 Spring 容器，使用纯 Java 代码实现</li><li>在性能上，由于 Spring AOP 是基于<strong>动态代理</strong>来实现的，在容器启动时需要生成代理实例，在方法调用上也会增加栈的深度，使得 Spring AOP 的性能不如 AspectJ 的那么好。</li><li>Spring AOP 致力于解决企业级开发中最普遍的 AOP(方法织入)。</li></ol><p><strong>AspectJ</strong></p><p>AspectJ 是一个易用的功能强大的 AOP 框架，属于<code>编译时增强</code>， 可以单独使用，也可以整合到其它框架中，是 AOP 编程的完全解决方案。AspectJ 需要用到单独的编译器 ajc。</p><p>AspectJ 属于<strong>静态织入</strong>，通过修改代码来实现，在实际运行之前就完成了织入，所以说它生成的类是没有额外运行时开销的，一般有如下几个织入的时机：</p><ol><li>编译期织入（Compile-time weaving）：如类 A 使用 AspectJ 添加了一个属性，类 B 引用了它，这个场景就需要编译期的时候就进行织入，否则没法编译类 B。</li><li>编译后织入（Post-compile weaving）：也就是已经生成了 .class 文件，或已经打成 jar 包了，这种情况我们需要增强处理的话，就要用到编译后织入。</li><li>类加载后织入（Load-time weaving）：指的是在加载类的时候进行织入，要实现这个时期的织入，有几种常见的方法</li></ol><p>整体对比如下：</p><p><img src="https://s2.loli.net/2023/03/27/CcDzq8okJTX5FZy.png" alt="Spring AOP和AspectJ对比"></p><center>Spring AOP和AspectJ对比</center><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>Spring 事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，Spring 是无法提供事务功能的。Spring 只提供统一事务管理接口，具体实现都是由各数据库自己实现，数据库事务的提交和回滚是通过数据库自己的事务机制实现。</p><h2 id="Spring-事务的种类？"><a href="#Spring-事务的种类？" class="headerlink" title="Spring 事务的种类？"></a>Spring 事务的种类？</h2><p>Spring 支持<code>编程式事务</code>管理和<code>声明式</code>事务管理两种方式：</p><p><img src="https://s2.loli.net/2023/03/27/vog8xukp6aAFEKZ.png" alt="Spring事务分类"></p><center>Spring事务分类</center><ol><li>编程式事务</li></ol><p>编程式事务管理使用 TransactionTemplate，需要显式执行事务。</p><ol><li>声明式事务</li><li>声明式事务管理建立在 AOP 之上的。其本质是通过 AOP 功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前启动一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务</li><li>优点是不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明或通过 @Transactional 注解的方式，便可以将事务规则应用到业务逻辑中，减少业务代码的污染。唯一不足地方是，最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。</li></ol><h2 id="Spring-的事务隔离级别？"><a href="#Spring-的事务隔离级别？" class="headerlink" title="Spring 的事务隔离级别？"></a>Spring 的事务隔离级别？</h2><p>Spring 的接口 TransactionDefinition 中定义了表示隔离级别的常量，当然其实主要还是对应数据库的事务隔离级别：</p><ol><li>ISOLATION_DEFAULT：使用后端数据库默认的隔离界别，MySQL 默认可重复读，Oracle 默认读已提交。</li><li>ISOLATION_READ_UNCOMMITTED：读未提交</li><li>ISOLATION_READ_COMMITTED：读已提交</li><li>ISOLATION_REPEATABLE_READ：可重复读</li><li>ISOLATION_SERIALIZABLE：串行化</li></ol><h2 id="Spring-的事务传播机制？"><a href="#Spring-的事务传播机制？" class="headerlink" title="Spring 的事务传播机制？"></a>Spring 的事务传播机制？</h2><p>Spring 事务的传播机制说的是，当多个事务同时存在的时候——一般指的是多个事务方法相互调用时，Spring 如何处理这些事务的行为。</p><p>事务传播机制是使用简单的 ThreadLocal 实现的，所以，如果调用的方法是在新线程调用的，事务传播实际上是会失效的。</p><p><img src="https://s2.loli.net/2023/03/27/i1k4lLgvAxrzhqw.png" alt="7种事务传播机制">7种事务传播机制</p><p>Spring 默认的事务传播行为是 PROPAFATION_REQUIRED，它适合绝大多数情况，如果多个 ServiceX#methodX()都工作在事务环境下（均被 Spring 事务增强），且程序中存在调用链 <code>Service1#method1()-&gt;Service2#method2()-&gt;Service3#method3()</code>，那么这 3 个服务类的三个方法通过 Spring 的事务传播机制都工作在同一个事务中。</p><h2 id="声明式事务实现原理了解吗？"><a href="#声明式事务实现原理了解吗？" class="headerlink" title="声明式事务实现原理了解吗？"></a>声明式事务实现原理了解吗？</h2><p>就是通过 AOP&#x2F;动态代理。</p><ul><li><strong>在 Bean 初始化阶段创建代理对象</strong>：Spring 容器在初始化每个单例 bean 的时候，会遍历容器中的所有 BeanPostProcessor 实现类，并执行其 postProcessAfterInitialization 方法，在执行 AbstractAutoProxyCreator 类的 postProcessAfterInitialization 方法时会遍历容器中所有的切面，查找与当前实例化 bean 匹配的切面，这里会获取事务属性切面，查找@Transactional 注解及其属性值，然后根据得到的切面创建一个代理对象，默认是使用 JDK 动态代理创建代理，如果目标类是接口，则使用 JDK 动态代理，否则使用 Cglib。</li><li><strong>在执行目标方法时进行事务增强操作</strong>：当通过代理对象调用 Bean 方法的时候，会触发对应的 AOP 增强拦截器，声明式事务是一种环绕增强，对应接口为<code>MethodInterceptor</code>，事务增强对该接口的实现为<code>TransactionInterceptor</code>，类图如下：</li></ul><p><img src="https://s2.loli.net/2023/03/27/A3Ox4bHmuNV1yqg.png" alt="图片来源网易技术专栏"></p><center>图片来源网易技术专栏</center><p>事务拦截器<code>TransactionInterceptor</code>在<code>invoke</code>方法中，通过调用父类<code>TransactionAspectSupport</code>的<code>invokeWithinTransaction</code>方法进行事务处理，包括开启事务、事务提交、异常回滚。</p><h2 id="声明式事务在哪些情况下会失效？"><a href="#声明式事务在哪些情况下会失效？" class="headerlink" title="声明式事务在哪些情况下会失效？"></a>声明式事务在哪些情况下会失效？</h2><p><img src="https://s2.loli.net/2023/03/27/NmHrPgJR4fU1pCK.png" alt="声明式事务的几种失效的情况"></p><center>声明式事务的几种失效的情况</center><p><strong>1、@Transactional 应用在非 public 修饰的方法上</strong></p><p>如果 Transactional 注解应用在非 public 修饰的方法上，Transactional 将会失效。</p><p>是因为在 Spring AOP 代理时，TransactionInterceptor （事务拦截器）在目标方法执行前后进行拦截，DynamicAdvisedInterceptor（CglibAopProxy 的内部类）的 intercept 方法 或 JdkDynamicAopProxy 的 invoke 方法会间接调用 AbstractFallbackTransactionAttributeSource 的 <strong>computeTransactionAttribute</strong>方法，获取 Transactional 注解的事务配置信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> TransactionAttribute <span class="title function_">computeTransactionAttribute</span><span class="params">(Method method,</span></span><br><span class="line"><span class="params">    Class&lt;?&gt; targetClass)</span> &#123;</span><br><span class="line">        <span class="comment">// Don&#x27;t allow no-public methods as required.</span></span><br><span class="line">        <span class="keyword">if</span> (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法会检查目标方法的修饰符是否为 public，不是 public 则不会获取@Transactional 的属性配置信息。</p><p><strong>2、@Transactional 注解属性 propagation 设置错误</strong></p><ul><li>TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li><li>TransactionDefinition.PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li><li>TransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。</li></ul><p><strong>3、@Transactional 注解属性 rollbackFor 设置错误</strong></p><p>rollbackFor 可以指定能够触发事务回滚的异常类型。Spring 默认抛出了未检查 unchecked 异常（继承自 RuntimeException 的异常）或者 Error 才回滚事务，其他异常不会触发回滚事务。</p><p><img src="https://s2.loli.net/2023/03/27/HaYkyplth4TNG8o.png" alt="Spring默认支持的异常回滚"></p><center>Spring默认支持的异常回滚</center><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 希望自定义的异常可以进行回滚</span></span><br><span class="line"><span class="meta">@Transactional(propagation= Propagation.REQUIRED,rollbackFor= MyException.class</span></span><br></pre></td></tr></table></figure><p>若在目标方法中抛出的异常是 rollbackFor 指定的异常的子类，事务同样会回滚。</p><p><strong>4、同一个类中方法调用，导致@Transactional 失效</strong></p><p>开发中避免不了会对同一个类里面的方法调用，比如有一个类 Test，它的一个方法 A，A 再调用本类的方法 B（不论方法 B 是用 public 还是 private 修饰），但方法 A 没有声明注解事务，而 B 方法有。则外部调用方法 A 之后，方法 B 的事务是不会起作用的。这也是经常犯错误的一个地方。</p><p>那为啥会出现这种情况？其实这还是由于使用 Spring AOP 代理造成的，因为只有当事务方法被当前类以外的代码调用时，才会由 Spring 生成的代理对象来管理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Transactional</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer <span class="title function_">A</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">CityInfoDict</span> <span class="variable">cityInfoDict</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CityInfoDict</span>();</span><br><span class="line">        cityInfoDict.setCityName(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * B 插入字段为 3的数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">this</span>.insertB();</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * A 插入字段为 2的数据</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">insert</span> <span class="operator">=</span> cityInfoDictMapper.insert(cityInfoDict);</span><br><span class="line">       <span class="keyword">return</span> insert;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Transactional()</span></span><br><span class="line">   <span class="keyword">public</span> Integer <span class="title function_">insertB</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="type">CityInfoDict</span> <span class="variable">cityInfoDict</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CityInfoDict</span>();</span><br><span class="line">       cityInfoDict.setCityName(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">       cityInfoDict.setParentCityId(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> cityInfoDictMapper.insert(cityInfoDict);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这种情况是最常见的一种@Transactional 注解失效场景</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">private</span> Integer <span class="title function_">A</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">insert</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">CityInfoDict</span> <span class="variable">cityInfoDict</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CityInfoDict</span>();</span><br><span class="line">        cityInfoDict.setCityName(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        cityInfoDict.setParentCityId(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * A 插入字段为 2的数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        insert = cityInfoDictMapper.insert(cityInfoDict);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * B 插入字段为 3的数据</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        b.insertB();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 B 方法内部抛了异常，而 A 方法此时 try catch 了 B 方法的异常，那这个事务就不能正常回滚了，会抛出异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.transaction.UnexpectedRollbackException: Transaction rolled back because it has been marked as rollback-only</span><br></pre></td></tr></table></figure><h1 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h1><h2 id="Spring-MVC-的核心组件？"><a href="#Spring-MVC-的核心组件？" class="headerlink" title="Spring MVC 的核心组件？"></a>Spring MVC 的核心组件？</h2><ol><li><strong>DispatcherServlet</strong>：前置控制器，是整个流程控制的<strong>核心</strong>，控制其他组件的执行，进行统一调度，降低组件之间的耦合性，相当于总指挥。</li><li><strong>Handler</strong>：处理器，完成具体的业务逻辑，相当于 Servlet 或 Action。</li><li><strong>HandlerMapping</strong>：DispatcherServlet 接收到请求之后，通过 HandlerMapping 将不同的请求映射到不同的 Handler。</li><li><strong>HandlerInterceptor</strong>：处理器拦截器，是一个接口，如果需要完成一些拦截处理，可以实现该接口。</li><li><strong>HandlerExecutionChain</strong>：处理器执行链，包括两部分内容：Handler 和 HandlerInterceptor（系统会有一个默认的 HandlerInterceptor，如果需要额外设置拦截，可以添加拦截器）。</li><li><strong>HandlerAdapter</strong>：处理器适配器，Handler 执行业务方法之前，需要进行一系列的操作，包括表单数据的验证、数据类型的转换、将表单数据封装到 JavaBean 等，这些操作都是由 HandlerApater 来完成，开发者只需将注意力集中业务逻辑的处理上，DispatcherServlet 通过 HandlerAdapter 执行不同的 Handler。</li><li><strong>ModelAndView</strong>：装载了模型数据和视图信息，作为 Handler 的处理结果，返回给 DispatcherServlet。</li><li><strong>ViewResolver</strong>：视图解析器，DispatcheServlet 通过它将逻辑视图解析为物理视图，最终将渲染结果响应给客户端。</li></ol><h2 id="Spring-MVC-的工作流程？"><a href="#Spring-MVC-的工作流程？" class="headerlink" title="Spring MVC 的工作流程？"></a>Spring MVC 的工作流程？</h2><p><img src="https://s2.loli.net/2023/03/27/vN8auUzW2Eg7fAZ.png" alt="Spring MVC的工作流程"></p><center>Spring MVC的工作流程</center><ol><li>客户端向服务端发送一次请求，这个请求会先到前端控制器 DispatcherServlet(也叫中央控制器)。</li><li>DispatcherServlet 接收到请求后会调用 HandlerMapping 处理器映射器。由此得知，该请求该由哪个 Controller 来处理（并未调用 Controller，只是得知）</li><li>DispatcherServlet 调用 HandlerAdapter 处理器适配器，告诉处理器适配器应该要去执行哪个 Controller</li><li>HandlerAdapter 处理器适配器去执行 Controller 并得到 ModelAndView(数据和视图)，并层层返回给 DispatcherServlet</li><li>DispatcherServlet 将 ModelAndView 交给 ViewReslover 视图解析器解析，然后返回真正的视图。</li><li>DispatcherServlet 将模型数据填充到视图中</li><li>DispatcherServlet 将结果响应给客户端</li></ol><p><strong>Spring MVC</strong> 虽然整体流程复杂，但是实际开发中很简单，大部分的组件不需要开发人员创建和管理，只需要通过配置文件的方式完成配置即可，真正需要开发人员进行处理的只有 <strong>Handler（Controller）</strong> 、<strong>View</strong> 、<strong>Model</strong>。</p><p>当然我们现在大部分的开发都是前后端分离，Restful 风格接口，后端只需要返回 Json 数据就行了。</p><h2 id="SpringMVC-Restful-风格的接口的流程是什么样的呢？"><a href="#SpringMVC-Restful-风格的接口的流程是什么样的呢？" class="headerlink" title="SpringMVC Restful 风格的接口的流程是什么样的呢？"></a>SpringMVC Restful 风格的接口的流程是什么样的呢？</h2><p>PS:这是一道全新的八股，毕竟 ModelAndView 这种方式应该没人用了吧？现在都是前后端分离接口，八股也该更新换代了。</p><p>我们都知道 Restful 接口，响应格式是 json，这就用到了一个常用注解：**@ResponseBody**</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">user</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加入了这个注解后，整体的流程上和使用 ModelAndView 大体上相同，但是细节上有一些不同：</p><p><img src="https://s2.loli.net/2023/03/27/avJlmkpRtFdShAU.png" alt="Spring MVC Restful请求响应示意图"></p><center>Spring MVC Restful请求响应示意图</center><ol><li><p>客户端向服务端发送一次请求，这个请求会先到前端控制器 DispatcherServlet</p></li><li><p>DispatcherServlet 接收到请求后会调用 HandlerMapping 处理器映射器。由此得知，该请求该由哪个 Controller 来处理</p></li><li><p>DispatcherServlet 调用 HandlerAdapter 处理器适配器，告诉处理器适配器应该要去执行哪个 Controller</p></li><li><p>Controller 被封装成了 ServletInvocableHandlerMethod，HandlerAdapter 处理器适配器去执行 invokeAndHandle 方法，完成对 Controller 的请求处理</p></li><li><p>HandlerAdapter 执行完对 Controller 的请求，会调用 HandlerMethodReturnValueHandler 去处理返回值，主要的过程：</p><p>5.1. 调用 RequestResponseBodyMethodProcessor，创建 ServletServerHttpResponse（Spring 对原生 ServerHttpResponse 的封装）实例</p><p>5.2.使用 HttpMessageConverter 的 write 方法，将返回值写入 ServletServerHttpResponse 的 OutputStream 输出流中</p><p>5.3.在写入的过程中，会使用 JsonGenerator（默认使用 Jackson 框架）对返回值进行 Json 序列化</p></li><li><p>执行完请求后，返回的 ModealAndView 为 null，ServletServerHttpResponse 里也已经写入了响应，所以不用关心 View 的处理</p></li></ol><h1 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h1><h2 id="介绍一下-SpringBoot，有哪些优点？"><a href="#介绍一下-SpringBoot，有哪些优点？" class="headerlink" title="介绍一下 SpringBoot，有哪些优点？"></a>介绍一下 SpringBoot，有哪些优点？</h2><p>Spring Boot 基于 Spring 开发，Spirng Boot 本身并不提供 Spring 框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序。它并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。</p><p><img src="https://s2.loli.net/2023/03/27/d4PAMkRSg9Eb2Xy.png" alt="SpringBoot图标">SpringBoot图标</p><p>Spring Boot 以<code>约定大于配置</code>核心思想开展工作，相比 Spring 具有如下优势：</p><ol><li>Spring Boot 可以快速创建独立的 Spring 应用程序。</li><li>Spring Boot 内嵌了如 Tomcat，Jetty 和 Undertow 这样的容器，也就是说可以直接跑起来，用不着再做部署工作了。</li><li>Spring Boot 无需再像 Spring 一样使用一堆繁琐的 xml 文件配置。</li><li>Spring Boot 可以自动配置(核心)Spring。SpringBoot 将原有的 XML 配置改为 Java 配置，将 bean 注入改为使用注解注入的方式(@Autowire)，并将多个 xml、properties 配置浓缩在一个 appliaction.yml 配置文件中。</li><li>Spring Boot 提供了一些现有的功能，如量度工具，表单数据验证以及一些外部配置这样的一些第三方功能。</li><li>Spring Boot 可以快速整合常用依赖（开发库，例如 spring-webmvc、jackson-json、validation-api 和 tomcat 等），提供的 POM 可以简化 Maven 的配置。当我们引入核心依赖时，SpringBoot 会自引入其他依赖。</li></ol><h2 id="SpringBoot-自动配置原理了解吗？"><a href="#SpringBoot-自动配置原理了解吗？" class="headerlink" title="SpringBoot 自动配置原理了解吗？"></a>SpringBoot 自动配置原理了解吗？</h2><p>SpringBoot 开启自动配置的注解是<code>@EnableAutoConfiguration</code> ，启动类上的注解<code>@SpringBootApplication</code>是一个复合注解，包含了@EnableAutoConfiguration：</p><p><img src="https://s2.loli.net/2023/03/27/yidxTrU6kmqZIvJ.png" alt="SpringBoot自动配置原理">SpringBoot自动配置原理</p><ul><li><p><code>EnableAutoConfiguration</code> 只是一个简单的注解，自动装配核心功能的实现实际是通过 <code>AutoConfigurationImportSelector</code>类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigurationPackage</span> <span class="comment">//将main同级的包下的所有组件注册到容器中</span></span><br><span class="line"><span class="meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span> <span class="comment">//加载自动装配类 xxxAutoconfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ENABLED_OVERRIDE_PROPERTY</span> <span class="operator">=</span> <span class="string">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>AutoConfigurationImportSelector</code>实现了<code>ImportSelector</code>接口，这个接口的作用就是收集需要导入的配置类，配合<code>@Import(）</code>就可以将相应的类导入到 Spring 容器中</p></li><li><p>获取注入类的方法是 selectImports()，它实际调用的是<code>getAutoConfigurationEntry</code>，这个方法是获取自动装配类的关键，主要流程可以分为这么几步：</p><ol><li>获取注解的属性，用于后面的排除</li><li><strong>获取所有需要自动装配的配置类的路径</strong>：这一步是最关键的，从 META-INF&#x2F;spring.factories 获取自动配置类的路径</li><li>去掉重复的配置类和需要排除的重复类，把需要自动加载的配置类的路径存储起来</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> AutoConfigurationImportSelector.AutoConfigurationEntry <span class="title function_">getAutoConfigurationEntry</span><span class="params">(AnnotationMetadata annotationMetadata)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//1.获取到注解的属性</span></span><br><span class="line">        <span class="type">AnnotationAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> <span class="built_in">this</span>.getAttributes(annotationMetadata);</span><br><span class="line">        <span class="comment">//2.获取需要自动装配的所有配置类，读取META-INF/spring.factories，获取自动配置类路径</span></span><br><span class="line">        List&lt;String&gt; configurations = <span class="built_in">this</span>.getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">        <span class="comment">//3.1.移除重复的配置</span></span><br><span class="line">        configurations = <span class="built_in">this</span>.removeDuplicates(configurations);</span><br><span class="line">        <span class="comment">//3.2.处理需要排除的配置</span></span><br><span class="line">        Set&lt;String&gt; exclusions = <span class="built_in">this</span>.getExclusions(annotationMetadata, attributes);</span><br><span class="line">        <span class="built_in">this</span>.checkExcludedClasses(configurations, exclusions);</span><br><span class="line">        configurations.removeAll(exclusions);</span><br><span class="line">        configurations = <span class="built_in">this</span>.getConfigurationClassFilter().filter(configurations);</span><br><span class="line">        <span class="built_in">this</span>.fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AutoConfigurationImportSelector</span>.AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何自定义一个-SpringBoot-Srarter"><a href="#如何自定义一个-SpringBoot-Srarter" class="headerlink" title="如何自定义一个 SpringBoot Srarter?"></a>如何自定义一个 SpringBoot Srarter?</h2><p>知道了自动配置原理，创建一个自定义 SpringBoot Starter 也很简单。</p><ol><li>创建一个项目，命名为 demo-spring-boot-starter，引入 SpringBoot 相关依赖</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;</span><br><span class="line">    &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ol><li><p>编写配置文件</p><p>这里定义了属性配置的前缀</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloProperties</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略getter、setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>自动装配</p><p>创建自动配置类 HelloPropertiesConfigure</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(HelloProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloPropertiesConfigure</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置自动类</p><p>在<code>/resources/META-INF/spring.factories</code>文件中添加自动配置类路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">  cn.fighter3.demo.starter.configure.HelloPropertiesConfigure</span><br></pre></td></tr></table></figure></li><li><p>测试</p><ul><li><p>创建一个工程，引入自定义 starter 依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cn.fighter3&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;demo-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">0.0</span><span class="number">.1</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>在配置文件里添加配置</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello.name=张三</span><br></pre></td></tr></table></figure></li><li><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    HelloProperties helloProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;你好，&quot;</span>+helloProperties.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><ul><li>运行结果</li></ul><p><img src="https://s2.loli.net/2023/03/27/lq1iHeZoUXVNFyp.png" alt="运行结果">运行结果</p><p>至此，随手写的一个自定义 SpringBoot-Starter 就完成了，虽然比较简单，但是完成了主要的自动装配的能力。</p><h2 id="Springboot-启动原理？"><a href="#Springboot-启动原理？" class="headerlink" title="Springboot 启动原理？"></a>Springboot 启动原理？</h2><p>SpringApplication 这个类主要做了以下四件事情：</p><ol><li>推断应用的类型是普通的项目还是 Web 项目</li><li>查找并加载所有可用初始化器 ， 设置到 initializers 属性中</li><li>找出所有的应用程序监听器，设置到 listeners 属性中</li><li>推断并设置 main 方法的定义类，找到运行的主类</li></ol><p>SpringBoot 启动大致流程如下 ：</p><p><img src="https://s2.loli.net/2023/03/27/qKPw1diXckAsGxH.png" alt="SpringBoot 启动大致流"></p><center>SpringBoot 启动大致流程</center><h1 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h1><h2 id="对-SpringCloud-了解多少？"><a href="#对-SpringCloud-了解多少？" class="headerlink" title="对 SpringCloud 了解多少？"></a>对 SpringCloud 了解多少？</h2><p>SpringCloud 是 Spring 官方推出的微服务治理框架。</p><p><img src="https://s2.loli.net/2023/03/28/Ye6mc4OtJ839Viy.png" alt="Spring Cloud Netfilx核心组件"><center>Spring Cloud Netfilx核心组件</center></p><blockquote><p><strong>什么是微服务？</strong></p></blockquote><ol><li>2014 年 <strong>Martin Fowler</strong> 提出的一种新的架构形式。微服务架构是一种<strong>架构模式</strong>，提倡将单一应用程序划分成一组小的服务，服务之间相互协调，互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务与服务之间采用轻量级的通信机制(如 HTTP 或 Dubbo)互相协作，每个服务都围绕着具体的业务进行构建，并且能够被独立的部署到生产环境中，另外，应尽量避免统一的，集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具(如 Maven)对其进行构建。</li><li>微服务化的核心就是将传统的一站式应用，根据业务拆分成一个一个的服务，彻底地去耦合，每一个微服务提供单个业务功能的服务，一个服务做一件事情，从技术角度看就是一种小而独立的处理过程，类似进程的概念，能够自行单独启动或销毁，拥有自己独立的数据库。</li></ol><blockquote><p><strong>微服务架构主要要解决哪些问题？</strong></p></blockquote><ol><li>服务很多，客户端怎么访问，如何提供对外网关?</li><li>这么多服务，服务之间如何通信? HTTP 还是 RPC?</li><li>这么多服务，如何治理? 服务的注册和发现。</li><li>服务挂了怎么办？熔断机制。</li></ol><blockquote><p><strong>有哪些主流微服务框架？</strong></p></blockquote><ol><li>Spring Cloud Netflix</li><li>Spring Cloud Alibaba</li><li>SpringBoot + Dubbo + ZooKeeper</li></ol><blockquote><p><strong>SpringCloud 有哪些核心组件？</strong></p></blockquote><p><img src="https://s2.loli.net/2023/03/27/AuIRicy1nLTvY9B.png" alt="SpringCloud"><center>SpringCloud</center></p><p>PS:微服务后面有机会再扩展，其实面试一般都是结合项目去问。</p>]]></content>
      
      
      <categories>
          
          <category> 面渣逆袭 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面渣逆袭 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面渣逆袭-Redis</title>
      <link href="/Blog/2023/03/20/interview/%E9%9D%A2%E6%B8%A3%E9%80%86%E8%A2%AD-Redis/"/>
      <url>/Blog/2023/03/20/interview/%E9%9D%A2%E6%B8%A3%E9%80%86%E8%A2%AD-Redis/</url>
      
        <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="说说什么是Redis"><a href="#说说什么是Redis" class="headerlink" title="说说什么是Redis?"></a>说说什么是Redis?</h2><p><img src="https://s2.loli.net/2023/03/27/eTo1LyOJlAFivBu.png" alt="Redis图标"></p><center>Redis图标</center><p>Redis是一种基于键值对（key-value）的NoSQL数据库。</p><p>比一般键值对数据库强大的地方，Redis中的value支持string（字符串）、hash（哈希）、 list（列表）、set（集合）、zset（有序集合）、Bitmaps（位图）、 HyperLogLog、GEO（地理信息定位）等多种数据结构，因此 Redis可以满足很多的应用场景。</p><p>而且因为Redis会将所有数据都存放在内存中，所以它的读写性能非常出色。</p><p>不仅如此，Redis还可以将内存的数据利用快照和日志的形式保存到硬盘上，这样在发生类似断电或者机器故障的时候，内存中的数据不会“丢失”。</p><p>除了上述功能以外，Redis还提供了键过期、发布订阅、事务、流水线、Lua脚本等附加功能。</p><p>总之，Redis是一款强大的性能利器。</p><h2 id="Redis可以用来干什么？"><a href="#Redis可以用来干什么？" class="headerlink" title="Redis可以用来干什么？"></a>Redis可以用来干什么？</h2><p><img src="https://s2.loli.net/2023/03/27/scCX6Ik4rb1S7d8.png" alt="Redis"></p><center>Redis</center><ol><li><p>缓存</p><p>这是Redis应用最广泛地方，基本所有的Web应用都会使用Redis作为缓存，来降低数据源压力，提高响应速度。 <img src="https://s2.loli.net/2023/03/27/IpK9UQtw1Sso5xX.png" alt="Redis缓存"></p></li><li><p>计数器 Redis天然支持计数功能，而且计数性能非常好，可以用来记录浏览量、点赞量等等。</p></li><li><p>排行榜 Redis提供了列表和有序集合数据结构，合理地使用这些数据结构可以很方便地构建各种排行榜系统。</p></li><li><p>社交网络 赞&#x2F;踩、粉丝、共同好友&#x2F;喜好、推送、下拉刷新。</p></li><li><p>消息队列 Redis提供了发布订阅功能和阻塞队列的功能，可以满足一般消息队列功能。</p></li><li><p>分布式锁 分布式环境下，利用Redis实现分布式锁，也是Redis常见的应用。</p></li></ol><p>Redis的应用一般会结合项目去问，以一个电商项目的用户服务为例：</p><ul><li>Token存储：用户登录成功之后，使用Redis存储Token</li><li>登录失败次数计数：使用Redis计数，登录失败超过一定次数，锁定账号</li><li>地址缓存：对省市区数据的缓存</li><li>分布式锁：分布式环境下登录、注册等操作加分布式锁</li><li>……</li></ul><h2 id="Redis-有哪些数据结构？"><a href="#Redis-有哪些数据结构？" class="headerlink" title="Redis 有哪些数据结构？"></a>Redis 有哪些数据结构？</h2><p><img src="https://s2.loli.net/2023/03/27/UorMhAg3viqpjkK.png" alt="Redis基本数据结构"></p><center>Redis有五种基本数据结构</center><p><strong>string</strong></p><p>字符串最基础的数据结构。字符串类型的值实际可以是字符串（简单的字符串、复杂的字符串（例如JSON、XML））、数字 （整数、浮点数），甚至是二进制（图片、音频、视频），但是值最大不能超过512MB。</p><p>字符串主要有以下几个典型使用场景：</p><ul><li>缓存功能</li><li>计数</li><li>共享Session</li><li>限速</li></ul><p><strong>hash</strong></p><p>哈希类型是指键值本身又是一个键值对结构。</p><p>哈希主要有以下典型应用场景：</p><ul><li>缓存用户信息</li><li>缓存对象</li></ul><p><strong>list</strong></p><p>列表（list）类型是用来存储多个有序的字符串。列表是一种比较灵活的数据结构，它可以充当栈和队列的角色</p><p>列表主要有以下几种使用场景：</p><ul><li>消息队列</li><li>文章列表</li></ul><p><strong>set</strong></p><p>集合（set）类型也是用来保存多个的字符串元素，但和列表类型不一 样的是，集合中不允许有重复元素，并且集合中的元素是无序的。</p><p>集合主要有如下使用场景：</p><ul><li>标签（tag）</li><li>共同关注</li></ul><p><strong>sorted set</strong></p><p>有序集合中的元素可以排序。但是它和列表使用索引下标作为排序依据不同的是，它给每个元素设置一个权重（score）作为排序的依据。</p><p>有序集合主要应用场景：</p><ul><li>用户点赞统计</li><li>用户排序</li></ul><h2 id="Redis为什么快呢？"><a href="#Redis为什么快呢？" class="headerlink" title="Redis为什么快呢？"></a>Redis为什么快呢？</h2><p>Redis的速度⾮常的快，单机的Redis就可以⽀撑每秒十几万的并发，相对于MySQL来说，性能是MySQL的⼏⼗倍。速度快的原因主要有⼏点：</p><ol><li><strong>完全基于内存操作</strong></li><li>使⽤单线程，避免了线程切换和竞态产生的消耗</li><li>基于⾮阻塞的IO多路复⽤机制</li><li>C语⾔实现，优化过的数据结构，基于⼏种基础的数据结构，redis做了⼤量的优化，性能极⾼ <img src="https://s2.loli.net/2023/03/27/y8wGd5upHY2iBtW.png" alt="Redis使用IO多路复用和自身事件模型"></li></ol><h2 id="能说一下I-x2F-O多路复用吗？"><a href="#能说一下I-x2F-O多路复用吗？" class="headerlink" title="能说一下I&#x2F;O多路复用吗？"></a>能说一下I&#x2F;O多路复用吗？</h2><p>引用知乎上一个高赞的回答来解释什么是I&#x2F;O多路复用。假设你是一个老师，让30个学生解答一道题目，然后检查学生做的是否正确，你有下面几个选择：</p><ul><li>第一种选择：按顺序逐个检查，先检查A，然后是B，之后是C、D。。。这中间如果有一个学生卡住，全班都会被耽误。这种模式就好比，你用循环挨个处理socket，根本不具有并发能力。</li><li>第二种选择：你创建30个分身，每个分身检查一个学生的答案是否正确。 这种类似于为每一个用户创建一个进程或者- 线程处理连接。</li><li>第三种选择，你站在讲台上等，谁解答完谁举手。这时C、D举手，表示他们解答问题完毕，你下去依次检查C、D的答案，然后继续回到讲台上等。此时E、A又举手，然后去处理E和A。</li></ul><p>第一种就是阻塞IO模型，第三种就是I&#x2F;O复用模型。</p><p><img src="https://s2.loli.net/2023/03/27/AwWoSUHFftqexlh.png" alt="多路复用模型"></p><center>多路复用模型</center><p>Linux系统有三种方式实现IO多路复用：select、poll和epoll。</p><p>例如epoll方式是将用户socket对应的fd注册进epoll，然后epoll帮你监听哪些socket上有消息到达，这样就避免了大量的无用操作。此时的socket应该采用非阻塞模式。</p><p>这样，整个过程只在进行select、poll、epoll这些调用的时候才会阻塞，收发客户消息是不会阻塞的，整个进程或者线程就被充分利用起来，这就是事件驱动，所谓的reactor模式。</p><h2 id="Redis为什么早期选择单线程？"><a href="#Redis为什么早期选择单线程？" class="headerlink" title="Redis为什么早期选择单线程？"></a>Redis为什么早期选择单线程？</h2><p>官方解释：<a href="https://redis.io/topics/faq">https://redis.io/topics/faqopen in new window</a></p><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-344b8461-98d4-495b-a697-70275b0abad6.png" alt="官方单线程解释"><br>官方FAQ表示，因为Redis是基于内存的操作，CPU成为Redis的瓶颈的情况很少见，Redis的瓶颈最有可能是内存的大小或者网络限制。</p><p>如果想要最大程度利用CPU，可以在一台机器上启动多个Redis实例。</p><p>PS：网上有这样的回答，吐槽官方的解释有些敷衍，其实就是历史原因，开发者嫌多线程麻烦，后来这个CPU的利用问题就被抛给了使用者。</p><p>同时FAQ里还提到了， Redis 4.0 之后开始变成多线程，除了主线程外，它也有后台线程在处理一些较为缓慢的操作，例如清理脏数据、无用连接的释放、大 Key 的删除等等。</p><h2 id="Redis6-0使用多线程是怎么回事"><a href="#Redis6-0使用多线程是怎么回事" class="headerlink" title="Redis6.0使用多线程是怎么回事?"></a>Redis6.0使用多线程是怎么回事?</h2><p>Redis不是说用单线程的吗？怎么6.0成了多线程的？</p><p>Redis6.0的多线程是用多线程来处理数据的<strong>读写和协议解析</strong>，但是Redis<strong>执行命令</strong>还是单线程的。</p><p><img src="https://s2.loli.net/2023/03/27/DyTfGgj2LWSbZrv.png" alt="Redis6.0多线程"> 这样做的⽬的是因为Redis的性能瓶颈在于⽹络IO⽽⾮CPU，使⽤多线程能提升IO读写的效率，从⽽整体提⾼Redis的性能。</p><h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><h2 id="Redis持久化⽅式有哪些？有什么区别？"><a href="#Redis持久化⽅式有哪些？有什么区别？" class="headerlink" title="Redis持久化⽅式有哪些？有什么区别？"></a>Redis持久化⽅式有哪些？有什么区别？</h2><p>Redis持久化⽅案分为RDB和AOF两种。 <img src="https://s2.loli.net/2023/03/27/gZArwPVXEITbo3j.png" alt="Redis持久化两种方式"></p><p><strong>RDB</strong></p><p>RDB持久化是把当前进程数据生成<strong>快照</strong>保存到硬盘的过程，触发RDB持久化过程分为手动触发和自动触发。</p><p>RDB⽂件是⼀个压缩的⼆进制⽂件，通过它可以还原某个时刻数据库的状态。由于RDB⽂件是保存在硬盘上的，所以即使Redis崩溃或者退出，只要RDB⽂件存在，就可以⽤它来恢复还原数据库的状态。</p><p>手动触发分别对应save和bgsave命令: <img src="https://s2.loli.net/2023/03/27/BGh9rH3o82KNJdM.png" alt="save和bgsave"></p><ul><li>save命令：阻塞当前Redis服务器，直到RDB过程完成为止，对于内存比较大的实例会造成长时间阻塞，线上环境不建议使用。</li><li>bgsave命令：Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。</li></ul><p>以下场景会自动触发RDB持久化：</p><ul><li>使用save相关配置，如“save m n”。表示m秒内数据集存在n次修改时，自动触发bgsave。</li><li>如果从节点执行全量复制操作，主节点自动执行bgsave生成RDB文件并发送给从节点</li><li>执行debug reload命令重新加载Redis时，也会自动触发save操作</li><li>默认情况下执行shutdown命令时，如果没有开启AOF持久化功能则自动执行bgsave。</li></ul><p><strong>AOF</strong></p><p>AOF（append only file）持久化：以独立日志的方式记录每次写命令， 重启时再重新执行AOF文件中的命令达到恢复数据的目的。AOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的主流方式。</p><p>AOF的工作流程操作：命令写入 （append）、文件同步（sync）、文件重写（rewrite）、重启加载 （load） <img src="https://s2.loli.net/2023/03/27/fEGNypds3egLbJi.png" alt="AOF工作流程">流程如下：</p><p>1）所有的写入命令会追加到aof_buf（缓冲区）中。</p><p>2）AOF缓冲区根据对应的策略向硬盘做同步操作。</p><p>3）随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩 的目的。</p><p>4）当Redis服务器重启时，可以加载AOF文件进行数据恢复。</p><h2 id="RDB-和-AOF-各自有什么优缺点？"><a href="#RDB-和-AOF-各自有什么优缺点？" class="headerlink" title="RDB 和 AOF 各自有什么优缺点？"></a>RDB 和 AOF 各自有什么优缺点？</h2><p><strong>RDB | 优点</strong></p><ol><li>只有一个紧凑的二进制文件 <code>dump.rdb</code>，非常适合备份、全量复制的场景。</li><li><strong>容灾性好</strong>，可以把RDB文件拷贝道远程机器或者文件系统张，用于容灾恢复。</li><li><strong>恢复速度快</strong>，RDB恢复数据的速度远远快于AOF的方式</li></ol><p><strong>RDB | 缺点</strong></p><ol><li><strong>实时性低</strong>，RDB 是间隔一段时间进行持久化，没法做到实时持久化&#x2F;秒级持久化。如果在这一间隔事件发生故障，数据会丢失。</li><li><strong>存在兼容问题</strong>，Redis演进过程存在多个格式的RDB版本，存在老版本Redis无法兼容新版本RDB的问题。</li></ol><p><strong>AOF | 优点</strong></p><ol><li><strong>实时性好</strong>，aof 持久化可以配置 <code>appendfsync</code> 属性，有 <code>always</code>，每进行一次命令操作就记录到 aof 文件中一次。</li><li>通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。</li></ol><p><strong>AOF | 缺点</strong></p><ol><li>AOF 文件比 RDB <strong>文件大</strong>，且 <strong>恢复速度慢</strong>。</li><li><strong>数据集大</strong> 的时候，比 RDB <strong>启动效率低</strong>。</li></ol><h2 id="RDB和AOF如何选择？"><a href="#RDB和AOF如何选择？" class="headerlink" title="RDB和AOF如何选择？"></a>RDB和AOF如何选择？</h2><ul><li>一般来说， 如果想达到足以媲美数据库的 <strong>数据安全性</strong>，应该 <strong>同时使用两种持久化功能</strong>。在这种情况下，当 Redis 重启的时候会优先载入 AOF 文件来恢复原始的数据，因为在通常情况下 AOF 文件保存的数据集要比 RDB 文件保存的数据集要完整。</li><li>如果 <strong>可以接受数分钟以内的数据丢失</strong>，那么可以 <strong>只使用 RDB 持久化</strong>。</li><li>有很多用户都只使用 AOF 持久化，但并不推荐这种方式，因为定时生成 RDB 快照（snapshot）非常便于进行数据备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快，除此之外，使用 RDB 还可以避免 AOF 程序的 bug。</li><li>如果只需要数据在服务器运行的时候存在，也可以不使用任何持久化方式。</li></ul><h2 id="Redis的数据恢复？"><a href="#Redis的数据恢复？" class="headerlink" title="Redis的数据恢复？"></a>Redis的数据恢复？</h2><p>当Redis发生了故障，可以从RDB或者AOF中恢复数据。</p><p>恢复的过程也很简单，把RDB或者AOF文件拷贝到Redis的数据目录下，如果使用AOF恢复，配置文件开启AOF，然后启动redis-server即可。 <img src="https://s2.loli.net/2023/03/27/GzQv9OYEAjrXLIS.png" alt="Redis启动加载数据"></p><p><strong>Redis</strong> 启动时加载数据的流程：</p><ol><li>AOF持久化开启且存在AOF文件时，优先加载AOF文件。</li><li>AOF关闭或者AOF文件不存在时，加载RDB文件。</li><li>加载AOF&#x2F;RDB文件成功后，Redis启动成功。</li><li>AOF&#x2F;RDB文件存在错误时，Redis启动失败并打印错误信息。</li></ol><h2 id="Redis-4-0-的混合持久化了解吗？"><a href="#Redis-4-0-的混合持久化了解吗？" class="headerlink" title="Redis 4.0 的混合持久化了解吗？"></a>Redis 4.0 的混合持久化了解吗？</h2><p>重启 Redis 时，我们很少使用 <code>RDB</code> 来恢复内存状态，因为会丢失大量数据。我们通常使用 AOF 日志重放，但是重放 AOF 日志性能相对 <code>RDB</code> 来说要慢很多，这样在 Redis 实例很大的情况下，启动需要花费很长的时间。</p><p><strong>Redis 4.0</strong> 为了解决这个问题，带来了一个新的持久化选项——<strong>混合持久化</strong>。将 <code>rdb</code> 文件的内容和增量的 AOF 日志文件存在一起。这里的 AOF 日志不再是全量的日志，而是 <strong>自持久化开始到持久化结束</strong> 的这段时间发生的增量 AOF 日志，通常这部分 AOF 日志很小： <img src="https://s2.loli.net/2023/03/27/y5dOZHvLn3j6rMk.png" alt="混合持久化"></p><p>于是在 Redis 重启的时候，可以先加载 <code>rdb</code> 的内容，然后再重放增量 AOF 日志就可以完全替代之前的 AOF 全量文件重放，重启效率因此大幅得到提升。</p><h1 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h1><p>Redis保证高可用主要有三种方式：主从、哨兵、集群。</p><h2 id="主从复制了解吗？"><a href="#主从复制了解吗？" class="headerlink" title="主从复制了解吗？"></a>主从复制了解吗？</h2><p><img src="https://s2.loli.net/2023/03/27/bZQhzcJuAKFlaIm.png" alt="Redis主从复制简图"></p><center>Redis主从复制简图</center><p><strong>主从复制</strong>，是指将一台 Redis 服务器的数据，复制到其他的 Redis 服务器。前者称为 **主节点(master)**，后者称为 **从节点(slave)**。且数据的复制是 <strong>单向</strong> 的，只能由主节点到从节点。Redis 主从复制支持 <strong>主从同步</strong> 和 <strong>从从同步</strong> 两种，后者是 Redis 后续版本新增的功能，以减轻主节点的同步负担。</p><blockquote><p>主从复制主要的作用?</p></blockquote><ul><li><strong>数据冗余：</strong> 主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li><li><strong>故障恢复：</strong> 当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复 *(实际上是一种服务的冗余)*。</li><li><strong>负载均衡：</strong> 在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务 <em>（即写 Redis 数据时应用连接主节点，读 Redis 数据时应用连接从节点）</em>，分担服务器负载。尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高 Redis 服务器的并发量。</li><li><strong>高可用基石：</strong> 除了上述作用以外，主从复制还是哨兵和集群能够实施的 <strong>基础</strong>，因此说主从复制是 Redis 高可用的基础。</li></ul><h2 id="Redis主从有几种常见的拓扑结构？"><a href="#Redis主从有几种常见的拓扑结构？" class="headerlink" title="Redis主从有几种常见的拓扑结构？"></a>Redis主从有几种常见的拓扑结构？</h2><p>Redis的复制拓扑结构可以支持单层或多层复制关系，根据拓扑复杂性可以分为以下三种：一主一从、一主多从、树状主从结构。</p><p>1.一主一从结构</p><p>一主一从结构是最简单的复制拓扑结构，用于主节点出现宕机时从节点提供故障转移支持。 <img src="https://s2.loli.net/2023/03/27/G7nQRiVk1oZ4XzD.png" alt="一主一从结构"> 2.一主多从结构</p><p>一主多从结构（又称为星形拓扑结构）使得应用端可以利用多个从节点实现读写分离（见图6-5）。对于读占比较大的场景，可以把读命令发送到从节点来分担主节点压力。 <img src="https://s2.loli.net/2023/03/27/ZBXuT4hP1qbJNY5.png" alt="一主多从结构"> 3.树状主从结构</p><p>树状主从结构（又称为树状拓扑结构）使得从节点不但可以复制主节点数据，同时可以作为其他从节点的主节点继续向下层复制。通过引入复制中间层，可以有效降低主节点负载和需要传送给从节点的数据量。 <img src="https://s2.loli.net/2023/03/27/I9sHjzBfAQgiWVL.png" alt="树状主从结构"></p><h2 id="Redis的主从复制原理了解吗？"><a href="#Redis的主从复制原理了解吗？" class="headerlink" title="Redis的主从复制原理了解吗？"></a>Redis的主从复制原理了解吗？</h2><p>Redis主从复制的工作流程大概可以分为如下几步： <img src="https://s2.loli.net/2023/03/27/XYQt3DGRCUgvrFu.png" alt="Redis主从复制工作流程"></p><ol><li>保存主节点（master）信息 这一步只是保存主节点信息，保存主节点的ip和port。</li><li>主从建立连接 从节点（slave）发现新的主节点后，会尝试和主节点建立网络连接。</li><li>发送ping命令 连接建立成功后从节点发送ping请求进行首次通信，主要是检测主从之间网络套接字是否可用、主节点当前是否可接受处理命令。</li><li>权限验证 如果主节点要求密码验证，从节点必须正确的密码才能通过验证。</li><li>同步数据集 主从复制连接正常通信后，主节点会把持有的数据全部发送给从节点。</li><li>命令持续复制 接下来主节点会持续地把写命令发送给从节点，保证主从数据一致性。</li></ol><h2 id="说说主从数据同步的方式？"><a href="#说说主从数据同步的方式？" class="headerlink" title="说说主从数据同步的方式？"></a>说说主从数据同步的方式？</h2><p>Redis在2.8及以上版本使用psync命令完成主从数据同步，同步过程分为：全量复制和部分复制。</p><p><img src="https://s2.loli.net/2023/03/27/RWMI52tbuVh4mBn.png" alt="主从数据同步方式">主从数据同步方式</p><p><strong>全量复制</strong> 一般用于初次复制场景，Redis早期支持的复制功能只有全量复制，它会把主节点全部数据一次性发送给从节点，当数据量较大时，会对主从节点和网络造成很大的开销。</p><p>全量复制的完整运行流程如下： <img src="https://s2.loli.net/2023/03/27/98tbPSYKXMcH3DQ.png" alt="全量复制"></p><ol><li>发送psync命令进行数据同步，由于是第一次进行复制，从节点没有复制偏移量和主节点的运行ID，所以发送psync-1。</li><li>主节点根据psync-1解析出当前为全量复制，回复+FULLRESYNC响应。</li><li>从节点接收主节点的响应数据保存运行ID和偏移量offset</li><li>主节点执行bgsave保存RDB文件到本地</li><li>主节点发送RDB文件给从节点，从节点把接收的RDB文件保存在本地并直接作为从节点的数据文件</li><li>对于从节点开始接收RDB快照到接收完成期间，主节点仍然响应读写命令，因此主节点会把这期间写命令数据保存在复制客户端缓冲区内，当从节点加载完RDB文件后，主节点再把缓冲区内的数据发送给从节点，保证主从之间数据一致性。</li><li>从节点接收完主节点传送来的全部数据后会清空自身旧数据</li><li>从节点清空数据后开始加载RDB文件</li><li>从节点成功加载完RDB后，如果当前节点开启了AOF持久化功能， 它会立刻做bgrewriteaof操作，为了保证全量复制后AOF持久化文件立刻可用。</li></ol><p><strong>部分复制</strong> 部分复制主要是Redis针对全量复制的过高开销做出的一种优化措施， 使用psync{runId}{offset}命令实现。当从节点（slave）正在复制主节点 （master）时，如果出现网络闪断或者命令丢失等异常情况时，从节点会向 主节点要求补发丢失的命令数据，如果主节点的复制积压缓冲区内存在这部分数据则直接发送给从节点，这样就可以保持主从节点复制的一致性。 <img src="https://s2.loli.net/2023/03/27/etPOjyfd68GAKvz.png" alt="部分复制"></p><ol><li>当主从节点之间网络出现中断时，如果超过repl-timeout时间，主节点会认为从节点故障并中断复制连接</li><li>主从连接中断期间主节点依然响应命令，但因复制连接中断命令无法发送给从节点，不过主节点内部存在的复制积压缓冲区，依然可以保存最近一段时间的写命令数据，默认最大缓存1MB。</li><li>当主从节点网络恢复后，从节点会再次连上主节点</li><li>当主从连接恢复后，由于从节点之前保存了自身已复制的偏移量和主节点的运行ID。因此会把它们当作psync参数发送给主节点，要求进行部分复制操作。</li><li>主节点接到psync命令后首先核对参数runId是否与自身一致，如果一 致，说明之前复制的是当前主节点；之后根据参数offset在自身复制积压缓冲区查找，如果偏移量之后的数据存在缓冲区中，则对从节点发送+CONTINUE响应，表示可以进行部分复制。</li><li>主节点根据偏移量把复制积压缓冲区里的数据发送给从节点，保证主从复制进入正常状态。</li></ol><h2 id="主从复制存在哪些问题呢？"><a href="#主从复制存在哪些问题呢？" class="headerlink" title="主从复制存在哪些问题呢？"></a>主从复制存在哪些问题呢？</h2><p>主从复制虽好，但也存在一些问题：</p><ul><li>一旦主节点出现故障，需要手动将一个从节点晋升为主节点，同时需要修改应用方的主节点地址，还需要命令其他从节点去复制新的主节点，整个过程都需要人工干预。</li><li>主节点的写能力受到单机的限制。</li><li>主节点的存储能力受到单机的限制。</li></ul><p>第一个问题是Redis的高可用问题，第二、三个问题属于Redis的分布式问题。</p><h2 id="Redis-Sentinel（哨兵）了解吗？"><a href="#Redis-Sentinel（哨兵）了解吗？" class="headerlink" title="Redis Sentinel（哨兵）了解吗？"></a>Redis Sentinel（哨兵）了解吗？</h2><p>主从复制存在一个问题，没法完成自动故障转移。所以我们需要一个方案来完成自动故障转移，它就是Redis Sentinel（哨兵）。</p><p><img src="https://s2.loli.net/2023/03/27/EdhsJ4az6myIlxg.png" alt="Redis Sentinel"></p><center>Redis Sentinel</center><p>Redis Sentinel ，它由两部分组成，哨兵节点和数据节点：</p><ul><li><strong>哨兵节点：</strong> 哨兵系统由一个或多个哨兵节点组成，哨兵节点是特殊的 Redis 节点，不存储数据，对数据节点进行监控。</li><li><strong>数据节点：</strong> 主节点和从节点都是数据节点；</li></ul><p>在复制的基础上，哨兵实现了 <strong>自动化的故障恢复</strong> 功能，下面是官方对于哨兵功能的描述：</p><ul><li><strong>监控（Monitoring）：</strong> 哨兵会不断地检查主节点和从节点是否运作正常。</li><li><strong>自动故障转移（Automatic failover）：</strong> 当 <strong>主节点</strong> 不能正常工作时，哨兵会开始 <strong>自动故障转移操作</strong>，它会将失效主节点的其中一个 <strong>从节点升级为新的主节点</strong>，并让其他从节点改为复制新的主节点。</li><li><strong>配置提供者（Configuration provider）：</strong> 客户端在初始化时，通过连接哨兵来获得当前 Redis 服务的主节点地址。</li><li><strong>通知（Notification）：</strong> 哨兵可以将故障转移的结果发送给客户端。</li></ul><p>其中，监控和自动故障转移功能，使得哨兵可以及时发现主节点故障并完成转移。而配置提供者和通知功能，则需要在与客户端的交互中才能体现。</p><h2 id="Redis-Sentinel（哨兵）实现原理知道吗？"><a href="#Redis-Sentinel（哨兵）实现原理知道吗？" class="headerlink" title="Redis Sentinel（哨兵）实现原理知道吗？"></a>Redis Sentinel（哨兵）实现原理知道吗？</h2><p>哨兵模式是通过哨兵节点完成对数据节点的监控、下线、故障转移。 <img src="https://s2.loli.net/2023/03/27/6ZBnrfDaiJ8QzPw.png" alt="Redis Sentinel工作流程"></p><ul><li><p>定时监控</p><p>Redis Sentinel通过三个定时监控任务完成对各个节点发现和监控：</p><ol><li>每隔10秒，每个Sentinel节点会向主节点和从节点发送info命令获取最新的拓扑结构</li><li>每隔2秒，每个Sentinel节点会向Redis数据节点的__sentinel__：hello 频道上发送该Sentinel节点对于主节点的判断以及当前Sentinel节点的信息</li><li>每隔1秒，每个Sentinel节点会向主节点、从节点、其余Sentinel节点发送一条ping命令做一次心跳检测，来确认这些节点当前是否可达</li></ol></li><li><p><strong>主观下线和客观下线</strong> 主观下线就是哨兵节点认为某个节点有问题，客观下线就是超过一定数量的哨兵节点认为主节点有问题。 <img src="https://s2.loli.net/2023/03/27/iBM3k2gORoJaA9h.png" alt="主观下线和客观下线"></p></li></ul><ol><li>主观下线 每个Sentinel节点会每隔1秒对主节点、从节点、其他Sentinel节点发送ping命令做心跳检测，当这些节点超过 down-after-milliseconds没有进行有效回复，Sentinel节点就会对该节点做失败判定，这个行为叫做主观下线。</li><li>客观下线 当Sentinel主观下线的节点是主节点时，该Sentinel节点会通过sentinel is- master-down-by-addr命令向其他Sentinel节点询问对主节点的判断，当超过 <quorum>个数，Sentinel节点认为主节点确实有问题，这时该Sentinel节点会做出客观下线的决定</li></ol><ul><li><p><strong>领导者Sentinel节点选举</strong> Sentinel节点之间会做一个领导者选举的工作，选出一个Sentinel节点作为领导者进行故障转移的工作。Redis使用了Raft算法实现领导者选举。</p></li><li><p><strong>故障转移</strong></p><p>领导者选举出的Sentinel节点负责故障转移，过程如下： <img src="https://s2.loli.net/2023/03/27/PAr8np1gJNmf3Lz.png" alt="故障转移"></p><ol><li>在从节点列表中选出一个节点作为新的主节点，这一步是相对复杂一些的一步</li><li>Sentinel领导者节点会对第一步选出来的从节点执行slaveof no one命令让其成为主节点</li><li>Sentinel领导者节点会向剩余的从节点发送命令，让它们成为新主节点的从节点</li><li>Sentinel节点集合会将原来的主节点更新为从节点，并保持着对其关注，当其恢复后命令它去复制新的主节点</li></ol></li></ul><h2 id="领导者Sentinel节点选举了解吗？"><a href="#领导者Sentinel节点选举了解吗？" class="headerlink" title="领导者Sentinel节点选举了解吗？"></a>领导者Sentinel节点选举了解吗？</h2><p>Redis使用了Raft算法实 现领导者选举，大致流程如下： <img src="https://s2.loli.net/2023/03/27/HnBofe8Emhkis3x.png" alt="领导者Sentinel节点选举"></p><ol><li>每个在线的Sentinel节点都有资格成为领导者，当它确认主节点主观 下线时候，会向其他Sentinel节点发送sentinel is-master-down-by-addr命令， 要求将自己设置为领导者。</li><li>收到命令的Sentinel节点，如果没有同意过其他Sentinel节点的sentinel is-master-down-by-addr命令，将同意该请求，否则拒绝。</li><li>如果该Sentinel节点发现自己的票数已经大于等于max（quorum， num（sentinels）&#x2F;2+1），那么它将成为领导者。</li><li>如果此过程没有选举出领导者，将进入下一次选举。</li></ol><h2 id="新的主节点是怎样被挑选出来的？"><a href="#新的主节点是怎样被挑选出来的？" class="headerlink" title="新的主节点是怎样被挑选出来的？"></a>新的主节点是怎样被挑选出来的？</h2><p>选出新的主节点，大概分为这么几步： <img src="https://s2.loli.net/2023/03/27/RpY3PDGdinukWAq.png" alt="新的主节点"></p><ol><li>过滤：“不健康”（主观下线、断线）、5秒内没有回复过Sentinel节 点ping响应、与主节点失联超过down-after-milliseconds*10秒。</li><li>选择slave-priority（从节点优先级）最高的从节点列表，如果存在则返回，不存在则继续。</li><li>选择复制偏移量最大的从节点（复制的最完整），如果存在则返 回，不存在则继续。</li><li>选择runid最小的从节点。</li></ol><h2 id="Redis-集群了解吗？"><a href="#Redis-集群了解吗？" class="headerlink" title="Redis 集群了解吗？"></a>Redis 集群了解吗？</h2><p>前面说到了主从存在高可用和分布式的问题，哨兵解决了高可用的问题，而集群就是终极方案，一举解决高可用和分布式问题。 <img src="https://s2.loli.net/2023/03/27/MrsZfqUoAS856ma.png" alt="Redis 集群示意图"></p><ol><li><strong>数据分区：</strong> 数据分区 <em>(或称数据分片)</em> 是集群最核心的功能。集群将数据分散到多个节点，一方面 突破了 Redis 单机内存大小的限制，<strong>存储容量大大增加</strong>；<strong>另一方面</strong> 每个主节点都可以对外提供读服务和写服务，<strong>大大提高了集群的响应能力</strong>。</li><li><strong>高可用：</strong> 集群支持主从复制和主节点的 <strong>自动故障转移</strong> <em>（与哨兵类似）</em>，当任一节点发生故障时，集群仍然可以对外提供服务。</li></ol><h2 id="集群中数据如何分区？"><a href="#集群中数据如何分区？" class="headerlink" title="集群中数据如何分区？"></a>集群中数据如何分区？</h2><p>分布式的存储中，要把数据集按照分区规则映射到多个节点，常见的数据分区规则三种： <img src="https://s2.loli.net/2023/03/27/UpgTVMWGrlyNAHZ.png" alt="分布式数据分区"></p><h3 id="方案一：节点取余分区"><a href="#方案一：节点取余分区" class="headerlink" title="方案一：节点取余分区"></a>方案一：节点取余分区</h3><p>节点取余分区，非常好理解，使用特定的数据，比如Redis的键，或者用户ID之类，对响应的hash值取余：hash（key）%N，来确定数据映射到哪一个节点上。</p><p>不过该方案最大的问题是，当节点数量变化时，如扩容或收缩节点，数据节点映射关 系需要重新计算，会导致数据的重新迁移。</p><p><img src="https://s2.loli.net/2023/03/27/ZjznhpoyqGM2ilA.png" alt="节点取余分区">节点取余分区</p><h3 id="方案二：一致性哈希分区"><a href="#方案二：一致性哈希分区" class="headerlink" title="方案二：一致性哈希分区"></a>方案二：一致性哈希分区</h3><p>将整个 Hash 值空间组织成一个虚拟的圆环，然后将缓存节点的 IP 地址或者主机名做 Hash 取值后，放置在这个圆环上。当我们需要确定某一个 Key 需 要存取到哪个节点上的时候，先对这个 Key 做同样的 Hash 取值，确定在环上的位置，然后按照顺时针方向在环上“行走”，遇到的第一个缓存节点就是要访问的节点。</p><p>比如说下面 这张图里面，Key 1 和 Key 2 会落入到 Node 1 中，Key 3、Key 4 会落入到 Node 2 中，Key 5 落入到 Node 3 中，Key 6 落入到 Node 4 中。 <img src="https://s2.loli.net/2023/03/27/LgN6KixTeBot9nf.png" alt="一致性哈希分区"></p><p>这种方式相比节点取余最大的好处在于加入和删除节点只影响哈希环中 相邻的节点，对其他节点无影响。</p><p>但它还是存在问题：</p><ul><li>缓存节点在圆环上分布不平均，会造成部分缓存节点的压力较大</li><li>当某个节点故障时，这个节点所要承担的所有访问都会被顺移到另一个节点上，会对后面这个节点造成力。</li></ul><h3 id="方案三：虚拟槽分区"><a href="#方案三：虚拟槽分区" class="headerlink" title="方案三：虚拟槽分区"></a>方案三：虚拟槽分区</h3><p>这个方案 一致性哈希分区的基础上，引入了 <strong>虚拟节点</strong> 的概念。Redis 集群使用的便是该方案，其中的虚拟节点称为 <strong>槽（slot）</strong>。槽是介于数据和实际节点之间的虚拟概念，每个实际节点包含一定数量的槽，每个槽包含哈希值在一定范围内的数据。 <img src="https://s2.loli.net/2023/03/27/rRQ69Jps5Df3iVw.png" alt="虚拟槽分配"></p><p>在使用了槽的一致性哈希分区中，槽是数据管理和迁移的基本单位。槽解耦了数据和实际节点 之间的关系，增加或删除节点对系统的影响很小。仍以上图为例，系统中有 <code>4</code> 个实际节点，假设为其分配 <code>16</code> 个槽(0-15)；</p><ul><li>槽 0-3 位于 node1；4-7 位于 node2；以此类推….</li></ul><p>如果此时删除 <code>node2</code>，只需要将槽 4-7 重新分配即可，例如槽 4-5 分配给 <code>node1</code>，槽 6 分配给 <code>node3</code>，槽 7 分配给 <code>node4</code>，数据在其他节点的分布仍然较为均衡。</p><h2 id="能说说Redis集群的原理吗？"><a href="#能说说Redis集群的原理吗？" class="headerlink" title="能说说Redis集群的原理吗？"></a>能说说Redis集群的原理吗？</h2><p>Redis集群通过数据分区来实现数据的分布式存储，通过自动故障转移实现高可用。</p><h3 id="集群创建"><a href="#集群创建" class="headerlink" title="集群创建"></a>集群创建</h3><p>数据分区是在集群创建的时候完成的。 <img src="https://s2.loli.net/2023/03/27/XHql4rBRUPyek5F.png" alt="集群创建"></p><p><strong>设置节点</strong> Redis集群一般由多个节点组成，节点数量至少为6个才能保证组成完整高可用的集群。每个节点需要开启配置cluster-enabled yes，让Redis运行在集群模式下。 <img src="https://s2.loli.net/2023/03/27/viI7PoNTe1QUH3j.png" alt="节点和握手"><strong>节点握手</strong> 节点握手是指一批运行在集群模式下的节点通过Gossip协议彼此通信， 达到感知对方的过程。节点握手是集群彼此通信的第一步，由客户端发起命 令：cluster meet{ip}{port}。完成节点握手之后，一个个的Redis节点就组成了一个多节点的集群。</p><p><strong>分配槽（slot）</strong> Redis集群把所有的数据映射到16384个槽中。每个节点对应若干个槽，只有当节点分配了槽，才能响应和这些槽关联的键命令。通过 cluster addslots命令为节点分配槽。</p><p><img src="https://s2.loli.net/2023/03/27/Q1I3WlAT89zNqr6.png" alt="分配槽">分配槽</p><h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><p>Redis集群的故障转移和哨兵的故障转移类似，但是Redis集群中所有的节点都要承担状态维护的任务。</p><p><strong>故障发现</strong> Redis集群内节点通过ping&#x2F;pong消息实现节点通信，集群中每个节点都会定期向其他节点发送ping消息，接收节点回复pong 消息作为响应。如果在cluster-node-timeout时间内通信一直失败，则发送节 点会认为接收节点存在故障，把接收节点标记为主观下线（pfail）状态。 <img src="https://s2.loli.net/2023/03/27/qOEomI6bpVXsLaz.png" alt="主观下线"> 当某个节点判断另一个节点主观下线后，相应的节点状态会跟随消息在集群内传播。通过Gossip消息传播，集群内节点不断收集到故障节点的下线报告。当 半数以上持有槽的主节点都标记某个节点是主观下线时。触发客观下线流程。 <img src="https://s2.loli.net/2023/03/27/XLH8uShwtfaDcCs.png" alt="主观下线和客观下线"></p><p><strong>故障恢复</strong></p><p>故障节点变为客观下线后，如果下线节点是持有槽的主节点则需要在它 的从节点中选出一个替换它，从而保证集群的高可用。</p><p><img src="https://s2.loli.net/2023/03/27/S5ERuKJtzey8Ta7.png" alt="故障恢复流程">故障恢复流程</p><ol><li>资格检查 每个从节点都要检查最后与主节点断线时间，判断是否有资格替换故障 的主节点。</li><li>准备选举时间 当从节点符合故障转移资格后，更新触发故障选举的时间，只有到达该 时间后才能执行后续流程。</li><li>发起选举 当从节点定时任务检测到达故障选举时间（failover_auth_time）到达后，发起选举流程。</li><li>选举投票 持有槽的主节点处理故障选举消息。投票过程其实是一个领导者选举的过程，如集群内有N个持有槽的主节 点代表有N张选票。由于在每个配置纪元内持有槽的主节点只能投票给一个 从节点，因此只能有一个从节点获得N&#x2F;2+1的选票，保证能够找出唯一的从节点。 <img src="https://s2.loli.net/2023/03/27/eNfSMYWx6mACPb5.png" alt="选举投票"></li><li>替换主节点 当从节点收集到足够的选票之后，触发替换主节点操作。</li></ol><blockquote><p><strong>部署Redis集群至少需要几个物理节点？</strong></p></blockquote><p>在投票选举的环节，故障主节点也算在投票数内，假设集群内节点规模是3主3从，其中有2 个主节点部署在一台机器上，当这台机器宕机时，由于从节点无法收集到 3&#x2F;2+1个主节点选票将导致故障转移失败。这个问题也适用于故障发现环节。因此部署集群时所有主节点最少需要部署在3台物理机上才能避免单点问题。</p><h2 id="说说集群的伸缩？"><a href="#说说集群的伸缩？" class="headerlink" title="说说集群的伸缩？"></a>说说集群的伸缩？</h2><p>Redis集群提供了灵活的节点扩容和收缩方案，可以在不影响集群对外服务的情况下，为集群添加节点进行扩容也可以下线部分节点进行缩容。 <img src="https://s2.loli.net/2023/03/27/l425jyc8ApdkRLv.png" alt="集群的伸缩">其实，集群扩容和缩容的关键点，就在于槽和节点的对应关系，扩容和缩容就是将一部分<code>槽</code>和<code>数据</code>迁移给新节点。</p><p>例如下面一个集群，每个节点对应若干个槽，每个槽对应一定的数据，如果希望加入1个节点希望实现集群扩容时，需要通过相关命令把一部分槽和内容迁移给新节点。 <img src="https://s2.loli.net/2023/03/27/1vcuhI8yE3XmAQV.png" alt="扩容实例">缩容也是类似，先把槽和数据迁移到其它节点，再把对应的节点下线。</p><h1 id="缓存设计"><a href="#缓存设计" class="headerlink" title="缓存设计"></a>缓存设计</h1><h2 id="什么是缓存击穿、缓存穿透、缓存雪崩？"><a href="#什么是缓存击穿、缓存穿透、缓存雪崩？" class="headerlink" title="什么是缓存击穿、缓存穿透、缓存雪崩？"></a>什么是缓存击穿、缓存穿透、缓存雪崩？</h2><p>PS:这是多年黄历的老八股了，一定要理解清楚。</p><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>一个并发访问量比较大的key在某个时间过期，导致所有的请求直接打在DB上。</p><p><img src="https://s2.loli.net/2023/03/27/dAtKyRGYawW3xOD.png" alt="缓存击穿"> 解决⽅案：</p><ol><li>加锁更新，⽐如请求查询A，发现缓存中没有，对A这个key加锁，同时去数据库查询数据，写⼊缓存，再返回给⽤户，这样后⾯的请求就可以从缓存中拿到数据了。 <img src="https://s2.loli.net/2023/03/27/PRSVesYwur6tfGA.png" alt="加锁更新"></li><li>将过期时间组合写在value中，通过异步的⽅式不断的刷新过期时间，防⽌此类现象。</li></ol><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透指的查询缓存和数据库中都不存在的数据，这样每次请求直接打到数据库，就好像缓存不存在一样。</p><p><img src="https://s2.loli.net/2023/03/27/5zFkYdE8mXiU3hI.png" alt="缓存穿透"> 缓存穿透将导致不存在的数据每次请求都要到存储层去查询，失去了缓存保护后端存储的意义。</p><p>缓存穿透可能会使后端存储负载加大，如果发现大量存储层空命中，可能就是出现了缓存穿透问题。</p><p>缓存穿透可能有两种原因：</p><ol><li>自身业务代码问题</li><li>恶意攻击，爬虫造成空命中</li></ol><p>它主要有两种解决办法：</p><ul><li><strong>缓存空值&#x2F;默认值</strong></li></ul><p>一种方式是在数据库不命中之后，把一个空对象或者默认值保存到缓存，之后再访问这个数据，就会从缓存中获取，这样就保护了数据库。</p><p><img src="https://s2.loli.net/2023/03/27/7UrFf3HP2cilwzn.png" alt="缓存空值/默认值"></p><center>缓存空值/默认值</center><p>缓存空值有两大问题：</p><ol><li>空值做了缓存，意味着缓存层中存了更多的键，需要更多的内存空间（如果是攻击，问题更严重），比较有效的方法是针对这类数据设置一个较短的过期时间，让其自动剔除。</li><li>缓存层和存储层的数据会有一段时间窗口的不一致，可能会对业务有一定影响。 例如过期时间设置为5分钟，如果此时存储层添加了这个数据，那此段时间就会出现缓存层和存储层数据的不一致。 这时候可以利用消息队列或者其它异步方式清理缓存中的空对象。</li></ol><ul><li><strong>布隆过滤器</strong> 除了缓存空对象，我们还可以在存储和缓存之前，加一个布隆过滤器，做一层过滤。</li></ul><p>布隆过滤器里会保存数据是否存在，如果判断数据不不能再，就不会访问存储。 <img src="https://s2.loli.net/2023/03/27/WXMVqek5xzYIulK.png" alt="布隆过滤器"> 两种解决方案的对比： <img src="https://s2.loli.net/2023/03/27/5ZcpFA46KsP1kLa.png" alt="缓存空对象核布隆过滤器方案对比"></p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>某⼀时刻发⽣⼤规模的缓存失效的情况，例如缓存服务宕机、大量key在同一时间过期，这样的后果就是⼤量的请求进来直接打到DB上，可能导致整个系统的崩溃，称为雪崩。</p><p><img src="https://s2.loli.net/2023/03/27/oOrFsbQhDG4JERX.png" alt="缓存雪崩"> 缓存雪崩是三大缓存问题里最严重的一种，我们来看看怎么预防和处理。</p><ul><li><strong>提高缓存可用性</strong></li></ul><ol><li>集群部署：通过集群来提升缓存的可用性，可以利用Redis本身的Redis Cluster或者第三方集群方案如Codis等。</li><li>多级缓存：设置多级缓存，第一级缓存失效的基础上，访问二级缓存，每一级缓存的失效时间都不同。</li></ol><ul><li><strong>过期时间</strong></li></ul><ol><li>均匀过期：为了避免大量的缓存在同一时间过期，可以把不同的 key 过期时间随机生成，避免过期时间太过集中。</li><li>热点数据永不过期。</li></ol><ul><li><strong>熔断降级</strong></li></ul><ol><li>服务熔断：当缓存服务器宕机或超时响应时，为了防止整个系统出现雪崩，暂时停止业务服务访问缓存系统。</li><li>服务降级：当出现大量缓存失效，而且处在高并发高负荷的情况下，在业务系统内部暂时舍弃对一些非核心的接口和数据的请求，而直接返回一个提前准备好的 fallback（退路）错误处理信息。</li></ol><h2 id="能说说布隆过滤器吗？"><a href="#能说说布隆过滤器吗？" class="headerlink" title="能说说布隆过滤器吗？"></a>能说说布隆过滤器吗？</h2><p>布隆过滤器，它是一个连续的数据结构，每个存储位存储都是一个<code>bit</code>，即<code>0</code>或者<code>1</code>, 来标识数据是否存在。</p><p>存储数据的时时候，使用K个不同的哈希函数将这个变量映射为bit列表的的K个点，把它们置为1。</p><p><img src="https://s2.loli.net/2023/03/27/CliX38dKWmpbFRQ.png" alt="布隆过滤器">我们判断缓存key是否存在，同样，K个哈希函数，映射到bit列表上的K个点，判断是不是1：</p><ul><li>如果全不是1，那么key不存在；</li><li>如果都是1，也只是表示key可能存在。</li></ul><p>布隆过滤器也有一些缺点：</p><ol><li>它在判断元素是否在集合中时是有一定错误几率，因为哈希算法有一定的碰撞的概率。</li><li>不支持删除元素。</li></ol><h2 id="如何保证缓存和数据库数据的⼀致性？"><a href="#如何保证缓存和数据库数据的⼀致性？" class="headerlink" title="如何保证缓存和数据库数据的⼀致性？"></a>如何保证缓存和数据库数据的⼀致性？</h2><p>根据CAP理论，在保证可用性和分区容错性的前提下，无法保证一致性，所以缓存和数据库的绝对一致是不可能实现的，只能尽可能保存缓存和数据库的最终一致性。</p><h3 id="选择合适的缓存更新策略"><a href="#选择合适的缓存更新策略" class="headerlink" title="选择合适的缓存更新策略"></a>选择合适的缓存更新策略</h3><p><strong>1.删除缓存而不是更新缓存</strong></p><p>当一个线程对缓存的key进行写操作的时候，如果其它线程进来读数据库的时候，读到的就是脏数据，产生了数据不一致问题。</p><p>相比较而言，删除缓存的速度比更新缓存的速度快很多，所用时间相对也少很多，读脏数据的概率也小很多。 <img src="https://s2.loli.net/2023/03/27/Xy4xQKbLl8fs2Jk.png" alt="删除缓存和更新缓存"></p><p><strong>2.先更数据，后删缓存</strong> 先更数据库还是先删缓存？这是一个问题。</p><p>更新数据，耗时可能在删除缓存的百倍以上。在缓存中不存在对应的key，数据库又没有完成更新的时候，如果有线程进来读取数据，并写入到缓存，那么在更新成功之后，这个key就是一个脏数据。</p><p>毫无疑问，先删缓存，再更数据库，缓存中key不存在的时间的时间更长，有更大的概率会产生脏数据。</p><p><img src="https://s2.loli.net/2023/03/27/yTV1IgZre38h6wm.png" alt="先更数据库还是先删缓存">目前最流行的缓存读写策略cache-aside-pattern就是采用先更数据库，再删缓存的方式。</p><h3 id="缓存不一致处理"><a href="#缓存不一致处理" class="headerlink" title="缓存不一致处理"></a>缓存不一致处理</h3><p>如果不是并发特别高，对缓存依赖性很强，其实一定程序的不一致是可以接受的。</p><p>但是如果对一致性要求比较高，那就得想办法保证缓存和数据库中数据一致。</p><p>缓存和数据库数据不一致常见的两种原因：</p><ul><li>缓存key删除失败</li><li>并发导致写入了脏数据</li></ul><p><img src="https://s2.loli.net/2023/03/27/TmIMGK8aZA5lHzh.png" alt="缓存一致性"></p><center>缓存一致性</center><p><strong>消息队列保证key被删除</strong> 可以引入消息队列，把要删除的key或者删除失败的key丢尽消息队列，利用消息队列的重试机制，重试删除对应的key。</p><p><img src="https://s2.loli.net/2023/03/27/V1TLG672xcqIeWP.png" alt="消息队列保证key被删除">这种方案看起来不错，缺点是对业务代码有一定的侵入性。</p><p><strong>数据库订阅+消息队列保证key被删除</strong> 可以用一个服务（比如阿里的 canal）去监听数据库的binlog，获取需要操作的数据。</p><p>然后用一个公共的服务获取订阅程序传来的信息，进行缓存删除操作。 <img src="https://s2.loli.net/2023/03/27/jF5moJfcCkaTGB8.png" alt="数据库订阅+消息队列保证key被删除"> 这种方式降低了对业务的侵入，但其实整个系统的复杂度是提升的，适合基建完善的大厂。</p><p><strong>延时双删防止脏数据</strong> 还有一种情况，是在缓存不存在的时候，写入了脏数据，这种情况在先删缓存，再更数据库的缓存更新策略下发生的比较多，解决方案是延时双删。</p><p>简单说，就是在第一次删除缓存之后，过了一段时间之后，再次删除缓存。</p><p><img src="https://s2.loli.net/2023/03/27/KozlaYLBe1U4vFj.png" alt="延时双删">延时双删</p><p>这种方式的延时时间设置需要仔细考量和测试。</p><p><strong>设置缓存过期时间兜底</strong></p><p>这是一个朴素但是有用的办法，给缓存设置一个合理的过期时间，即使发生了缓存数据不一致的问题，它也不会永远不一致下去，缓存过期的时候，自然又会恢复一致。</p><h2 id="如何保证本地缓存和分布式缓存的一致？"><a href="#如何保证本地缓存和分布式缓存的一致？" class="headerlink" title="如何保证本地缓存和分布式缓存的一致？"></a>如何保证本地缓存和分布式缓存的一致？</h2><p>PS:这道题面试很少问，但实际工作中很常见。</p><p>在日常的开发中，我们常常采用两级缓存：本地缓存+分布式缓存。</p><p>所谓本地缓存，就是对应服务器的内存缓存，比如Caffeine，分布式缓存基本就是采用Redis。</p><p>那么问题来了，本地缓存和分布式缓存怎么保持数据一致？ <img src="https://s2.loli.net/2023/03/27/Nw3Yacsn46obXkT.png" alt="延时双删"> Redis缓存，数据库发生更新，直接删除缓存的key即可，因为对于应用系统而言，它是一种中心化的缓存。</p><p>但是本地缓存，它是非中心化的，散落在分布式服务的各个节点上，没法通过客户端的请求删除本地缓存的key，所以得想办法通知集群所有节点，删除对应的本地缓存key。 <img src="https://s2.loli.net/2023/03/27/VIXtYzDGr3vEAFO.png" alt="本地缓存/分布式缓存保持一致"></p><p>可以采用消息队列的方式：</p><ol><li>采用Redis本身的Pub&#x2F;Sub机制，分布式集群的所有节点订阅删除本地缓存频道，删除Redis缓存的节点，同事发布删除本地缓存消息，订阅者们订阅到消息后，删除对应的本地key。 但是Redis的发布订阅不是可靠的，不能保证一定删除成功。</li><li>引入专业的消息队列，比如RocketMQ，保证消息的可靠性，但是增加了系统的复杂度。</li><li>设置适当的过期时间兜底，本地缓存可以设置相对短一些的过期时间。</li></ol><h2 id="怎么处理热key？"><a href="#怎么处理热key？" class="headerlink" title="怎么处理热key？"></a>怎么处理热key？</h2><blockquote><p><strong>什么是热Key？</strong> 所谓的热key，就是访问频率比较的key。</p></blockquote><p>比如，热门新闻事件或商品，这类key通常有大流量的访问，对存储这类信息的 Redis来说，是不小的压力。</p><p>假如Redis集群部署，热key可能会造成整体流量的不均衡，个别节点出现OPS过大的情况，极端情况下热点key甚至会超过 Redis本身能够承受的OPS。</p><blockquote><p><strong>怎么处理热key？</strong></p></blockquote><p><img src="https://s2.loli.net/2023/03/27/wyGXH7M8agpIljc.png" alt="热key处理"> 对热key的处理，最关键的是对热点key的监控，可以从这些端来监控热点key:</p><ol><li>客户端 客户端其实是距离key“最近”的地方，因为Redis命令就是从客户端发出的，例如在客户端设置全局字典（key和调用次数），每次调用Redis命令时，使用这个字典进行记录。</li><li>代理端 像Twemproxy、Codis这些基于代理的Redis分布式架构，所有客户端的请求都是通过代理端完成的，可以在代理端进行收集统计。</li><li>Redis服务端 使用monitor命令统计热点key是很多开发和运维人员首先想到，monitor命令可以监控到Redis执行的所有命令。</li></ol><p>只要监控到了热key，对热key的处理就简单了：</p><ol><li>把热key打散到不同的服务器，降低压⼒</li><li>加⼊⼆级缓存，提前加载热key数据到内存中，如果redis宕机，⾛内存查询</li></ol><h2 id="缓存预热怎么做呢？"><a href="#缓存预热怎么做呢？" class="headerlink" title="缓存预热怎么做呢？"></a>缓存预热怎么做呢？</h2><p>所谓缓存预热，就是提前把数据库里的数据刷到缓存里，通常有这些方法：</p><p>1、直接写个缓存刷新页面或者接口，上线时手动操作</p><p>2、数据量不大，可以在项目启动的时候自动进行加载</p><p>3、定时任务刷新缓存.</p><h2 id="热点key重建？问题？解决？"><a href="#热点key重建？问题？解决？" class="headerlink" title="热点key重建？问题？解决？"></a>热点key重建？问题？解决？</h2><p>开发的时候一般使用“缓存+过期时间”的策略，既可以加速数据读写，又保证数据的定期更新，这种模式基本能够满足绝大部分需求。</p><p>但是有两个问题如果同时出现，可能就会出现比较大的问题：</p><ul><li>当前key是一个热点key（例如一个热门的娱乐新闻），并发量非常大。</li><li>重建缓存不能在短时间完成，可能是一个复杂计算，例如复杂的 SQL、多次IO、多个依赖等。 在缓存失效的瞬间，有大量线程来重建缓存，造成后端负载加大，甚至可能会让应用崩溃。</li></ul><blockquote><p><strong>怎么处理呢？</strong></p></blockquote><p>要解决这个问题也不是很复杂，解决问题的要点在于：</p><ul><li>减少重建缓存的次数。</li><li>数据尽可能一致。</li><li>较少的潜在危险。</li></ul><p>所以一般采用如下方式：</p><ol><li>互斥锁（mutex key） 这种方法只允许一个线程重建缓存，其他线程等待重建缓存的线程执行完，重新从缓存获取数据即可。</li><li>永远不过期 “永远不过期”包含两层意思：</li></ol><ul><li>从缓存层面来看，确实没有设置过期时间，所以不会出现热点key过期后产生的问题，也就是“物理”不过期。</li><li>从功能层面来看，为每个value设置一个逻辑过期时间，当发现超过逻辑过期时间后，会使用单独的线程去构建缓存。</li></ul><h2 id="无底洞问题吗？如何解决？"><a href="#无底洞问题吗？如何解决？" class="headerlink" title="无底洞问题吗？如何解决？"></a>无底洞问题吗？如何解决？</h2><blockquote><p><strong>什么是无底洞问题？</strong></p></blockquote><p>2010年，Facebook的Memcache节点已经达到了3000个，承载着TB级别的缓存数据。但开发和运维人员发现了一个问题，为了满足业务要求添加了大量新Memcache节点，但是发现性能不但没有好转反而下降了，当时将这 种现象称为缓存的“<strong>无底洞</strong>”现象。</p><p>那么为什么会产生这种现象呢?</p><p>通常来说添加节点使得Memcache集群 性能应该更强了，但事实并非如此。键值数据库由于通常采用哈希函数将 key映射到各个节点上，造成key的分布与业务无关，但是由于数据量和访问量的持续增长，造成需要添加大量节点做水平扩容，导致键值分布到更多的 节点上，所以无论是Memcache还是Redis的分布式，批量操作通常需要从不同节点上获取，相比于单机批量操作只涉及一次网络操作，分布式批量操作会涉及多次网络时间。</p><blockquote><p><strong>无底洞问题如何优化呢？</strong></p></blockquote><p>先分析一下无底洞问题：</p><ul><li>客户端一次批量操作会涉及多次网络操作，也就意味着批量操作会随着节点的增多，耗时会不断增大。</li><li>网络连接数变多，对节点的性能也有一定影响。</li></ul><p>常见的优化思路如下：</p><ul><li>命令本身的优化，例如优化操作语句等。</li><li>减少网络通信次数。</li><li>降低接入成本，例如客户端使用长连&#x2F;连接池、NIO等。</li></ul><h1 id="Redis运维"><a href="#Redis运维" class="headerlink" title="Redis运维"></a>Redis运维</h1><h2 id="Redis报内存不足怎么处理？"><a href="#Redis报内存不足怎么处理？" class="headerlink" title="Redis报内存不足怎么处理？"></a>Redis报内存不足怎么处理？</h2><p>Redis 内存不足有这么几种处理方式：</p><ul><li>修改配置文件 redis.conf 的 maxmemory 参数，增加 Redis 可用内存</li><li>也可以通过命令set maxmemory动态设置内存上限</li><li>修改内存淘汰策略，及时释放内存空间</li><li>使用 Redis 集群模式，进行横向扩容。</li></ul><h2 id="Redis的过期数据回收策略有哪些？"><a href="#Redis的过期数据回收策略有哪些？" class="headerlink" title="Redis的过期数据回收策略有哪些？"></a>Redis的过期数据回收策略有哪些？</h2><p>Redis主要有2种过期数据回收策略： <img src="https://s2.loli.net/2023/03/27/dQwDO6rZJqUfMvN.png" alt="在这里插入图片描述"></p><p><strong>惰性删除</strong></p><p>惰性删除指的是当我们查询key的时候才对key进⾏检测，如果已经达到过期时间，则删除。显然，他有⼀个缺点就是如果这些过期的key没有被访问，那么他就⼀直⽆法被删除，⽽且⼀直占⽤内存。</p><p><strong>定期删除</strong></p><p>定期删除指的是Redis每隔⼀段时间对数据库做⼀次检查，删除⾥⾯的过期key。由于不可能对所有key去做轮询来删除，所以Redis会每次随机取⼀些key去做检查和删除。</p><h2 id="Redis有哪些内存溢出控制-x2F-内存淘汰策略？"><a href="#Redis有哪些内存溢出控制-x2F-内存淘汰策略？" class="headerlink" title="Redis有哪些内存溢出控制&#x2F;内存淘汰策略？"></a>Redis有哪些内存溢出控制&#x2F;内存淘汰策略？</h2><p>Redis所用内存达到maxmemory上限时会触发相应的溢出控制策略，Redis支持六种策略： <img src="https://s2.loli.net/2023/03/27/poC5q2kc3MGEnNz.png" alt="Redis六种内存溢出控制策略"></p><ol><li>noeviction：默认策略，不会删除任何数据，拒绝所有写入操作并返 回客户端错误信息，此 时Redis只响应读操作。</li><li>volatile-lru：根据LRU算法删除设置了超时属性（expire）的键，直 到腾出足够空间为止。如果没有可删除的键对象，回退到noeviction策略。</li><li>allkeys-lru：根据LRU算法删除键，不管数据有没有设置超时属性， 直到腾出足够空间为止。</li><li>allkeys-random：随机删除所有键，直到腾出足够空间为止。</li><li>volatile-random：随机删除过期键，直到腾出足够空间为止。</li><li>volatile-ttl：根据键值对象的ttl属性，删除最近将要过期数据。如果 没有，回退到noeviction策略。</li></ol><h2 id="Redis阻塞？怎么解决？"><a href="#Redis阻塞？怎么解决？" class="headerlink" title="Redis阻塞？怎么解决？"></a>Redis阻塞？怎么解决？</h2><p>Redis发生阻塞，可以从以下几个方面排查： <img src="https://s2.loli.net/2023/03/27/xhNnBuAdKG4Uf2s.png" alt="Redis阻塞排查"></p><ul><li><p><strong>API或数据结构使用不合理</strong></p><p>通常Redis执行命令速度非常快，但是不合理地使用命令，可能会导致执行速度很慢，导致阻塞，对于高并发的场景，应该尽量避免在大对象上执行算法复杂 度超过O（n）的命令。</p><p>对慢查询的处理分为两步：</p><ol><li>发现慢查询： slowlog get{n}命令可以获取最近 的n条慢查询命令；</li><li>发现慢查询后，可以从两个方向去优化慢查询： 1）修改为低算法复杂度的命令，如hgetall改为hmget等，禁用keys、sort等命 令 2）调整大对象：缩减大对象数据或把大对象拆分为多个小对象，防止一次命令操作过多的数据。</li></ol></li><li><p><strong>CPU饱和的问题</strong></p><p>单线程的Redis处理命令时只能使用一个CPU。而CPU饱和是指Redis单核CPU使用率跑到接近100%。</p><p>针对这种情况，处理步骤一般如下：</p><ol><li>判断当前Redis并发量是否已经达到极限，可以使用统计命令redis-cli-h{ip}-p{port}–stat获取当前 Redis使用情况</li><li>如果Redis的请求几万+，那么大概就是Redis的OPS已经到了极限，应该做集群化水品扩展来分摊OPS压力</li><li>如果只有几百几千，那么就得排查命令和内存的使用</li></ol></li><li><p><strong>持久化相关的阻塞</strong></p><p>对于开启了持久化功能的Redis节点，需要排查是否是持久化导致的阻塞。</p><ol><li>fork阻塞 fork操作发生在RDB和AOF重写时，Redis主线程调用fork操作产生共享 内存的子进程，由子进程完成持久化文件重写工作。如果fork操作本身耗时过长，必然会导致主线程的阻塞。</li><li>AOF刷盘阻塞 当我们开启AOF持久化功能时，文件刷盘的方式一般采用每秒一次，后台线程每秒对AOF文件做fsync操作。当硬盘压力过大时，fsync操作需要等 待，直到写入完成。如果主线程发现距离上一次的fsync成功超过2秒，为了 数据安全性它会阻塞直到后台线程执行fsync操作完成。</li><li>HugePage写操作阻塞 对于开启Transparent HugePages的 操作系统，每次写命令引起的复制内存页单位由4K变为2MB，放大了512 倍，会拖慢写操作的执行时间，导致大量写操作慢查询。</li></ol></li></ul><h2 id="大key问题了解吗？"><a href="#大key问题了解吗？" class="headerlink" title="大key问题了解吗？"></a>大key问题了解吗？</h2><p>Redis使用过程中，有时候会出现大key的情况， 比如：</p><ul><li>单个简单的key存储的value很大，size超过10KB</li><li>hash， set，zset，list 中存储过多的元素（以万为单位）</li></ul><blockquote><p><strong>大key会造成什么问题呢？</strong></p></blockquote><ul><li>客户端耗时增加，甚至超时</li><li>对大key进行IO操作时，会严重占用带宽和CPU</li><li>造成Redis集群中数据倾斜</li><li>主动删除、被动删等，可能会导致阻塞</li></ul><blockquote><p><strong>如何找到大key?</strong></p></blockquote><ul><li>bigkeys命令：使用bigkeys命令以遍历的方式分析Redis实例中的所有Key，并返回整体统计信息与每个数据类型中Top1的大Key</li><li>redis-rdb-tools：redis-rdb-tools是由Python写的用来分析Redis的rdb快照文件用的工具，它可以把rdb快照文件生成json文件或者生成报表用来分析Redis的使用详情。</li></ul><blockquote><p><strong>如何处理大key?</strong></p></blockquote><p><img src="https://s2.loli.net/2023/03/27/N3FCLOh25PZVnck.png" alt="大key处理">大key处理</p><ul><li><strong>删除大key</strong><ul><li>当Redis版本大于4.0时，可使用UNLINK命令安全地删除大Key，该命令能够以非阻塞的方式，逐步地清理传入的Key。</li><li>当Redis版本小于4.0时，避免使用阻塞式命令KEYS，而是建议通过SCAN命令执行增量迭代扫描key，然后判断进行删除。</li></ul></li><li><strong>压缩和拆分key</strong><ul><li>当vaule是string时，比较难拆分，则使用序列化、压缩算法将key的大小控制在合理范围内，但是序列化和反序列化都会带来更多时间上的消耗。</li><li>当value是string，压缩之后仍然是大key，则需要进行拆分，一个大key分为不同的部分，记录每个部分的key，使用multiget等操作实现事务读取。</li><li>当value是list&#x2F;set等集合类型时，根据预估的数据规模来进行分片，不同的元素计算后分到不同的片。</li></ul></li></ul><h2 id="Redis常见性能问题和解决方案？"><a href="#Redis常见性能问题和解决方案？" class="headerlink" title="Redis常见性能问题和解决方案？"></a>Redis常见性能问题和解决方案？</h2><ol><li>Master 最好不要做任何持久化工作，包括内存快照和 AOF 日志文件，特别是不要启用内存快照做持久化。</li><li>如果数据比较关键，某个 Slave 开启 AOF 备份数据，策略为每秒同步一次。</li><li>为了主从复制的速度和连接的稳定性，Slave 和 Master 最好在同一个局域网内。</li><li>尽量避免在压力较大的主库上增加从库。</li><li>Master 调用 BGREWRITEAOF 重写 AOF 文件，AOF 在重写的时候会占大量的 CPU 和内存资源，导致服务 load 过高，出现短暂服务暂停现象。</li><li>为了 Master 的稳定性，主从复制不要用图状结构，用单向链表结构更稳定，即主从关为：Master&lt;–Slave1&lt;–Slave2&lt;–Slave3…，这样的结构也方便解决单点故障问题，实现 Slave 对 Master 的替换，也即，如果 Master 挂了，可以立马启用 Slave1 做 Master，其他不变。</li></ol><h1 id="Redis应用"><a href="#Redis应用" class="headerlink" title="Redis应用"></a>Redis应用</h1><h2 id="使用Redis-如何实现异步队列？"><a href="#使用Redis-如何实现异步队列？" class="headerlink" title="使用Redis 如何实现异步队列？"></a>使用Redis 如何实现异步队列？</h2><p>我们知道redis支持很多种结构的数据，那么如何使用redis作为异步队列使用呢？ 一般有以下几种方式：</p><ul><li><strong>使用list作为队列，lpush生产消息，rpop消费消息</strong></li></ul><p>这种方式，消费者死循环rpop从队列中消费消息。但是这样，即使队列里没有消息，也会进行rpop，会导致Redis CPU的消耗。 <img src="https://s2.loli.net/2023/03/27/hDNBAk6dP5YqVyo.png" alt="list作为队列"> 可以通过让消费者休眠的方式的方式来处理，但是这样又会又消息的延迟问题。</p><p>-<strong>使用list作为队列，lpush生产消息，brpop消费消息</strong></p><p>brpop是rpop的阻塞版本，list为空的时候，它会一直阻塞，直到list中有值或者超时。 <img src="https://s2.loli.net/2023/03/27/8oD3UY5McAgKe1P.png" alt="list作为队列，brpop"></p><p>这种方式只能实现一对一的消息队列。</p><ul><li><strong>使用Redis的pub&#x2F;sub来进行消息的发布&#x2F;订阅</strong></li></ul><p>发布&#x2F;订阅模式可以1：N的消息发布&#x2F;订阅。发布者将消息发布到指定的频道频道（channel），订阅相应频道的客户端都能收到消息。</p><p><img src="https://s2.loli.net/2023/03/27/shd2uaK4DSoXe3v.png" alt="pub/sub"> 但是这种方式不是可靠的，它不保证订阅者一定能收到消息，也不进行消息的存储。</p><p>所以，一般的异步队列的实现还是交给专业的消息队列。</p><h2 id="Redis-如何实现延时队列"><a href="#Redis-如何实现延时队列" class="headerlink" title="Redis 如何实现延时队列?"></a>Redis 如何实现延时队列?</h2><ul><li><strong>使用zset，利用排序实现</strong></li></ul><p>可以使用 zset这个结构，用设置好的时间戳作为score进行排序，使用 zadd score1 value1 ….命令就可以一直往内存中生产消息。再利用 zrangebysocre 查询符合条件的所有待处理的任务，通过循环执行队列任务即可。 <img src="https://s2.loli.net/2023/03/27/qgJs8YjkXi3QCIo.png" alt="zset实现延时队列"></p><h2 id="Redis-支持事务吗？"><a href="#Redis-支持事务吗？" class="headerlink" title="Redis 支持事务吗？"></a>Redis 支持事务吗？</h2><p>Redis提供了简单的事务，但它对事务ACID的支持并不完备。</p><p>multi命令代表事务开始，exec命令代表事务结束，它们之间的命令是原子顺序执行的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; multi </span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; sadd user:a:follow user:b </span><br><span class="line">QUEUED </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; sadd user:b:fans user:a </span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; sismember user:a:follow user:b </span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; exec <span class="number">1</span>) (integer) <span class="number">1</span></span><br><span class="line"><span class="number">2</span>) (integer) <span class="number">1</span></span><br></pre></td></tr></table></figure><p>Redis事务的原理，是所有的指令在 exec 之前不执行，而是缓存在 服务器的一个事务队列中，服务器一旦收到 exec 指令，才开执行整个事务队列，执行完毕后一次性返回所有指令的运行结果。 <img src="https://s2.loli.net/2023/03/27/9IMiTaQhr8pXPuv.png" alt="Redis事务"></p><p>因为Redis执行命令是单线程的，所以这组命令顺序执行，而且不会被其它线程打断。</p><p><strong>Redis事务的注意点有哪些？</strong></p><p>需要注意的点有：</p><ul><li>Redis 事务是不支持回滚的，不像 MySQL 的事务一样，要么都执行要么都不执行；</li><li>Redis 服务端在执行事务的过程中，不会被其他客户端发送来的命令请求打断。直到事务命令全部执行完毕才会执行其他客户端的命令。</li></ul><p><strong>Redis 事务为什么不支持回滚？</strong></p><p>Redis 的事务不支持回滚。</p><p>如果执行的命令有语法错误，Redis 会执行失败，这些问题可以从程序层面捕获并解决。但是如果出现其他问题，则依然会继续执行余下的命令。</p><p>这样做的原因是因为回滚需要增加很多工作，而不支持回滚则可以<strong>保持简单、快速的特性</strong>。</p><h2 id="Redis和Lua脚本的使用了解吗？"><a href="#Redis和Lua脚本的使用了解吗？" class="headerlink" title="Redis和Lua脚本的使用了解吗？"></a>Redis和Lua脚本的使用了解吗？</h2><p>Redis的事务功能比较简单，平时的开发中，可以利用Lua脚本来增强Redis的命令。</p><p>Lua脚本能给开发人员带来这些好处：</p><ul><li>Lua脚本在Redis中是原子执行的，执行过程中间不会插入其他命令。</li><li>Lua脚本可以帮助开发和运维人员创造出自己定制的命令，并可以将这 些命令常驻在Redis内存中，实现复用的效果。</li><li>Lua脚本可以将多条命令一次性打包，有效地减少网络开销。</li></ul><p>比如这一段很（烂）经（大）典（街）的秒杀系统利用lua扣减Redis库存的脚本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">-- 库存未预热</span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;exists&#x27;</span>, KEYS[<span class="number">2</span>]) == <span class="number">1</span>) then</span><br><span class="line">     <span class="keyword">return</span> -<span class="number">9</span>;</span><br><span class="line"> end;</span><br><span class="line"> -- 秒杀商品库存存在</span><br><span class="line"> <span class="keyword">if</span> (redis.call(<span class="string">&#x27;exists&#x27;</span>, KEYS[<span class="number">1</span>]) == <span class="number">1</span>) then</span><br><span class="line">     <span class="type">local</span> <span class="variable">stock</span> <span class="operator">=</span> tonumber(redis.call(<span class="string">&#x27;get&#x27;</span>, KEYS[<span class="number">1</span>]));</span><br><span class="line">     <span class="type">local</span> <span class="variable">num</span> <span class="operator">=</span> tonumber(ARGV[<span class="number">1</span>]);</span><br><span class="line">     -- 剩余库存少于请求数量</span><br><span class="line">     <span class="keyword">if</span> (stock &lt; num) then</span><br><span class="line">         <span class="keyword">return</span> -<span class="number">3</span></span><br><span class="line">     end;</span><br><span class="line">     -- 扣减库存</span><br><span class="line">     <span class="keyword">if</span> (stock &gt;= num) then</span><br><span class="line">         redis.call(<span class="string">&#x27;incrby&#x27;</span>, KEYS[<span class="number">1</span>], <span class="number">0</span> - num);</span><br><span class="line">         -- 扣减成功</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">     end;</span><br><span class="line">     <span class="keyword">return</span> -<span class="number">2</span>;</span><br><span class="line"> end;</span><br><span class="line"> -- 秒杀商品库存不存在</span><br><span class="line"> <span class="keyword">return</span> -<span class="number">1</span>;</span><br></pre></td></tr></table></figure><h2 id="Redis的管道了解吗？"><a href="#Redis的管道了解吗？" class="headerlink" title="Redis的管道了解吗？"></a>Redis的管道了解吗？</h2><p>Redis 提供三种将客户端多条命令打包发送给服务端执行的方式：</p><p>Pipelining(管道) 、 Transactions(事务) 和 Lua Scripts(Lua 脚本) 。</p><p><strong>Pipelining</strong>（管道）</p><p>Redis 管道是三者之中最简单的，当客户端需要执行多条 redis 命令时，可以通过管道一次性将要执行的多条命令发送给服务端，其作用是为了降低 RTT(Round Trip Time) 对性能的影响，比如我们使用 nc 命令将两条指令发送给 redis 服务端。</p><p>Redis 服务端接收到管道发送过来的多条命令后，会一直执命令，并将命令的执行结果进行缓存，直到最后一条命令执行完成，再所有命令的执行结果一次性返回给客户端 。 ![Pipelining示意图&#96;](<a href="https://s2.loli.net/2023/03/27/knga6AKJWVxo54B.png">https://s2.loli.net/2023/03/27/knga6AKJWVxo54B.png</a>)</p><p><strong>Pipelining的优势</strong></p><p>在性能方面， Pipelining 有下面两个优势：</p><ul><li><strong>节省了RTT</strong>：将多条命令打包一次性发送给服务端，减少了客户端与服务端之间的网络调用次数</li><li><strong>减少了上下文切换</strong>：当客户端&#x2F;服务端需要从网络中读写数据时，都会产生一次系统调用，系统调用是非常耗时的操作，其中设计到程序由用户态切换到内核态，再从内核态切换回用户态的过程。当我们执行 10 条 redis 命令的时候，就会发生 10 次用户态到内核态的上下文切换，但如果我们使用 Pipeining 将多条命令打包成一条一次性发送给服务端，就只会产生一次上下文切换。</li></ul><h2 id="Redis实现分布式锁了解吗？"><a href="#Redis实现分布式锁了解吗？" class="headerlink" title="Redis实现分布式锁了解吗？"></a>Redis实现分布式锁了解吗？</h2><p>Redis是分布式锁本质上要实现的目标就是在 Redis 里面占一个“茅坑”，当别的进程也要来占时，发现已经有人蹲在那里了，就只好放弃或者稍后再试。</p><ul><li><strong>V1：setnx命令</strong></li></ul><p>占坑一般是使用 setnx(set if not exists) 指令，只允许被一个客户端占坑。先来先占， 用完了，再调用 del 指令释放茅坑。 <img src="https://s2.loli.net/2023/03/27/be8TvNrXIJARS6F.png" alt="setnx(set if not exists)"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; setnx lock:fighter <span class="literal">true</span></span><br><span class="line">OK</span><br><span class="line">... <span class="keyword">do</span> something critical ...</span><br><span class="line">&gt; del lock:fighter</span><br><span class="line">(integer) <span class="number">1</span></span><br></pre></td></tr></table></figure><p>但是有个问题，如果逻辑执行到中间出现异常了，可能会导致 del 指令没有被调用，这样就会陷入死锁，锁永远得不到释放。</p><ul><li><strong>V2:锁超时释放</strong></li></ul><p>所以在拿到锁之后，再给锁加上一个过期时间，比如 5s，这样即使中间出现异常也可以保证 5 秒之后锁会自动释放。 <img src="https://s2.loli.net/2023/03/27/CvabPn84W3x2mVi.png" alt="锁超时释放"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; setnx lock:fighter <span class="literal">true</span></span><br><span class="line">OK</span><br><span class="line">&gt; expire lock:fighter <span class="number">5</span></span><br><span class="line">... <span class="keyword">do</span> something critical ...</span><br><span class="line">&gt; del lock:fighter</span><br><span class="line">(integer) <span class="number">1</span></span><br></pre></td></tr></table></figure><p>但是以上逻辑还有问题。如果在 setnx 和 expire 之间服务器进程突然挂掉了，可能是因为机器掉电或者是被人为杀掉的，就会导致 expire 得不到执行，也会造成死锁。</p><p>这种问题的根源就在于 setnx 和 expire 是两条指令而不是原子指令。如果这两条指令可以一起执行就不会出现问题。</p><ul><li><strong>V3:set指令</strong></li></ul><p>这个问题在Redis 2.8 版本中得到了解决，这个版本加入了 set 指令的扩展参数，使得 setnx 和expire 指令可以一起执行。 <img src="https://s2.loli.net/2023/03/27/JgadF8pOIybEwCM.png" alt="set原子指令"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set lock:fighter3 <span class="literal">true</span> ex <span class="number">5</span> nx OK ... <span class="keyword">do</span> something critical ... &gt; del lock:codehole</span><br></pre></td></tr></table></figure><p>上面这个指令就是 setnx 和 expire 组合在一起的原子指令，这个就算是比较完善的分布式锁了。</p><p>当然实际的开发，没人会去自己写分布式锁的命令，因为有专业的轮子——<strong>Redisson</strong>。</p><h1 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h1><p>这一部分就比较深了，如果不是简历上写了精通Redis，应该不会怎么问。</p><h2 id="说说Redis底层数据结构？"><a href="#说说Redis底层数据结构？" class="headerlink" title="说说Redis底层数据结构？"></a>说说Redis底层数据结构？</h2><p>Redis有<strong>动态字符串(sds)<strong>、</strong>链表(list)<strong>、</strong>字典(ht)<strong>、</strong>跳跃表(skiplist)<strong>、</strong>整数集合(intset)<strong>、</strong>压缩列表(ziplist)</strong> 等底层数据结构。</p><p>Redis并没有使用这些数据结构来直接实现键值对数据库，而是基于这些数据结构创建了一个对象系统，来表示所有的key-value。</p><p><img src="https://s2.loli.net/2023/03/27/CLe59rnBuQ2pxgI.png" alt="redisObject对应的映射"> 我们常用的数据类型和编码对应的映射关系：</p><p><img src="https://s2.loli.net/2023/03/27/TdAisu1VDoJfRNB.png" alt="类型-编码-结构"> 简单看一下底层数据结构，如果对数据结构掌握不错的话，理解这些结构应该不是特别难：</p><ol><li><p><strong>字符串</strong>：redis没有直接使⽤C语⾔传统的字符串表示，⽽是⾃⼰实现的叫做简单动态字符串SDS的抽象类型。</p><p>C语⾔的字符串不记录⾃身的⻓度信息，⽽SDS则保存了⻓度信息，这样将获取字符串⻓度的时间由O(N)降低到了O(1)，同时可以避免缓冲区溢出和减少修改字符串⻓度时所需的内存重分配次数。</p></li></ol><p><img src="https://s2.loli.net/2023/03/27/e3F1mSrh6igGvty.png" alt="SDS">SDS</p><ol><li><strong>链表linkedlist</strong>：redis链表是⼀个双向⽆环链表结构，很多发布订阅、慢查询、监视器功能都是使⽤到了链表来实现，每个链表的节点由⼀个listNode结构来表示，每个节点都有指向前置节点和后置节点的指针，同时表头节点的前置和后置节点都指向NULL。</li></ol><p><img src="https://s2.loli.net/2023/03/27/t2XCivhBQ7ed5qm.png" alt="链表linkedlist">链表linkedlist</p><ol><li><strong>字典dict</strong>：⽤于保存键值对的抽象数据结构。Redis使⽤hash表作为底层实现，一个哈希表里可以有多个哈希表节点，而每个哈希表节点就保存了字典里中的一个键值对。 每个字典带有两个hash表，供平时使⽤和rehash时使⽤，hash表使⽤链地址法来解决键冲突，被分配到同⼀个索引位置的多个键值对会形成⼀个单向链表，在对hash表进⾏扩容或者缩容的时候，为了服务的可⽤性，rehash的过程不是⼀次性完成的，⽽是渐进式的。 <img src="https://s2.loli.net/2023/03/27/2vHmqQ87sPiFLkw.png" alt="字典"></li><li><strong>跳跃表skiplist</strong>：跳跃表是有序集合的底层实现之⼀，Redis中在实现有序集合键和集群节点的内部结构中都是⽤到了跳跃表。Redis跳跃表由zskiplist和zskiplistNode组成，zskiplist⽤于保存跳跃表信息（表头、表尾节点、⻓度等），zskiplistNode⽤于表示表跳跃节点，每个跳跃表节点的层⾼都是1-32的随机数，在同⼀个跳跃表中，多个节点可以包含相同的分值，但是每个节点的成员对象必须是唯⼀的，节点按照分值⼤⼩排序，如果分值相同，则按照成员对象的⼤⼩排序。 <img src="https://s2.loli.net/2023/03/27/oQRgCXjb5Glvw4u.png" alt="跳跃表"></li><li><strong>整数集合intset</strong>：⽤于保存整数值的集合抽象数据结构，不会出现重复元素，底层实现为数组。 <img src="https://s2.loli.net/2023/03/28/dLfpeNBSoxkgObC.png" alt="整数集合intset"></li><li><strong>压缩列表ziplist</strong>：压缩列表是为节约内存⽽开发的顺序性数据结构，它可以包含任意多个节点，每个节点可以保存⼀个字节数组或者整数值。</li></ol><p><img src="https://s2.loli.net/2023/03/27/ArUWzS5s83TdJpC.png" alt="压缩列表组成"></p><center>压缩列表组成</center><h2 id="Redis-的-SDS-和-C-中字符串相比有什么优势？"><a href="#Redis-的-SDS-和-C-中字符串相比有什么优势？" class="headerlink" title="Redis 的 SDS 和 C 中字符串相比有什么优势？"></a>Redis 的 SDS 和 C 中字符串相比有什么优势？</h2><p>C 语言使用了一个长度为 <code>N+1</code> 的字符数组来表示长度为 <code>N</code> 的字符串，并且字符数组最后一个元素总是 <code>\0</code>，这种简单的字符串表示方式 不符合 Redis 对字符串在安全性、效率以及功能方面的要求。</p><p><img src="https://s2.loli.net/2023/03/27/sDpNqG92Etd5vwZ.png" alt="C语言的字符串"></p><center>C语言的字符串</center><blockquote><p><strong>C语言的字符串可能有什么问题？</strong></p></blockquote><p>这样简单的数据结构可能会造成以下一些问题：</p><ul><li><strong>获取字符串长度复杂度高</strong> ：因为 C 不保存数组的长度，每次都需要遍历一遍整个数组，时间复杂度为O(n)；</li><li>不能杜绝 <strong>缓冲区溢出&#x2F;内存泄漏</strong> 的问题 : C字符串不记录自身长度带来的另外一个问题是容易造成缓存区溢出（buffer overflow），例如在字符串拼接的时候，新的</li><li>C 字符串 <strong>只能保存文本数据</strong> → 因为 C 语言中的字符串必须符合某种编码（比如 ASCII），例如中间出现的 <code>&#39;\0&#39;</code> 可能会被判定为提前结束的字符串而识别不了；</li></ul><blockquote><p><strong>Redis如何解决？优势？</strong></p></blockquote><p><img src="https://s2.loli.net/2023/03/28/9zYriuW35SOcw2s.png" alt="Redis sds"></p><center>Redis sds</center><p>简单来说一下 Redis 如何解决的：</p><ol><li><strong>多增加 len 表示当前字符串的长度</strong>：这样就可以直接获取长度了，复杂度 O(1)；</li><li><strong>自动扩展空间</strong>：当 SDS 需要对字符串进行修改时，首先借助于 <code>len</code> 和 <code>alloc</code> 检查空间是否满足修改所需的要求，如果空间不够的话，SDS 会自动扩展空间，避免了像 C 字符串操作中的溢出情况；</li><li><strong>有效降低内存分配次数</strong>：C 字符串在涉及增加或者清除操作时会改变底层数组的大小造成重新分配，SDS 使用了 <strong>空间预分配</strong> 和 <strong>惰性空间释放</strong> 机制，简单理解就是每次在扩展时是成倍的多分配的，在缩容是也是先留着并不正式归还给 OS；</li><li><strong>二进制安全</strong>：C 语言字符串只能保存 <code>ascii</code> 码，对于图片、音频等信息无法保存，SDS 是二进制安全的，写入什么读取就是什么，不做任何过滤和限制；</li></ol><h2 id="字典是如何实现的？Rehash-了解吗？"><a href="#字典是如何实现的？Rehash-了解吗？" class="headerlink" title="字典是如何实现的？Rehash 了解吗？"></a>字典是如何实现的？Rehash 了解吗？</h2><p>字典是 Redis 服务器中出现最为频繁的复合型数据结构。除了 <strong>hash</strong> 结构的数据会用到字典外，整个 Redis 数据库的所有 <code>key</code> 和 <code>value</code> 也组成了一个 <strong>全局字典</strong>，还有带过期时间的 <code>key</code> 也是一个字典。*(存储在 RedisDb 数据结构中)*</p><blockquote><p><strong>字典结构是什么样的呢？</strong></p></blockquote><p><strong>Redis</strong> 中的字典相当于 Java 中的 <strong>HashMap</strong>，内部实现也差不多类似，采用哈希与运算计算下标位置；通过 **”数组 + 链表” *<em>的*<em>链地址法</em></em> 来解决哈希冲突，同时这样的结构也吸收了两种不同数据结构的优点。 <img src="https://s2.loli.net/2023/03/28/wjDfh7a8W3ekPct.png" alt="Redis字典结构"></p><blockquote><p><strong>字典是怎么扩容的？</strong></p></blockquote><p>字典结构内部包含 <strong>两个 hashtable</strong>，通常情况下只有一个哈希表 ht[0] 有值，在扩容的时候，把ht[0]里的值rehash到ht[1]，然后进行 <strong>渐进式rehash</strong> ——所谓渐进式rehash，指的是这个rehash的动作并不是一次性、集中式地完成的，而是分多次、渐进式地完成的。</p><p>待搬迁结束后，h[1]就取代h[0]存储字典的元素。</p><h2 id="跳跃表是如何实现的？原理？"><a href="#跳跃表是如何实现的？原理？" class="headerlink" title="跳跃表是如何实现的？原理？"></a>跳跃表是如何实现的？原理？</h2><p>PS:跳跃表是比较常问的一种结构。</p><p>跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其它节点的指针，从而达到快速访问节点的目的。 <img src="https://s2.loli.net/2023/03/28/eXB6oDwIdW1PC5f.png" alt="跳跃表"></p><blockquote><p><strong>为什么使用跳跃表?</strong></p></blockquote><p>首先，因为 zset 要支持随机的插入和删除，所以它 <strong>不宜使用数组来实现</strong>，关于排序问题，我们也很容易就想到 <strong>红黑树&#x2F; 平衡树</strong> 这样的树形结构，为什么 Redis 不使用这样一些结构呢？</p><ol><li><strong>性能考虑：</strong> 在高并发的情况下，树形结构需要执行一些类似于 rebalance 这样的可能涉及整棵树的操作，相对来说跳跃表的变化只涉及局部；</li><li><strong>实现考虑：</strong> 在复杂度与红黑树相同的情况下，跳跃表实现起来更简单，看起来也更加直观；</li></ol><p>基于以上的一些考虑，Redis 基于 <strong>William Pugh</strong> 的论文做出一些改进后采用了 <strong>跳跃表</strong> 这样的结构。</p><p>本质是解决查找问题。</p><blockquote><p><strong>跳跃表是怎么实现的？</strong></p></blockquote><p>跳跃表的节点里有这些元素：</p><ul><li><p><strong>层</strong> 跳跃表节点的level数组可以包含多个元素，每个元素都包含一个指向其它节点的指针，程序可以通过这些层来加快访问其它节点的速度，一般来说，层的数量月多，访问其它节点的速度就越快。</p><p>每次创建一个新的跳跃表节点的时候，程序都根据幂次定律，随机生成一个介于1和32之间的值作为level数组的大小，这个大小就是层的“高度”</p></li><li><p><strong>前进指针</strong> 每个层都有一个指向表尾的前进指针（level[i].forward属性），用于从表头向表尾方向访问节点。</p><p>我们看一下跳跃表从表头到表尾，遍历所有节点的路径： <img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-b153f782-e2e5-4f98-b251-04f06e16c073.png" alt="通过前进指针遍历"></p></li><li><p><strong>跨度</strong> 层的跨度用于记录两个节点之间的距离。跨度是用来计算排位（rank）的：在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位。</p><p>例如查找，分值为3.0、成员对象为o3的节点时，沿途经历的层：查找的过程只经过了一个层，并且层的跨度为3，所以目标节点在跳跃表中的排位为3。 <img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-d2395b7e-2f31-4ca8-b06d-2cb47afaeb74.png" alt="计算节点的排位"></p></li><li><p><strong>分值和成员</strong> 节点的分值（score属性）是一个double类型的浮点数，跳跃表中所有的节点都按分值从小到大来排序。</p><p>节点的成员对象（obj属性）是一个指针，它指向一个字符串对象，而字符串对象则保存这一个SDS值。</p></li></ul><h2 id="压缩列表了解吗？"><a href="#压缩列表了解吗？" class="headerlink" title="压缩列表了解吗？"></a>压缩列表了解吗？</h2><p>压缩列表是 Redis <strong>为了节约内存</strong> 而使用的一种数据结构，是由一系列特殊编码的连续内存快组成的顺序型数据结构。</p><p>一个压缩列表可以包含任意多个节点（entry），每个节点可以保存一个字节数组或者一个整数值。</p><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-6be492f7-9f92-4607-a4c4-81a612a3d7bd.png" alt="压缩列表组成部分">压缩列表由这么几部分组成：</p><ul><li><strong>zlbyttes</strong>:记录整个压缩列表占用的内存字节数</li><li><strong>zltail</strong>:记录压缩列表表尾节点距离压缩列表的起始地址有多少字节</li><li><strong>zllen</strong>:记录压缩列表包含的节点数量</li><li><strong>entryX</strong>:列表节点</li><li><strong>zlend</strong>:用于标记压缩列表的末端</li></ul><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-b5d224c2-53ee-40a3-9efc-2feb7dd3d7a8.png" alt="压缩列表示例">压缩列表示例</p><h2 id="快速列表-quicklist-了解吗？"><a href="#快速列表-quicklist-了解吗？" class="headerlink" title="快速列表 quicklist 了解吗？"></a>快速列表 quicklist 了解吗？</h2><p>Redis 早期版本存储 list 列表数据结构使用的是压缩列表 ziplist 和普通的双向链表 linkedlist，也就是说当元素少时使用 ziplist，当元素多时用 linkedlist。</p><p>但考虑到链表的附加空间相对较高，<code>prev</code> 和 <code>next</code> 指针就要占去 <code>16</code> 个字节（64 位操作系统占用 <code>8</code> 个字节），另外每个节点的内存都是单独分配，会家具内存的碎片化，影响内存管理效率。</p><p>后来 Redis 新版本（3.2）对列表数据结构进行了改造，使用 <code>quicklist</code> 代替了 <code>ziplist</code> 和 <code>linkedlist</code>，quicklist是综合考虑了时间效率与空间效率引入的新型数据结构。</p><p>quicklist由list和ziplist结合而成，它是一个由ziplist充当节点的双向链表。 <img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-3b9785b0-6573-4c2d-8b7d-d5d1be799e26.png" alt="quicklist"></p>]]></content>
      
      
      <categories>
          
          <category> 面渣逆袭 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面渣逆袭 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面渣逆袭-MyBatis</title>
      <link href="/Blog/2023/03/19/interview/%E9%9D%A2%E6%B8%A3%E9%80%86%E8%A2%AD-MyBatis/"/>
      <url>/Blog/2023/03/19/interview/%E9%9D%A2%E6%B8%A3%E9%80%86%E8%A2%AD-MyBatis/</url>
      
        <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="说说什么是MyBatis"><a href="#说说什么是MyBatis" class="headerlink" title="说说什么是MyBatis?"></a>说说什么是MyBatis?</h2><p><img src="https://s2.loli.net/2023/03/28/j7WIq9HvPDcl4Tt.png" alt="MyBatis logo"></p><center>MyBatis logo</center><p><strong>先吹一下</strong>：</p><ul><li>Mybatis 是一个半 ORM（对象关系映射）框架，它内部封装了 JDBC，开发时只需要关注 SQL 语句本身，不需要花费精力去处理加载驱动、创建连接、创建statement 等繁杂的过程。程序员直接编写原生态 sql，可以严格控制 sql 执行性能，灵活度高。</li><li>MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO 映射成数据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</li></ul><p><strong>再说一下缺点</strong></p><ul><li>SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求</li><li>SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库</li></ul><blockquote><p><strong>ORM是什么?</strong></p></blockquote><p><img src="https://s2.loli.net/2023/03/28/DIThwFMu5S1UiZy.png" alt="ORM简单示意图"></p><center>ORM简单示意图</center><ul><li>ORM（Object Relational Mapping），对象关系映射，是一种为了解决关系型数据库数据与简单Java对象（POJO）的映射关系的技术。简单来说，ORM是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系型数据库中。</li></ul><blockquote><p><strong>为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？</strong></p></blockquote><ul><li>Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。</li><li>而Mybatis在查询关联对象或关联集合对象时，需要手动编写SQL来完成，所以，被称之为半自动ORM映射工具。</li></ul><blockquote><p><strong>JDBC编程有哪些不足之处，MyBatis是如何解决的？</strong></p></blockquote><p><img src="https://s2.loli.net/2023/03/28/wgzhBUciMrZJSab.png" alt="JDBC编程的不足"></p><center>JDBC编程的不足</center><ul><li>1、数据连接创建、释放频繁造成系统资源浪费从而影响系统性能，在mybatis-config.xml中配置数据链接池，使用连接池统一管理数据库连接。</li><li>2、sql语句写在代码中造成代码不易维护，将sql语句配置在XXXXmapper.xml文件中与java代码分离。</li><li>3、向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数一一对应。Mybatis自动将java对象映射至sql语句。</li><li>4、对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比较方便。Mybatis自动将sql执行结果映射至java对象。</li></ul><h2 id="Hibernate-和-MyBatis-有什么区别？"><a href="#Hibernate-和-MyBatis-有什么区别？" class="headerlink" title="Hibernate 和 MyBatis 有什么区别？"></a>Hibernate 和 MyBatis 有什么区别？</h2><p><strong>相同点</strong></p><ul><li>都是对jdbc的封装，都是应用于持久层的框架。</li></ul><p><img src="https://s2.loli.net/2023/03/28/J8ouz7h4BDeMHIi.gif" alt="这还用说？"></p><center>这还用说？</center><p><strong>不同点</strong></p><p>1）映射关系</p><ul><li>MyBatis 是一个半自动映射的框架，配置Java对象与sql语句执行结果的对应关系，多表关联关系配置简单</li><li>Hibernate 是一个全表映射的框架，配置Java对象与数据库表的对应关系，多表关联关系配置复杂</li></ul><p>2）<strong>SQL优化和移植性</strong></p><ul><li>Hibernate 对SQL语句封装，提供了日志、缓存、级联（级联比 MyBatis 强大）等特性，此外还提供 HQL（Hibernate Query Language）操作数据库，数据库无关性支持好，但会多消耗性能。如果项目需要支持多种数据库，代码开发量少，但SQL语句优化困难。</li><li>MyBatis 需要手动编写 SQL，支持动态 SQL、处理列表、动态生成表名、支持存储过程。开发工作量相对大些。直接使用SQL语句操作数据库，不支持数据库无关性，但sql语句优化容易。</li></ul><p>3）<strong>MyBatis和Hibernate的适用场景不同</strong></p><p><img src="https://s2.loli.net/2023/03/28/hdX8ovD9jgtUkbQ.png" alt="Mybatis vs Hibernate"></p><center>Mybatis vs Hibernate</center><ul><li>Hibernate 是标准的ORM框架，SQL编写量较少，但不够灵活，适合于需求相对稳定，中小型的软件项目，比如：办公自动化系统</li><li>MyBatis 是半ORM框架，需要编写较多SQL，但是比较灵活，适合于需求变化频繁，快速迭代的项目，比如：电商网站</li></ul><h2 id="MyBatis使用过程？生命周期？"><a href="#MyBatis使用过程？生命周期？" class="headerlink" title="MyBatis使用过程？生命周期？"></a>MyBatis使用过程？生命周期？</h2><p>MyBatis基本使用的过程大概可以分为这么几步：</p><p><img src="https://s2.loli.net/2023/03/28/aACeIlvPckwJgLO.png" alt="Mybatis基本使用步骤"></p><center>Mybatis基本使用步骤</center><ul><li>1）创建SqlSessionFactory</li></ul><p>可以从配置或者直接编码来创建SqlSessionFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;org/mybatis/example/mybatis-config.xml&quot;</span>;</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br></pre></td></tr></table></figure><ul><li>2）通过SqlSessionFactory创建SqlSession</li></ul><p>SqlSession（会话）可以理解为程序和数据库之间的桥梁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br></pre></td></tr></table></figure><ul><li>3）通过sqlsession执行数据库操作</li></ul><p>可以通过 SqlSession 实例来直接执行已映射的 SQL 语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Blog</span> <span class="variable">blog</span> <span class="operator">=</span> (Blog)session.selectOne(<span class="string">&quot;org.mybatis.example.BlogMapper.selectBlog&quot;</span>, <span class="number">101</span>);</span><br></pre></td></tr></table></figure><p>更常用的方式是先获取Mapper(映射)，然后再执行SQL语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BlogMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> session.getMapper(BlogMapper.class);</span><br><span class="line"><span class="type">Blog</span> <span class="variable">blog</span> <span class="operator">=</span> mapper.selectBlog(<span class="number">101</span>);</span><br></pre></td></tr></table></figure><ul><li>4）调用session.commit()提交事务</li></ul><p>如果是更新、删除语句，我们还需要提交一下事务。</p><ul><li>5）调用session.close()关闭会话</li></ul><p>最后一定要记得关闭会话。</p><blockquote><p><strong>MyBatis生命周期？</strong></p></blockquote><p>上面提到了几个MyBatis的组件，一般说的MyBatis生命周期就是这些组件的生命周期。</p><ul><li>SqlSessionFactoryBuilder</li></ul><p>一旦创建了 SqlSessionFactory，就不再需要它了。 因此 SqlSessionFactoryBuilder 实例的生命周期只存在于方法的内部。</p><ul><li>SqlSessionFactory</li></ul><p>SqlSessionFactory 是用来创建SqlSession的，相当于一个数据库连接池，每次创建SqlSessionFactory都会使用数据库资源，多次创建和销毁是对资源的浪费。所以SqlSessionFactory是应用级的生命周期，而且应该是单例的。</p><ul><li>SqlSession</li></ul><p>SqlSession相当于JDBC中的Connection，SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的生命周期是一次请求或一个方法。</p><ul><li>Mapper</li></ul><p>映射器是一些绑定映射语句的接口。映射器接口的实例是从 SqlSession 中获得的，它的生命周期在sqlsession事务方法之内，一般会控制在方法级。</p><p><img src="https://s2.loli.net/2023/03/28/3s2lPDQYTqy7fSF.png" alt="MyBatis主要组件生命周期"></p><center>MyBatis主要组件生命周期</center><p>当然，万物皆可集成Spring，MyBatis通常也是和Spring集成使用，Spring可以帮助我们创建线程安全的、基于事务的 SqlSession 和映射器，并将它们直接注入到我们的 bean 中，我们不需要关心它们的创建过程和生命周期，那就是另外的故事了。</p><p><img src="https://s2.loli.net/2023/03/28/H3Jfx51CQBpZLVv.jpg" alt="这个应该会">这个应该会</p><h2 id="在mapper中如何传递多个参数？"><a href="#在mapper中如何传递多个参数？" class="headerlink" title="在mapper中如何传递多个参数？"></a>在mapper中如何传递多个参数？</h2><p><img src="https://s2.loli.net/2023/03/28/crmyIk6JDzsOuX9.png" alt="mapper传递多个参数方法"></p><center>mapper传递多个参数方法</center><p><strong>方法1：顺序传参法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> User <span class="title function_">selectUser</span><span class="params">(String name, <span class="type">int</span> deptId)</span>;</span><br><span class="line"></span><br><span class="line">&lt;select id=<span class="string">&quot;selectUser&quot;</span> resultMap=<span class="string">&quot;UserResultMap&quot;</span>&gt;</span><br><span class="line">    select * from user</span><br><span class="line">    <span class="type">where</span> <span class="variable">user_name</span> <span class="operator">=</span> #&#123;<span class="number">0</span>&#125; <span class="type">and</span> <span class="variable">dept_id</span> <span class="operator">=</span> #&#123;<span class="number">1</span>&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><ul><li><code>\#&#123;&#125;</code>里面的数字代表传入参数的顺序。</li><li>这种方法不建议使用，sql层表达不直观，且一旦顺序调整容易出错。</li></ul><p><strong>方法2：@Param注解传参法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> User <span class="title function_">selectUser</span><span class="params">(<span class="meta">@Param(&quot;userName&quot;)</span> String name, <span class="type">int</span> <span class="meta">@Param(&quot;deptId&quot;)</span> deptId)</span>;</span><br><span class="line"></span><br><span class="line">&lt;select id=<span class="string">&quot;selectUser&quot;</span> resultMap=<span class="string">&quot;UserResultMap&quot;</span>&gt;</span><br><span class="line">    select * from user</span><br><span class="line">    <span class="type">where</span> <span class="variable">user_name</span> <span class="operator">=</span> #&#123;userName&#125; <span class="type">and</span> <span class="variable">dept_id</span> <span class="operator">=</span> #&#123;deptId&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><ul><li><code>\#&#123;&#125;</code>里面的名称对应的是注解@Param括号里面修饰的名称。</li><li>这种方法在参数不多的情况还是比较直观的，（推荐使用）。</li></ul><p><strong>方法3：Map传参法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> User <span class="title function_">selectUser</span><span class="params">(Map&lt;String, Object&gt; params)</span>;</span><br><span class="line"></span><br><span class="line">&lt;select id=<span class="string">&quot;selectUser&quot;</span> parameterType=<span class="string">&quot;java.util.Map&quot;</span> resultMap=<span class="string">&quot;UserResultMap&quot;</span>&gt;</span><br><span class="line">    select * from user</span><br><span class="line">    <span class="type">where</span> <span class="variable">user_name</span> <span class="operator">=</span> #&#123;userName&#125; <span class="type">and</span> <span class="variable">dept_id</span> <span class="operator">=</span> #&#123;deptId&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><ul><li><code>\#&#123;&#125;</code>里面的名称对应的是Map里面的key名称。</li><li>这种方法适合传递多个参数，且参数易变能灵活传递的情况。</li></ul><p><strong>方法4：Java Bean传参法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> User <span class="title function_">selectUser</span><span class="params">(User user)</span>;</span><br><span class="line"></span><br><span class="line">&lt;select id=<span class="string">&quot;selectUser&quot;</span> parameterType=<span class="string">&quot;com.jourwon.pojo.User&quot;</span> resultMap=<span class="string">&quot;UserResultMap&quot;</span>&gt;</span><br><span class="line">    select * from user</span><br><span class="line">    <span class="type">where</span> <span class="variable">user_name</span> <span class="operator">=</span> #&#123;userName&#125; <span class="type">and</span> <span class="variable">dept_id</span> <span class="operator">=</span> #&#123;deptId&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><ul><li><code>\#&#123;&#125;</code>里面的名称对应的是User类里面的成员属性。</li><li>这种方法直观，需要建一个实体类，扩展不容易，需要加属性，但代码可读性强，业务逻辑处理方便，推荐使用。（推荐使用）。</li></ul><h2 id="实体类属性名和表中字段名不一样-，怎么办"><a href="#实体类属性名和表中字段名不一样-，怎么办" class="headerlink" title="实体类属性名和表中字段名不一样 ，怎么办?"></a>实体类属性名和表中字段名不一样 ，怎么办?</h2><ul><li>第1种： 通过在查询的SQL语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;getOrder&quot;</span> parameterType=<span class="string">&quot;int&quot;</span> resultType=<span class="string">&quot;com.jourwon.pojo.Order&quot;</span>&gt;</span><br><span class="line">       select order_id id, order_no orderno ,order_price price form orders where order_id=#&#123;id&#125;;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><ul><li>第2种： 通过resultMap 中的<result>来映射字段名和实体类属性名的一一对应的关系。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;getOrder&quot;</span> parameterType=<span class="string">&quot;int&quot;</span> resultMap=<span class="string">&quot;orderResultMap&quot;</span>&gt;</span><br><span class="line">  select * from orders where order_id=#&#123;id&#125;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br><span class="line">&lt;resultMap type=<span class="string">&quot;com.jourwon.pojo.Order&quot;</span> id=<span class="string">&quot;orderResultMap&quot;</span>&gt;</span><br><span class="line">    &lt;!–用id属性来映射主键字段–&gt;</span><br><span class="line">    &lt;id property=<span class="string">&quot;id&quot;</span> column=<span class="string">&quot;order_id&quot;</span>&gt;</span><br><span class="line">    &lt;!–用result属性来映射非主键字段，property为实体类属性名，column为数据库表中的属性–&gt;</span><br><span class="line">  &lt;<span class="type">result</span> <span class="variable">property</span> <span class="operator">=</span><span class="string">&quot;orderno&quot;</span> column =<span class="string">&quot;order_no&quot;</span>/&gt;</span><br><span class="line">  &lt;result property=<span class="string">&quot;price&quot;</span> column=<span class="string">&quot;order_price&quot;</span> /&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure><h2 id="Mybatis是否可以映射Enum枚举类？"><a href="#Mybatis是否可以映射Enum枚举类？" class="headerlink" title="Mybatis是否可以映射Enum枚举类？"></a>Mybatis是否可以映射Enum枚举类？</h2><ul><li>Mybatis当然可以映射枚举类，不单可以映射枚举类，Mybatis可以映射任何对象到表的一列上。映射方式为自定义一个TypeHandler，实现TypeHandler的setParameter()和getResult()接口方法。</li><li>TypeHandler有两个作用，一是完成从javaType至jdbcType的转换，二是完成jdbcType至javaType的转换，体现为setParameter()和getResult()两个方法，分别代表设置sql问号占位符参数和获取列查询结果。</li></ul><h2 id="和-的区别"><a href="#和-的区别" class="headerlink" title="#{}和${}的区别?"></a><code>#&#123;&#125;和$&#123;&#125;的区别</code>?</h2><p><img src="https://s2.loli.net/2023/03/28/LyzH2e6VrZk9Yv3.png" alt="img"></p><center>`#{}和${}比较`</center><ul><li><code>#&#123;&#125;</code>是占位符，预编译处理；<code>$&#123;&#125;</code>是拼接符，字符串替换，没有预编译处理。</li><li>Mybatis在处理<code>#&#123;&#125;</code>时，<code>#&#123;&#125;</code>传入参数是以字符串传入，会将SQL中的<code>#&#123;&#125;</code>替换为?号，调用PreparedStatement的set方法来赋值。</li><li><code>#&#123;&#125;</code> 可以有效的防止SQL注入，提高系统安全性；<code>$&#123;&#125;</code> 不能防止SQL 注入</li><li><code>#&#123;&#125;</code> 的变量替换是在DBMS 中；<code>$&#123;&#125;</code> 的变量替换是在 DBMS 外</li></ul><h2 id="模糊查询like语句该怎么写"><a href="#模糊查询like语句该怎么写" class="headerlink" title="模糊查询like语句该怎么写?"></a>模糊查询like语句该怎么写?</h2><p><img src="https://s2.loli.net/2023/03/28/Sqs4rfpvHlyAMK3.png" alt="concat拼接like"></p><center>concat拼接like</center><ul><li>1 ’<code>%$&#123;question&#125;%</code>’ 可能引起SQL注入，不推荐</li><li>2 <code>&quot;%&quot;#&#123;question&#125;&quot;%&quot;</code> 注意：因为<code>#&#123;…&#125;</code>解析成sql语句时候，会在变量外侧自动加单引号’ ‘，所以这里 % 需要使用双引号” “，不能使用单引号 ’ ‘，不然会查不到任何结果。</li><li>3 <code>CONCAT(&#39;%&#39;,#&#123;question&#125;,&#39;%&#39;)</code> 使用CONCAT()函数，（推荐✨）</li><li>4 使用bind标签（不推荐）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;listUserLikeUsername&quot;</span> resultType=<span class="string">&quot;com.jourwon.pojo.User&quot;</span>&gt;</span><br><span class="line">&amp;emsp;&amp;emsp;&lt;bind name=<span class="string">&quot;pattern&quot;</span> value=<span class="string">&quot;&#x27;%&#x27; + username + &#x27;%&#x27;&quot;</span> /&gt;</span><br><span class="line">&amp;emsp;&amp;emsp;select id,sex,age,username,password from person where username LIKE #&#123;pattern&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><h2 id="Mybatis能执行一对一、一对多的关联查询吗？"><a href="#Mybatis能执行一对一、一对多的关联查询吗？" class="headerlink" title="Mybatis能执行一对一、一对多的关联查询吗？"></a>Mybatis能执行一对一、一对多的关联查询吗？</h2><p>当然可以，不止支持一对一、一对多的关联查询，还支持多对多、多对一的关联查询。</p><p><img src="https://s2.loli.net/2023/03/28/qPUmodJZtwziDab.png" alt="MyBatis级联"></p><center>MyBatis级联</center><ul><li><strong>一对一<association></strong></li></ul><p>比如订单和支付是一对一的关系，这种关联的实现：</p><p>实体类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer orderId;</span><br><span class="line">    <span class="keyword">private</span> String orderDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 支付对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Pay pay;</span><br><span class="line">    <span class="comment">//……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果映射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 订单resultMap --&gt;</span><br><span class="line">&lt;resultMap id=<span class="string">&quot;peopleResultMap&quot;</span> type=<span class="string">&quot;cn.fighter3.entity.Order&quot;</span>&gt;</span><br><span class="line">    &lt;id property=<span class="string">&quot;orderId&quot;</span> column=<span class="string">&quot;order_id&quot;</span> /&gt;</span><br><span class="line">    &lt;result property=<span class="string">&quot;orderDesc&quot;</span> column=<span class="string">&quot;order_desc&quot;</span>/&gt;</span><br><span class="line">    &lt;!--一对一结果映射--&gt;</span><br><span class="line">    &lt;association property=<span class="string">&quot;pay&quot;</span> javaType=<span class="string">&quot;cn.fighter3.entity.Pay&quot;</span>&gt;</span><br><span class="line">        &lt;id column=<span class="string">&quot;payId&quot;</span> property=<span class="string">&quot;pay_id&quot;</span>/&gt;</span><br><span class="line">        &lt;result column=<span class="string">&quot;account&quot;</span> property=<span class="string">&quot;account&quot;</span>/&gt;</span><br><span class="line">    &lt;/association&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure><p>查询就是普通的关联查</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;getTeacher&quot;</span> resultMap=<span class="string">&quot;getTeacherMap&quot;</span> parameterType=<span class="string">&quot;int&quot;</span>&gt;</span><br><span class="line">    select * from order o </span><br><span class="line">     left join pay p on o.order_id=p.order_id</span><br><span class="line">    where  o.order_id=#&#123;orderId&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>一对多<code>&lt;collection&gt;</code></strong></li></ul><p>比如商品分类和商品，是一对多的关系。</p><ul><li>实体类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Category</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> categoryId;</span><br><span class="line">    <span class="keyword">private</span> String categoryName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 商品列表</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    List&lt;Product&gt; products;</span><br><span class="line">    <span class="comment">//……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>结果映射</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap type=<span class="string">&quot;Category&quot;</span> id=<span class="string">&quot;categoryBean&quot;</span>&gt;</span><br><span class="line">    &lt;id column=<span class="string">&quot;categoryId&quot;</span> property=<span class="string">&quot;category_id&quot;</span> /&gt;</span><br><span class="line">    &lt;result column=<span class="string">&quot;categoryName&quot;</span> property=<span class="string">&quot;category_name&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 一对多的关系 --&gt;</span><br><span class="line">    &lt;!-- property: 指的是集合属性的值, ofType：指的是集合中元素的类型 --&gt;</span><br><span class="line">    &lt;collection property=<span class="string">&quot;products&quot;</span> ofType=<span class="string">&quot;Product&quot;</span>&gt;</span><br><span class="line">        &lt;id column=<span class="string">&quot;product_id&quot;</span> property=<span class="string">&quot;productId&quot;</span> /&gt;</span><br><span class="line">        &lt;result column=<span class="string">&quot;productName&quot;</span> property=<span class="string">&quot;productName&quot;</span> /&gt;</span><br><span class="line">        &lt;result column=<span class="string">&quot;price&quot;</span> property=<span class="string">&quot;price&quot;</span> /&gt;</span><br><span class="line">    &lt;/collection&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure><ul><li>查询</li></ul><p>查询就是一个普通的关联查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 关联查询分类和产品表 --&gt;</span><br><span class="line">&lt;select id=<span class="string">&quot;listCategory&quot;</span> resultMap=<span class="string">&quot;categoryBean&quot;</span>&gt;</span><br><span class="line">    select c.*, p.* from category_ c left join product_ p on c.id = p.cid</span><br><span class="line">&lt;/select&gt;  </span><br></pre></td></tr></table></figure><p> 那么多对一、多对多怎么实现呢？还是利用<association>和<collection>，篇幅所限，这里就不展开了。</p><h2 id="Mybatis是否支持延迟加载？原理？"><a href="#Mybatis是否支持延迟加载？原理？" class="headerlink" title="Mybatis是否支持延迟加载？原理？"></a>Mybatis是否支持延迟加载？原理？</h2><ul><li>Mybatis支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled&#x3D;true|false。</li><li>它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</li><li>当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。</li></ul><h2 id="如何获取生成的主键"><a href="#如何获取生成的主键" class="headerlink" title="如何获取生成的主键?"></a>如何获取生成的主键?</h2><ul><li>新增标签中添加：keyProperty&#x3D;” ID “ 即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=<span class="string">&quot;insert&quot;</span> useGeneratedKeys=<span class="string">&quot;true&quot;</span> keyProperty=<span class="string">&quot;userId&quot;</span> &gt;</span><br><span class="line">    insert into <span class="title function_">user</span><span class="params">( </span></span><br><span class="line"><span class="params">    user_name, user_password, create_time)</span> </span><br><span class="line">    values(#&#123;userName&#125;, #&#123;userPassword&#125; , #&#123;createTime, jdbcType= TIMESTAMP&#125;)</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure><ul><li>这时候就可以完成回填主键</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mapper.insert(user);</span><br><span class="line">user.getId;</span><br></pre></td></tr></table></figure><h2 id="MyBatis支持动态SQL吗？"><a href="#MyBatis支持动态SQL吗？" class="headerlink" title="MyBatis支持动态SQL吗？"></a>MyBatis支持动态SQL吗？</h2><p>MyBatis中有一些支持动态SQL的标签，它们的原理是使用OGNL从SQL参数对象中计算表达式的值，根据表达式的值动态拼接SQL，以此来完成动态SQL的功能。</p><p><img src="https://s2.loli.net/2023/03/28/Zn2k5AKiu4a8PoI.png" alt="MyBatis"></p><center>MyBatis</center><ul><li>if</li></ul><p>根据条件来组成where子句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;findActiveBlogWithTitleLike&quot;</span></span><br><span class="line">   resultType=<span class="string">&quot;Blog&quot;</span>&gt;</span><br><span class="line">SELECT * FROM BLOG</span><br><span class="line"><span class="type">WHERE</span> <span class="variable">state</span> <span class="operator">=</span> ‘ACTIVE’</span><br><span class="line">&lt;<span class="keyword">if</span> test=<span class="string">&quot;title != null&quot;</span>&gt;</span><br><span class="line">  AND title like #&#123;title&#125;</span><br><span class="line">&lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><ul><li>choose (when, otherwise)</li></ul><p>这个和Java 中的 switch 语句有点像</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;findActiveBlogLike&quot;</span></span><br><span class="line">   resultType=<span class="string">&quot;Blog&quot;</span>&gt;</span><br><span class="line">SELECT * FROM BLOG <span class="type">WHERE</span> <span class="variable">state</span> <span class="operator">=</span> ‘ACTIVE’</span><br><span class="line">&lt;choose&gt;</span><br><span class="line">  &lt;when test=<span class="string">&quot;title != null&quot;</span>&gt;</span><br><span class="line">    AND title like #&#123;title&#125;</span><br><span class="line">  &lt;/when&gt;</span><br><span class="line">  &lt;when test=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span><br><span class="line">    AND author_name like #&#123;author.name&#125;</span><br><span class="line">  &lt;/when&gt;</span><br><span class="line">  &lt;otherwise&gt;</span><br><span class="line">    <span class="type">AND</span> <span class="variable">featured</span> <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">  &lt;/otherwise&gt;</span><br><span class="line">&lt;/choose&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><ul><li>trim (where, set)</li><li><where>可以用在所有的查询条件都是动态的情况</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;findActiveBlogLike&quot;</span></span><br><span class="line">   resultType=<span class="string">&quot;Blog&quot;</span>&gt;</span><br><span class="line">SELECT * FROM BLOG</span><br><span class="line">&lt;where&gt;</span><br><span class="line">  &lt;<span class="keyword">if</span> test=<span class="string">&quot;state != null&quot;</span>&gt;</span><br><span class="line">       state = #&#123;state&#125;</span><br><span class="line">  &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">if</span> test=<span class="string">&quot;title != null&quot;</span>&gt;</span><br><span class="line">      AND title like #&#123;title&#125;</span><br><span class="line">  &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">if</span> test=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span><br><span class="line">      AND author_name like #&#123;author.name&#125;</span><br><span class="line">  &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">&lt;/where&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><ul><li><set> 可以用在动态更新的时候</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;update id=<span class="string">&quot;updateAuthorIfNecessary&quot;</span>&gt;</span><br><span class="line">  update Author</span><br><span class="line">    &lt;set&gt;</span><br><span class="line">      &lt;<span class="keyword">if</span> test=<span class="string">&quot;username != null&quot;</span>&gt;username=#&#123;username&#125;,&lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">      &lt;<span class="keyword">if</span> test=<span class="string">&quot;password != null&quot;</span>&gt;password=#&#123;password&#125;,&lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">      &lt;<span class="keyword">if</span> test=<span class="string">&quot;email != null&quot;</span>&gt;email=#&#123;email&#125;,&lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">      &lt;<span class="keyword">if</span> test=<span class="string">&quot;bio != null&quot;</span>&gt;bio=#&#123;bio&#125;&lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">    &lt;/set&gt;</span><br><span class="line">  where id=#&#123;id&#125;</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure><ul><li><p>foreach</p><p>看到名字就知道了，这个是用来循环的，可以对集合进行遍历</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;selectPostIn&quot;</span> resultType=<span class="string">&quot;domain.blog.Post&quot;</span>&gt;</span><br><span class="line">SELECT *</span><br><span class="line">FROM POST P</span><br><span class="line">&lt;where&gt;</span><br><span class="line">  &lt;foreach item=<span class="string">&quot;item&quot;</span> index=<span class="string">&quot;index&quot;</span> collection=<span class="string">&quot;list&quot;</span></span><br><span class="line">      open=<span class="string">&quot;ID in (&quot;</span> separator=<span class="string">&quot;,&quot;</span> close=<span class="string">&quot;)&quot;</span> nullable=<span class="string">&quot;true&quot;</span>&gt;</span><br><span class="line">        #&#123;item&#125;</span><br><span class="line">  &lt;/foreach&gt;</span><br><span class="line">&lt;/where&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><h2 id="MyBatis如何执行批量操作？"><a href="#MyBatis如何执行批量操作？" class="headerlink" title="MyBatis如何执行批量操作？"></a>MyBatis如何执行批量操作？</h2><p><img src="https://s2.loli.net/2023/03/28/8U1YjHG3Ip2vLVz.png" alt="MyBatis批量操作"></p><center>MyBatis批量操作</center><p><strong>第一种方法：使用foreach标签</strong></p><p>foreach的主要用在构建in条件中，它可以在SQL语句中进行迭代一个集合。foreach标签的属性主要有item，index，collection，open，separator，close。</p><ul><li>item   表示集合中每一个元素进行迭代时的别名，随便起的变量名；</li><li>index   指定一个名字，用于表示在迭代过程中，每次迭代到的位置，不常用；</li><li>open   表示该语句以什么开始，常用“(”；</li><li>separator 表示在每次进行迭代之间以什么符号作为分隔符，常用“,”；</li><li>close   表示以什么结束，常用“)”。</li></ul><p>在使用foreach的时候最关键的也是最容易出错的就是collection属性，该属性是必须指定的，但是在不同情况下，该属性的值是不一样的，主要有以下3种情况：</p><ol><li>如果传入的是单参数且参数类型是一个List的时候，collection属性值为list</li><li>如果传入的是单参数且参数类型是一个array数组的时候，collection的属性值为array</li><li>如果传入的参数是多个的时候，我们就需要把它们封装成一个Map了，当然单参数也可以封装成map，实际上如果你在传入参数的时候，在MyBatis里面也是会把它封装成一个Map的，map的key就是参数名，所以这个时候collection属性值就是传入的List或array对象在自己封装的map里面的key</li></ol><p>看看批量保存的两种用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- MySQL下批量保存，可以foreach遍历 mysql支持values(),(),()语法 --&gt; <span class="comment">//推荐使用</span></span><br><span class="line">&lt;insert id=<span class="string">&quot;addEmpsBatch&quot;</span>&gt;</span><br><span class="line">    INSERT INTO <span class="title function_">emp</span><span class="params">(ename,gender,email,did)</span></span><br><span class="line">    VALUES</span><br><span class="line">    &lt;foreach collection=<span class="string">&quot;emps&quot;</span> item=<span class="string">&quot;emp&quot;</span> separator=<span class="string">&quot;,&quot;</span>&gt;</span><br><span class="line">        (#&#123;emp.eName&#125;,#&#123;emp.gender&#125;,#&#123;emp.email&#125;,#&#123;emp.dept.id&#125;)</span><br><span class="line">    &lt;/foreach&gt;</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 这种方式需要数据库连接属性allowMutiQueries=<span class="literal">true</span>的支持</span><br><span class="line"> 如jdbc.url=jdbc:mysql:<span class="comment">//localhost:3306/mybatis?allowMultiQueries=true --&gt;  </span></span><br><span class="line">&lt;insert id=<span class="string">&quot;addEmpsBatch&quot;</span>&gt;</span><br><span class="line">    &lt;foreach collection=<span class="string">&quot;emps&quot;</span> item=<span class="string">&quot;emp&quot;</span> separator=<span class="string">&quot;;&quot;</span>&gt;                                 </span><br><span class="line">        INSERT INTO <span class="title function_">emp</span><span class="params">(ename,gender,email,did)</span></span><br><span class="line">        VALUES(#&#123;emp.eName&#125;,#&#123;emp.gender&#125;,#&#123;emp.email&#125;,#&#123;emp.dept.id&#125;)</span><br><span class="line">    &lt;/foreach&gt;</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure><p><strong>第二种方法：使用ExecutorType.BATCH</strong></p><ul><li>Mybatis内置的ExecutorType有3种，默认为simple，该模式下它为每个语句的执行创建一个新的预处理语句，单条提交sql；而batch模式重复使用已经预处理的语句，并且批量执行所有更新语句，显然batch性能将更优； 但batch模式也有自己的问题，比如在Insert操作时，在事务没有提交之前，是没有办法获取到自增的id，在某些情况下不符合业务的需求。</li></ul><p>具体用法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//批量保存方法测试</span></span><br><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBatch</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> getSqlSessionFactory();</span><br><span class="line">    <span class="comment">//可以执行批量操作的sqlSession</span></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">openSession</span> <span class="operator">=</span> sqlSessionFactory.openSession(ExecutorType.BATCH);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//批量保存执行前时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">EmployeeMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> openSession.getMapper(EmployeeMapper.class);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            mapper.addEmp(<span class="keyword">new</span> <span class="title class_">Employee</span>(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">5</span>), <span class="string">&quot;b&quot;</span>, <span class="string">&quot;1&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        openSession.commit();</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//批量保存执行后的时间</span></span><br><span class="line">        System.out.println(<span class="string">&quot;执行时长&quot;</span> + (end - start));</span><br><span class="line">        <span class="comment">//批量 预编译sql一次==》设置参数==》10000次==》执行1次   677</span></span><br><span class="line">        <span class="comment">//非批量  （预编译=设置参数=执行 ）==》10000次   1121</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        openSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>mapper和mapper.xml如下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EmployeeMapper</span> &#123;   </span><br><span class="line">    <span class="comment">//批量保存员工</span></span><br><span class="line">    Long <span class="title function_">addEmp</span><span class="params">(Employee employee)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;mapper namespace=<span class="string">&quot;com.jourwon.mapper.EmployeeMapper&quot;</span></span><br><span class="line">     &lt;!--批量保存员工 --&gt;</span><br><span class="line">    &lt;insert id=<span class="string">&quot;addEmp&quot;</span>&gt;</span><br><span class="line">        insert into <span class="title function_">employee</span><span class="params">(lastName,email,gender)</span></span><br><span class="line">        values(#&#123;lastName&#125;,#&#123;email&#125;,#&#123;gender&#125;)</span><br><span class="line">    &lt;/insert&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><h2 id="说说Mybatis的一级、二级缓存？"><a href="#说说Mybatis的一级、二级缓存？" class="headerlink" title="说说Mybatis的一级、二级缓存？"></a>说说Mybatis的一级、二级缓存？</h2><ol><li>一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为SqlSession，各个SqlSession之间的缓存相互隔离，当 Session flush 或 close 之后，该 SqlSession 中的所有 Cache 就将清空，MyBatis默认打开一级缓存。</li></ol><p><img src="https://s2.loli.net/2023/03/28/FNshEWn8oUiIgSG.png" alt="Mybatis一级缓存"></p><center>Mybatis一级缓存</center><ol start="2"><li>二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同之处在于其存储作用域为 Mapper(Namespace)，可以在多个SqlSession之间共享，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置。</li></ol><p><img src="https://s2.loli.net/2023/03/28/VWYucjSxM6bLnvE.png" alt="Mybatis二级缓存示意图"></p><center>Mybatis二级缓存示意图</center><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="能说说MyBatis的工作原理吗？"><a href="#能说说MyBatis的工作原理吗？" class="headerlink" title="能说说MyBatis的工作原理吗？"></a>能说说MyBatis的工作原理吗？</h2><p>我们已经大概知道了MyBatis的工作流程，按工作原理，可以分为两大步：<code>生成会话工厂</code>、<code>会话运行</code>。</p><p><img src="https://s2.loli.net/2023/03/28/m34DNnrSsF2ipR7.png" alt="MyBatis的工作流程"></p><center>MyBatis的工作流程</center><p>MyBatis是一个成熟的框架，篇幅限制，这里抓大放小，来看看它的主要工作流程。</p><blockquote><p><strong>构建会话工厂</strong></p></blockquote><p>构造会话工厂也可以分为两步：</p><p><img src="https://s2.loli.net/2023/03/28/z6GYaPViMd9jRb2.png" alt="构建会话工厂"></p><center>构建会话工厂</center><ul><li>获取配置</li></ul><p>获取配置这一步经过了几步转化，最终由生成了一个配置类Configuration实例，这个配置类实例非常重要，主要作用包括：</p><ul><li>读取配置文件，包括基础配置文件和映射文件</li><li>初始化基础配置，比如MyBatis的别名，还有其它的一些重要的类对象，像插件、映射器、ObjectFactory等等</li><li>提供一个单例，作为会话工厂构建的重要参数</li><li>它的构建过程也会初始化一些环境变量，比如数据源</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> SqlSessionFactory <span class="title function_">build</span><span class="params">(Reader reader, String environment, Properties properties)</span> &#123;</span><br><span class="line">      SqlSessionFactory var5;</span><br><span class="line">      <span class="comment">//省略异常处理</span></span><br><span class="line">          <span class="comment">//xml配置构建器</span></span><br><span class="line">          <span class="type">XMLConfigBuilder</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLConfigBuilder</span>(reader, environment, properties);</span><br><span class="line">          <span class="comment">//通过转化的Configuration构建SqlSessionFactory</span></span><br><span class="line">          var5 = <span class="built_in">this</span>.build(parser.parse());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>构建SqlSessionFactory</li></ul><p>SqlSessionFactory只是一个接口，构建出来的实际上是它的实现类的实例，一般我们用的都是它的实现类DefaultSqlSessionFactory，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> SqlSessionFactory <span class="title function_">build</span><span class="params">(Configuration config)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultSqlSessionFactory</span>(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>会话运行</strong></p></blockquote><p>会话运行是MyBatis最复杂的部分，它的运行离不开四大组件的配合：</p><p><img src="https://s2.loli.net/2023/03/28/d4cpTl31szjeoDf.png" alt="MyBatis会话运行四大关键组件"></p><center>MyBatis会话运行四大关键组件</center><ul><li>Executor（执行器）</li></ul><p>Executor起到了至关重要的作用，SqlSession只是一个门面，相当于客服，真正干活的是是Executor，就像是默默无闻的工程师。它提供了相应的查询和更新方法，以及事务方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Environment</span> <span class="variable">environment</span> <span class="operator">=</span> <span class="built_in">this</span>.configuration.getEnvironment();</span><br><span class="line"><span class="type">TransactionFactory</span> <span class="variable">transactionFactory</span> <span class="operator">=</span> <span class="built_in">this</span>.getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line"><span class="comment">//通过Configuration创建executor</span></span><br><span class="line"><span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="built_in">this</span>.configuration.newExecutor(tx, execType);</span><br><span class="line">var8 = <span class="keyword">new</span> <span class="title class_">DefaultSqlSession</span>(<span class="built_in">this</span>.configuration, executor, autoCommit);</span><br></pre></td></tr></table></figure><ul><li>StatementHandler（数据库会话器）</li></ul><p>StatementHandler，顾名思义，处理数据库会话的。我们以SimpleExecutor为例，看一下它的查询方法，先生成了一个StatementHandler实例，再拿这个handler去执行query。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    List var9;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> ms.getConfiguration();</span><br><span class="line">        <span class="type">StatementHandler</span> <span class="variable">handler</span> <span class="operator">=</span> configuration.newStatementHandler(<span class="built_in">this</span>.wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        stmt = <span class="built_in">this</span>.prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">        var9 = handler.query(stmt, resultHandler);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.closeStatement(stmt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var9;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再以最常用的PreparedStatementHandler看一下它的query方法，其实在上面的<code>prepareStatement</code>已经对参数进行了预编译处理，到了这里，就直接执行sql，使用ResultHandler处理返回结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> (PreparedStatement)statement;</span><br><span class="line">    ps.execute();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.resultSetHandler.handleResultSets(ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ParameterHandler （参数处理器）</li></ul><p>PreparedStatementHandler里对sql进行了预编译处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parameterize</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="built_in">this</span>.parameterHandler.setParameters((PreparedStatement)statement);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用的就是ParameterHandler，setParameters的作用就是设置预编译SQL语句的参数。</p><p>里面还会用到typeHandler类型处理器，对类型进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ParameterHandler</span> &#123;</span><br><span class="line">    Object <span class="title function_">getParameterObject</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setParameters</span><span class="params">(PreparedStatement var1)</span> <span class="keyword">throws</span> SQLException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>ResultSetHandler（结果处理器）</p><p>我们前面也看到了，最后的结果要通过ResultSetHandler来进行处理，handleResultSets这个方法就是用来包装结果集的。Mybatis为我们提供了一个DefaultResultSetHandler，通常都是用这个实现类去进行结果的处理的。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ResultSetHandler</span> &#123;</span><br><span class="line">  &lt;E&gt; List&lt;E&gt; <span class="title function_">handleResultSets</span><span class="params">(Statement var1)</span> <span class="keyword">throws</span> SQLException;</span><br><span class="line"></span><br><span class="line">  &lt;E&gt; Cursor&lt;E&gt; <span class="title function_">handleCursorResultSets</span><span class="params">(Statement var1)</span> <span class="keyword">throws</span> SQLException;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">handleOutputParameters</span><span class="params">(CallableStatement var1)</span> <span class="keyword">throws</span> SQLException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它会使用typeHandle处理类型，然后用ObjectFactory提供的规则组装对象，返回给调用者。</p><p>整体上总结一下会话运行：</p><p><img src="https://s2.loli.net/2023/03/28/gUHp8nFLlKmq2ab.png" alt="会话运行的简单示意图"></p><center>会话运行的简单示意图</center><blockquote><p>我们最后把整个的工作流程串联起来，简单总结一下：</p></blockquote><p><img src="https://s2.loli.net/2023/03/28/KW8ExGfe4oPjyVQ.png" alt="MyBatis整体工作原理图"></p><center>MyBatis整体工作原理图</center><ol><li>读取 MyBatis 配置文件——mybatis-config.xml 、加载映射文件——映射文件即 SQL 映射文件，文件中配置了操作数据库的 SQL 语句。最后生成一个配置对象。</li><li>构造会话工厂：通过 MyBatis 的环境等配置信息构建会话工厂 SqlSessionFactory。</li><li>创建会话对象：由会话工厂创建 SqlSession 对象，该对象中包含了执行 SQL 语句的所有方法。</li><li>Executor 执行器：MyBatis 底层定义了一个 Executor 接口来操作数据库，它将根据 SqlSession 传递的参数动态地生成需要执行的 SQL 语句，同时负责查询缓存的维护。</li><li>StatementHandler：数据库会话器，串联起参数映射的处理和运行结果映射的处理。</li><li>参数处理：对输入参数的类型进行处理，并预编译。</li><li>结果处理：对返回结果的类型进行处理，根据对象映射规则，返回相应的对象。</li></ol><h2 id="MyBatis的功能架构是什么样的？"><a href="#MyBatis的功能架构是什么样的？" class="headerlink" title="MyBatis的功能架构是什么样的？"></a>MyBatis的功能架构是什么样的？</h2><p><img src="https://s2.loli.net/2023/03/28/f95OsVCqQaJlFMv.png" alt="MyBatis功能架构"></p><center>MyBatis功能架构</center><p>我们一般把Mybatis的功能架构分为三层：</p><ul><li>API接口层：提供给外部使用的接口API，开发人员通过这些本地API来操纵数据库。接口层一接收到调用请求就会调用数据处理层来完成具体的数据处理。</li><li>数据处理层：负责具体的SQL查找、SQL解析、SQL执行和执行结果映射处理等。它主要的目的是根据调用的请求完成一次数据库操作。</li><li>基础支撑层：负责最基础的功能支撑，包括连接管理、事务管理、配置加载和缓存处理，这些都是共用的东西，将他们抽取出来作为最基础的组件。为上层的数据处理层提供最基础的支撑。</li></ul><h2 id="为什么Mapper接口不需要实现类？"><a href="#为什么Mapper接口不需要实现类？" class="headerlink" title="为什么Mapper接口不需要实现类？"></a>为什么Mapper接口不需要实现类？</h2><p>四个字回答：<strong>动态代理</strong>，我们来看一下获取Mapper的过程：</p><p><img src="https://s2.loli.net/2023/03/28/yYhaK7lGBcAvCSM.png" alt="Mapper代理"></p><center>Mapper代理</center><ul><li>获取Mapper</li></ul><p>我们都知道定义的Mapper接口是没有实现类的，Mapper映射其实是通过<strong>动态代理</strong>实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BlogMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> session.getMapper(BlogMapper.class);</span><br></pre></td></tr></table></figure><p>七拐八绕地进去看一下，发现获取Mapper的过程，需要先获取MapperProxyFactory——Mapper代理工厂。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> &#123;</span><br><span class="line">    MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory)<span class="built_in">this</span>.knownMappers.get(type);</span><br><span class="line">    <span class="keyword">if</span> (mapperProxyFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BindingException</span>(<span class="string">&quot;Type &quot;</span> + type + <span class="string">&quot; is not known to the MapperRegistry.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BindingException</span>(<span class="string">&quot;Error getting mapper instance. Cause: &quot;</span> + var5, var5);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>MapperProxyFactory</li></ul><p>MapperProxyFactory的作用是生成MapperProxy（Mapper代理对象）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperProxyFactory</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line">  ……</span><br><span class="line">  <span class="keyword">protected</span> T <span class="title function_">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> Proxy.newProxyInstance(<span class="built_in">this</span>.mapperInterface.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;<span class="built_in">this</span>.mapperInterface&#125;, mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> T <span class="title function_">newInstance</span><span class="params">(SqlSession sqlSession)</span> &#123;</span><br><span class="line">      MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> <span class="title class_">MapperProxy</span>(sqlSession, <span class="built_in">this</span>.mapperInterface, <span class="built_in">this</span>.methodCache);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.newInstance(mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到动态代理对接口的绑定，它的作用就是生成动态代理对象（占位），而代理的方法被放到了MapperProxy中。</p><ul><li>MapperProxy</li></ul><p>MapperProxy里，通常会生成一个MapperMethod对象，它是通过cachedMapperMethod方法对其进行初始化的，然后执行excute方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Object.class.equals(method.getDeclaringClass()) ? method.invoke(<span class="built_in">this</span>, args) : <span class="built_in">this</span>.cachedInvoker(method).invoke(proxy, method, args, <span class="built_in">this</span>.sqlSession);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var5) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(var5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>MapperMethod</li></ul><p>MapperMethod里的excute方法，会真正去执行sql。这里用到了命令模式，其实绕一圈，最终它还是通过SqlSession的实例去运行对象的sql。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">execute</span><span class="params">(SqlSession sqlSession, Object[] args)</span> &#123;</span><br><span class="line">      Object result;</span><br><span class="line">      Object param;</span><br><span class="line">      ……</span><br><span class="line">      <span class="keyword">case</span> SELECT:</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">this</span>.method.returnsVoid() &amp;&amp; <span class="built_in">this</span>.method.hasResultHandler()) &#123;</span><br><span class="line">              <span class="built_in">this</span>.executeWithResultHandler(sqlSession, args);</span><br><span class="line">              result = <span class="literal">null</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.method.returnsMany()) &#123;</span><br><span class="line">              result = <span class="built_in">this</span>.executeForMany(sqlSession, args);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.method.returnsMap()) &#123;</span><br><span class="line">              result = <span class="built_in">this</span>.executeForMap(sqlSession, args);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.method.returnsCursor()) &#123;</span><br><span class="line">              result = <span class="built_in">this</span>.executeForCursor(sqlSession, args);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              param = <span class="built_in">this</span>.method.convertArgsToSqlCommandParam(args);</span><br><span class="line">              result = sqlSession.selectOne(<span class="built_in">this</span>.command.getName(), param);</span><br><span class="line">              <span class="keyword">if</span> (<span class="built_in">this</span>.method.returnsOptional() &amp;&amp; (result == <span class="literal">null</span> || !<span class="built_in">this</span>.method.getReturnType().equals(result.getClass()))) &#123;</span><br><span class="line">                  result = Optional.ofNullable(result);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">         ……</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="Mybatis都有哪些Executor执行器？"><a href="#Mybatis都有哪些Executor执行器？" class="headerlink" title="Mybatis都有哪些Executor执行器？"></a>Mybatis都有哪些Executor执行器？</h2><p><img src="https://s2.loli.net/2023/03/28/XUqY7QiK4fPZsbw.png" alt="Mybatis Executor类型"></p><center>Mybatis Executor类型</center><p>Mybatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。</p><ul><li><strong>SimpleExecutor</strong>：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。</li><li><strong>ReuseExecutor</strong>：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用Statement对象。</li><li><strong>BatchExecutor</strong>：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。</li></ul><p>作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内。</p><blockquote><p><strong>Mybatis中如何指定使用哪一种Executor执行器？</strong></p></blockquote><ul><li>在Mybatis配置文件中，在设置（settings）可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数，如<code>SqlSession openSession(ExecutorType execType)</code>。</li><li>配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（prepared statements）； BATCH 执行器将重用语句并执行批量更新。</li></ul><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><h2 id="说说Mybatis的插件运行原理，如何编写一个插件？"><a href="#说说Mybatis的插件运行原理，如何编写一个插件？" class="headerlink" title="说说Mybatis的插件运行原理，如何编写一个插件？"></a>说说Mybatis的插件运行原理，如何编写一个插件？</h2><blockquote><p><strong>插件的运行原理？</strong></p></blockquote><p>Mybatis会话的运行需要ParameterHandler、ResultSetHandler、StatementHandler、Executor这四大对象的配合，插件的原理就是在这四大对象调度的时候，插入一些我我们自己的代码。</p><p><img src="https://s2.loli.net/2023/03/28/Vl9iUOEBzXfThLe.png" alt="MyBatis插件原理简图"></p><center>MyBatis插件原理简图</center><p>Mybatis使用JDK的动态代理，为目标对象生成代理对象。它提供了一个工具类<code>Plugin</code>，实现了<code>InvocationHandler</code>接口。</p><p><img src="https://s2.loli.net/2023/03/28/9lPEKRg6zOIq5Yy.png" alt="Plugin中调用插件方法"></p><center>Plugin中调用插件方法</center><p>使用<code>Plugin</code>生成代理对象，代理对象在调用方法的时候，就会进入invoke方法，在invoke方法中，如果存在签名的拦截方法，插件的intercept方法就会在这里被我们调用，然后就返回结果。如果不存在签名方法，那么将直接反射调用我们要执行的方法。</p><blockquote><p><strong>如何编写一个插件？</strong></p></blockquote><p>我们自己编写MyBatis 插件，只需要实现拦截器接口 <code>Interceptor (org.apache.ibatis. plugin Interceptor ）</code>，在实现类中对拦截对象和方法进行处理。</p><ul><li>实现Mybatis的Interceptor接口并重写intercept()方法</li></ul><p>这里我们只是在目标对象执行目标方法的前后进行了打印；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterceptor</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line">    Properties props=<span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before……&quot;</span>);</span><br><span class="line">        <span class="comment">//如果当前代理的是一个非代理对象，那么就会调用真实拦截对象的方法</span></span><br><span class="line">        <span class="comment">// 如果不是它就会调用下个插件代理对象的invoke方法</span></span><br><span class="line">        Object obj=invocation.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;after……&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>然后再给插件编写注解，确定要拦截的对象，要拦截的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts(&#123;@Signature(</span></span><br><span class="line"><span class="meta">        type = Executor.class,  //确定要拦截的对象</span></span><br><span class="line"><span class="meta">        method = &quot;update&quot;,        //确定要拦截的方法</span></span><br><span class="line"><span class="meta">        args = &#123;MappedStatement.class,Object.class&#125;   //拦截方法的参数</span></span><br><span class="line"><span class="meta">)&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterceptor</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line">    Properties props=<span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before……&quot;</span>);</span><br><span class="line">        <span class="comment">//如果当前代理的是一个非代理对象，那么就会调用真实拦截对象的方法</span></span><br><span class="line">        <span class="comment">// 如果不是它就会调用下个插件代理对象的invoke方法</span></span><br><span class="line">        Object obj=invocation.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;after……&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最后，再MyBatis配置文件里面配置插件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugins&gt;</span><br><span class="line">    &lt;plugin interceptor=<span class="string">&quot;xxx.MyPlugin&quot;</span>&gt;</span><br><span class="line">       &lt;property name=<span class="string">&quot;dbType&quot;</span>,value=<span class="string">&quot;mysql&quot;</span>/&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;    </span><br></pre></td></tr></table></figure><h2 id="MyBatis是如何进行分页的？分页插件的原理是什么？"><a href="#MyBatis是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="MyBatis是如何进行分页的？分页插件的原理是什么？"></a>MyBatis是如何进行分页的？分页插件的原理是什么？</h2><blockquote><p><strong>MyBatis是如何分页的？</strong></p></blockquote><p>MyBatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页。可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</p><blockquote><p><strong>分页插件的原理是什么？</strong></p></blockquote><ul><li>分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，拦截Executor的query方法</li><li>在执行查询的时候，拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。</li><li>举例：<code>select * from student</code>，拦截sql后重写为：<code>select t.* from (select * from student) t limit 0, 10</code></li></ul><p>可以看一下一个大概的MyBatis通用分页拦截器：</p><p><img src="https://s2.loli.net/2023/03/28/VCWOwJslor4fqkY.png" alt="Mybatis-通用分页拦截器"></p><center>Mybatis-通用分页拦截器</center>]]></content>
      
      
      <categories>
          
          <category> 面渣逆袭 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面渣逆袭 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面渣逆袭-MySQL</title>
      <link href="/Blog/2023/03/18/interview/%E9%9D%A2%E6%B8%A3%E9%80%86%E8%A2%AD-MySQL/"/>
      <url>/Blog/2023/03/18/interview/%E9%9D%A2%E6%B8%A3%E9%80%86%E8%A2%AD-MySQL/</url>
      
        <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p><img src="https://s2.loli.net/2023/03/28/psbLerMTBXdzSRO.png" alt="img"></p><p>作为 SQL Boy，基础部分不会有人不会吧？面试也不怎么问，基础掌握不错的小伙伴可以<strong>跳过</strong>这一部分。当然，可能会现场写一些 SQL 语句，SQ 语句可以通过牛客、LeetCode、LintCode 之类的网站来练习。</p><h2 id="什么是内连接、外连接、交叉连接、笛卡尔积呢？"><a href="#什么是内连接、外连接、交叉连接、笛卡尔积呢？" class="headerlink" title="什么是内连接、外连接、交叉连接、笛卡尔积呢？"></a>什么是内连接、外连接、交叉连接、笛卡尔积呢？</h2><ul><li>内连接（inner join）：取得两张表中满足存在连接匹配关系的记录。</li><li>外连接（outer join）：不只取得两张表中满足存在连接匹配关系的记录，还包括某张表（或两张表）中不满足匹配关系的记录。</li><li>交叉连接（cross join）：显示两张表所有记录一一对应，没有匹配关系进行筛选，它是笛卡尔积在 SQL 中的实现，如果 A 表有 m 行，B 表有 n 行，那么 A 和 B 交叉连接的结果就有 m*n 行。</li><li>笛卡尔积：是数学中的一个概念，例如集合 A&#x3D;{a,b}，集合 B&#x3D;{1,2,3}，那么 A✖️B&#x3D;<code>&#123;&lt;a,o&gt;,&lt;a,1&gt;,&lt;a,2&gt;,&lt;b,0&gt;,&lt;b,1&gt;,&lt;b,2&gt;,&#125;</code>。</li></ul><h2 id="那-MySQL-的内连接、左连接、右连接有有什么区别？"><a href="#那-MySQL-的内连接、左连接、右连接有有什么区别？" class="headerlink" title="那 MySQL 的内连接、左连接、右连接有有什么区别？"></a>那 MySQL 的内连接、左连接、右连接有有什么区别？</h2><p>MySQL 的连接主要分为内连接和外连接，外连接常用的有左连接、右连接。</p><p><img src="https://s2.loli.net/2023/03/28/HLXvfCg1bkDRO6p.png" alt="img"></p><p>MySQL-joins-来源菜鸟教程</p><ul><li>inner join 内连接，在两张表进行连接查询时，只保留两张表中完全匹配的结果集</li><li>left join 在两张表进行连接查询时，会返回左表所有的行，即使在右表中没有匹配的记录。</li><li>right join 在两张表进行连接查询时，会返回右表所有的行，即使在左表中没有匹配的记录。</li></ul><h2 id="说一下数据库的三大范式？"><a href="#说一下数据库的三大范式？" class="headerlink" title="说一下数据库的三大范式？"></a>说一下数据库的三大范式？</h2><p><img src="https://s2.loli.net/2023/03/28/y5CwO2HWG7N83Xn.png" alt="数据库三范式"></p><center>数据库三范式</center><ul><li>第一范式：数据表中的每一列（每个字段）都不可以再拆分。例如用户表，用户地址还可以拆分成国家、省份、市，这样才是符合第一范式的。</li><li>第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。例如订单表里，存储了商品信息（商品价格、商品类型），那就需要把商品 ID 和订单 ID 作为联合主键，才满足第二范式。</li><li>第三范式：在满足第二范式的基础上，表中的非主键只依赖于主键，而不依赖于其他非主键。例如订单表，就不能存储用户信息（姓名、地址）。</li></ul><p><img src="https://s2.loli.net/2023/03/28/GSfqgiaNQrtzmBR.gif" alt="你设计遵守范式吗？"></p><center>你设计遵守范式吗？</center><p>三大范式的作用是为了控制数据库的冗余，是对空间的节省，实际上，一般互联网公司的设计都是反范式的，通过冗余一些数据，避免跨表跨库，利用空间换时间，提高性能。</p><h2 id="varchar-与-char-的区别？"><a href="#varchar-与-char-的区别？" class="headerlink" title="varchar 与 char 的区别？"></a>varchar 与 char 的区别？</h2><p><img src="https://s2.loli.net/2023/03/28/veTUpqWfNyGwVrB.png" alt="varchar"></p><center>varchar</center><p><strong>char</strong>：</p><ul><li>char 表示定长字符串，长度是固定的；</li><li>如果插入数据的长度小于 char 的固定长度时，则用空格填充；</li><li>因为长度固定，所以存取速度要比 varchar 快很多，甚至能快 50%，但正因为其长度固定，所以会占据多余的空间，是空间换时间的做法；</li><li>对于 char 来说，最多能存放的字符个数为 255，和编码无关</li></ul><p><strong>varchar</strong>：</p><ul><li>varchar 表示可变长字符串，长度是可变的；</li><li>插入的数据是多长，就按照多长来存储；</li><li>varchar 在存取方面与 char 相反，它存取慢，因为长度不固定，但正因如此，不占据多余的空间，是时间换空间的做法；</li><li>对于 varchar 来说，最多能存放的字符个数为 65532</li></ul><p>日常的设计，对于长度相对固定的字符串，可以使用 char，对于长度不确定的，使用 varchar 更合适一些。</p><h2 id="blob-和-text-有什么区别？"><a href="#blob-和-text-有什么区别？" class="headerlink" title="blob 和 text 有什么区别？"></a>blob 和 text 有什么区别？</h2><ul><li>blob 用于存储二进制数据，而 text 用于存储大字符串。</li><li>blob 没有字符集，text 有一个字符集，并且根据字符集的校对规则对值进行排序和比较</li></ul><h2 id="DATETIME-和-TIMESTAMP-的异同？"><a href="#DATETIME-和-TIMESTAMP-的异同？" class="headerlink" title="DATETIME 和 TIMESTAMP 的异同？"></a>DATETIME 和 TIMESTAMP 的异同？</h2><p><strong>相同点</strong>：</p><ol><li>两个数据类型存储时间的表现格式一致。均为 <code>YYYY-MM-DD HH:MM:SS</code></li><li>两个数据类型都包含「日期」和「时间」部分。</li><li>两个数据类型都可以存储微秒的小数秒（秒后 6 位小数秒）</li></ol><p><strong>区别</strong>：</p><p><img src="https://s2.loli.net/2023/03/28/QsunqZBR8vdzmE4.png" alt="img"></p><p>DATETIME 和 TIMESTAMP 的区别</p><ol><li><strong>日期范围</strong>：DATETIME 的日期范围是 <code>1000-01-01 00:00:00.000000</code> 到 <code>9999-12-31 23:59:59.999999</code>；TIMESTAMP 的时间范围是<code>1970-01-01 00:00:01.000000</code> UTC <code>到 ``2038-01-09 03:14:07.999999</code> UTC</li><li><strong>存储空间</strong>：DATETIME 的存储空间为 8 字节；TIMESTAMP 的存储空间为 4 字节</li><li><strong>时区相关</strong>：DATETIME 存储时间与时区无关；TIMESTAMP 存储时间与时区有关，显示的值也依赖于时区</li><li><strong>默认值</strong>：DATETIME 的默认值为 null；TIMESTAMP 的字段默认不为空(not null)，默认值为当前时间(CURRENT_TIMESTAMP)</li></ol><h2 id="MySQL-中-in-和-exists-的区别？"><a href="#MySQL-中-in-和-exists-的区别？" class="headerlink" title="MySQL 中 in 和 exists 的区别？"></a>MySQL 中 in 和 exists 的区别？</h2><p>MySQL 中的 in 语句是把外表和内表作 hash 连接，而 exists 语句是对外表作 loop 循环，每次 loop 循环再对内表进行查询。我们可能认为 exists 比 in 语句的效率要高，这种说法其实是不准确的，要区分情景：</p><ol><li>如果查询的两个表大小相当，那么用 in 和 exists 差别不大。</li><li>如果两个表中一个较小，一个是大表，则子查询表大的用 exists，子查询表小的用 in。</li><li>not in 和 not exists：如果查询语句使用了 not in，那么内外表都进行全表扫描，没有用到索引；而 not extsts 的子查询依然能用到表上的索引。所以无论那个表大，用 not exists 都比 not in 要快。</li></ol><h2 id="MySQL-里记录货币用什么字段类型比较好？"><a href="#MySQL-里记录货币用什么字段类型比较好？" class="headerlink" title="MySQL 里记录货币用什么字段类型比较好？"></a>MySQL 里记录货币用什么字段类型比较好？</h2><p>货币在数据库中 MySQL 常用 Decimal 和 Numric 类型表示，这两种类型被 MySQL 实现为同样的类型。他们被用于保存与货币有关的数据。</p><p>例如 salary DECIMAL(9,2)，9(precision)代表将被用于存储值的总的小数位数，而 2(scale)代表将被用于存储小数点后的位数。存储在 salary 列中的值的范围是从-9999999.99 到 9999999.99。</p><p>DECIMAL 和 NUMERIC 值作为字符串存储，而不是作为二进制浮点数，以便保存那些值的小数精度。</p><p>之所以不使用 float 或者 double 的原因：因为 float 和 double 是以二进制存储的，所以有一定的误差。</p><h2 id="MySQL-怎么存储-emoji😊"><a href="#MySQL-怎么存储-emoji😊" class="headerlink" title="MySQL 怎么存储 emoji😊?"></a>MySQL 怎么存储 emoji😊?</h2><p>MySQL 可以直接使用字符串存储 emoji。</p><p>但是需要注意的，utf8 编码是不行的，MySQL 中的 utf8 是阉割版的 utf8，它最多只用 3 个字节存储字符，所以存储不了表情。那该怎么办？</p><p>需要使用 utf8mb4 编码。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table blogs modify content text CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci not null;</span><br></pre></td></tr></table></figure><h2 id="drop、delete-与-truncate-的区别？"><a href="#drop、delete-与-truncate-的区别？" class="headerlink" title="drop、delete 与 truncate 的区别？"></a>drop、delete 与 truncate 的区别？</h2><p>三者都表示删除，但是三者有一些差别：</p><table><thead><tr><th>delete</th><th>truncate</th><th>drop</th></tr></thead><tbody><tr><td>类型</td><td>属于 DML</td><td>属于 DDL</td></tr><tr><td>回滚</td><td>可回滚</td><td>不可回滚</td></tr><tr><td>删除内容</td><td>表结构还在，删除表的全部或者一部分数据行</td><td>表结构还在，删除表中的所有数据</td></tr><tr><td>删除速度</td><td>删除速度慢，需要逐行删除</td><td>删除速度快</td></tr></tbody></table><p>因此，在不再需要一张表的时候，用 drop；在想删除部分数据行时候，用 delete；在保留表而删除所有数据的时候用 truncate。</p><h2 id="UNION-与-UNION-ALL-的区别？"><a href="#UNION-与-UNION-ALL-的区别？" class="headerlink" title="UNION 与 UNION ALL 的区别？"></a>UNION 与 UNION ALL 的区别？</h2><ul><li>如果使用 UNION，会在表链接后筛选掉重复的记录行</li><li>如果使用 UNION ALL，不会合并重复的记录行</li><li>从效率上说，UNION ALL 要比 UNION 快很多，如果合并没有刻意要删除重复行，那么就使用 UNION All</li></ul><h2 id="count-1-、count-与-count-列名-的区别？"><a href="#count-1-、count-与-count-列名-的区别？" class="headerlink" title="count(1)、count(*) 与 count(列名) 的区别？"></a>count(1)、count(*) 与 count(列名) 的区别？</h2><p><img src="https://s2.loli.net/2023/03/28/bn3c2s6IFQomXJw.png" alt="三种计数方式"></p><center>三种计数方式</center><p><strong>执行效果</strong>：</p><ul><li>count(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为 NULL</li><li>count(1)包括了忽略所有列，用 1 代表代码行，在统计结果的时候，不会忽略列值为 NULL</li><li>count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者 0，而是表示 null）的计数，即某个字段值为 NULL 时，不统计。</li></ul><p><strong>执行速度</strong>：</p><ul><li>列名为主键，count(列名)会比 count(1)快</li><li>列名不为主键，count(1)会比 count(列名)快</li><li>如果表多个列并且没有主键，则 count（1） 的执行效率优于 count（*）</li><li>如果有主键，则 select count（主键）的执行效率是最优的</li><li>如果表只有一个字段，则 select count（*）最优。</li></ul><h2 id="一条-SQL-查询语句的执行顺序？"><a href="#一条-SQL-查询语句的执行顺序？" class="headerlink" title="一条 SQL 查询语句的执行顺序？"></a>一条 SQL 查询语句的执行顺序？</h2><p><img src="https://s2.loli.net/2023/03/28/ysfVhRapQ5rFumg.png" alt="查询语句执行顺序"></p><center>查询语句执行顺序</center><ol><li><strong>FROM</strong>：对 FROM 子句中的左表<left_table>和右表<right_table>执行笛卡儿积（Cartesianproduct），产生虚拟表 VT1</li><li><strong>ON</strong>：对虚拟表 VT1 应用 ON 筛选，只有那些符合<join_condition>的行才被插入虚拟表 VT2 中</li><li><strong>JOIN</strong>：如果指定了 OUTER JOIN（如 LEFT OUTER JOIN、RIGHT OUTER JOIN），那么保留表中未匹配的行作为外部行添加到虚拟表 VT2 中，产生虚拟表 VT3。如果 FROM 子句包含两个以上表，则对上一个连接生成的结果表 VT3 和下一个表重复执行步骤 1）～步骤 3），直到处理完所有的表为止</li><li><strong>WHERE</strong>：对虚拟表 VT3 应用 WHERE 过滤条件，只有符合<where_condition>的记录才被插入虚拟表 VT4 中</li><li><strong>GROUP BY</strong>：根据 GROUP BY 子句中的列，对 VT4 中的记录进行分组操作，产生 VT5</li><li><strong>CUBE|ROLLUP</strong>：对表 VT5 进行 CUBE 或 ROLLUP 操作，产生表 VT6</li><li><strong>HAVING</strong>：对虚拟表 VT6 应用 HAVING 过滤器，只有符合<having_condition>的记录才被插入虚拟表 VT7 中。</li><li><strong>SELECT</strong>：第二次执行 SELECT 操作，选择指定的列，插入到虚拟表 VT8 中</li><li><strong>DISTINCT</strong>：去除重复数据，产生虚拟表 VT9</li><li><strong>ORDER BY</strong>：将虚拟表 VT9 中的记录按照<order_by_list>进行排序操作，产生虚拟表 VT10。11）</li><li><strong>LIMIT</strong>：取出指定行的记录，产生虚拟表 VT11，并返回给查询用户</li></ol><h1 id="数据库架构"><a href="#数据库架构" class="headerlink" title="数据库架构"></a>数据库架构</h1><h2 id="说说-MySQL-的基础架构"><a href="#说说-MySQL-的基础架构" class="headerlink" title="说说 MySQL 的基础架构?"></a>说说 MySQL 的基础架构?</h2><p><img src="https://s2.loli.net/2023/03/28/H9WJXhOgrMf5CPB.png" alt="img"></p><p>MySQL 逻辑架构图主要分三层：</p><ul><li>客户端：最上层的服务并不是 MySQL 所独有的，大多数基于网络的客户端&#x2F;服务器的工具或者服务都有类似的架构。比如连接处理、授权认证、安全等等。</li><li>Server 层：大多数 MySQL 的核心服务功能都在这一层，包括查询解析、分析、优化、缓存以及所有的内置函数（例如，日期、时间、数学和加密函数），所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。</li><li>存储引擎层：第三层包含了存储引擎。存储引擎负责 MySQL 中数据的存储和提取。Server 层通过 API 与存储引擎进行通信。这些接口屏蔽了不同存储引擎之间的差异，使得这些差异对上层的查询过程透明。</li></ul><h2 id="一条-SQL-查询语句在-MySQL-中如何执行的？"><a href="#一条-SQL-查询语句在-MySQL-中如何执行的？" class="headerlink" title="一条 SQL 查询语句在 MySQL 中如何执行的？"></a>一条 SQL 查询语句在 MySQL 中如何执行的？</h2><ul><li>先检查该语句<code>是否有权限</code>，如果没有权限，直接返回错误信息，如果有权限会先查询缓存 (MySQL8.0 版本以前)。</li><li>如果没有缓存，分析器进行<code>语法分析</code>，提取 sql 语句中 select 等关键元素，然后判断 sql 语句是否有语法错误，比如关键词是否正确等等。</li><li>语法解析之后，MySQL 的服务器会对查询的语句进行优化，确定执行的方案。</li><li>完成查询优化后，按照生成的执行计划<code>调用数据库引擎接口</code>，返回执行结果。</li></ul><h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><h2 id="MySQL-有哪些常见存储引擎？"><a href="#MySQL-有哪些常见存储引擎？" class="headerlink" title="MySQL 有哪些常见存储引擎？"></a>MySQL 有哪些常见存储引擎？</h2><p><img src="https://s2.loli.net/2023/03/28/F7nfZP8LGHyvRtJ.png" alt="主要存储引擎"></p><center>主要存储引擎</center><p>主要存储引擎以及功能如下：</p><table><thead><tr><th>功能</th><th>MylSAM</th><th>MEMORY</th><th>InnoDB</th></tr></thead><tbody><tr><td>存储限制</td><td>256TB</td><td>RAM</td><td>64TB</td></tr><tr><td>支持事务</td><td>No</td><td>No</td><td>Yes</td></tr><tr><td>支持全文索引</td><td>Yes</td><td>No</td><td>Yes</td></tr><tr><td>支持树索引</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>支持哈希索引</td><td>No</td><td>Yes</td><td>Yes</td></tr><tr><td>支持数据缓存</td><td>No</td><td>N&#x2F;A</td><td>Yes</td></tr><tr><td>支持外键</td><td>No</td><td>No</td><td>Yes</td></tr></tbody></table><p>MySQL5.5 之前，默认存储引擎是 MylSAM，5.5 之后变成了 InnoDB。</p><blockquote><p>InnoDB 支持的哈希索引是自适应的，InnoDB 会根据表的使用情况自动为表生成哈希索引，不能人为干预是否在一张表中生成哈希索引。</p></blockquote><blockquote><p>MySQL 5.6 开始 InnoDB 支持全文索引。</p></blockquote><h2 id="那存储引擎应该怎么选择？"><a href="#那存储引擎应该怎么选择？" class="headerlink" title="那存储引擎应该怎么选择？"></a>那存储引擎应该怎么选择？</h2><p>大致上可以这么选择：</p><ul><li>大多数情况下，使用默认的 InnoDB 就够了。如果要提供提交、回滚和恢复的事务安全（ACID 兼容）能力，并要求实现并发控制，InnoDB 就是比较靠前的选择了。</li><li>如果数据表主要用来插入和查询记录，则 MyISAM 引擎提供较高的处理效率。</li><li>如果只是临时存放数据，数据量不大，并且不需要较高的数据安全性，可以选择将数据保存在内存的 MEMORY 引擎中，MySQL 中使用该引擎作为临时表，存放查询的中间结果。</li></ul><p>使用哪一种引擎可以根据需要灵活选择，因为存储引擎是基于表的，所以一个数据库中多个表可以使用不同的引擎以满足各种性能和实际需求。使用合适的存储引擎将会提高整个数据库的性能。</p><h2 id="InnoDB-和-MylSAM-主要有什么区别？"><a href="#InnoDB-和-MylSAM-主要有什么区别？" class="headerlink" title="InnoDB 和 MylSAM 主要有什么区别？"></a>InnoDB 和 MylSAM 主要有什么区别？</h2><p>PS:MySQL8.0 都开始慢慢流行了，如果不是面试，MylSAM 其实可以不用怎么了解。</p><p><img src="https://s2.loli.net/2023/03/28/kDa6pKAXZEdexvf.png" alt="InnoDB 和 MylSAM 主要有什么区别"></p><center>InnoDB 和 MylSAM 主要有什么区别</center><p><strong>1.  存储结构</strong>：每个 MyISAM 在磁盘上存储成三个文件；InnoDB 所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB 表的大小只受限于操作系统文件的大小，一般为 2GB。</p><p><strong>2. 事务支持</strong>：MyISAM 不提供事务支持；InnoDB 提供事务支持事务，具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全特性。</p><p><strong>3  最小锁粒度</strong>：MyISAM 只支持表级锁，更新时会锁住整张表，导致其它查询和更新都会被阻塞 InnoDB 支持行级锁。</p><p><strong>4. 索引类型</strong>：MyISAM 的索引为非聚簇索引，数据结构是 B 树；InnoDB 的索引是聚簇索引，数据结构是 B+树。</p><p><strong>5.  主键必需</strong>：MyISAM 允许没有任何索引和主键的表存在；InnoDB 如果没有设定主键或者非空唯一索引，**就会自动生成一个 6 字节的主键(用户不可见)**，数据是主索引的一部分，附加索引保存的是主索引的值。</p><p><strong>6. 表的具体行数</strong>：MyISAM 保存了表的总行数，如果 select count(<em>) from table;会直接取出出该值; InnoDB 没有保存表的总行数，如果使用 select count(</em>) from table；就会遍历整个表;但是在加了 wehre 条件后，MyISAM 和 InnoDB 处理的方式都一样。</p><p><strong>7.  外键支持</strong>：MyISAM 不支持外键；InnoDB 支持外键。</p><h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><h2 id="MySQL-日志文件有哪些？分别介绍下作用？"><a href="#MySQL-日志文件有哪些？分别介绍下作用？" class="headerlink" title="MySQL 日志文件有哪些？分别介绍下作用？"></a>MySQL 日志文件有哪些？分别介绍下作用？</h2><p><img src="https://s2.loli.net/2023/03/28/o1flFpCBX6vieJw.png" alt="MySQL 主要日志"></p><center>MySQL 主要日志</center><p>MySQL 日志文件有很多，包括 ：</p><ul><li><strong>错误日志</strong>（error log）：错误日志文件对 MySQL 的启动、运行、关闭过程进行了记录，能帮助定位 MySQL 问题。</li><li><strong>慢查询日志</strong>（slow query log）：慢查询日志是用来记录执行时间超过 long_query_time 这个变量定义的时长的查询语句。通过慢查询日志，可以查找出哪些查询语句的执行效率很低，以便进行优化。</li><li><strong>一般查询日志</strong>（general log）：一般查询日志记录了所有对 MySQL 数据库请求的信息，无论请求是否正确执行。</li><li><strong>二进制日志</strong>（bin log）：关于二进制日志，它记录了数据库所有执行的 DDL 和 DML 语句（除了数据查询语句 select、show 等），以事件形式记录并保存在二进制文件中。</li></ul><p>还有两个 InnoDB 存储引擎特有的日志文件：</p><ul><li><strong>重做日志</strong>（redo log）：重做日志至关重要，因为它们记录了对于 InnoDB 存储引擎的事务日志。</li><li><strong>回滚日志</strong>（undo log）：回滚日志同样也是 InnoDB 引擎提供的日志，顾名思义，回滚日志的作用就是对数据进行回滚。当事务对数据库进行修改，InnoDB 引擎不仅会记录 redo log，还会生成对应的 undo log 日志；如果事务执行失败或调用了 rollback，导致事务需要回滚，就可以利用 undo log 中的信息将数据回滚到修改之前的样子。</li></ul><h2 id="binlog-和-redo-log-有什么区别？"><a href="#binlog-和-redo-log-有什么区别？" class="headerlink" title="binlog 和 redo log 有什么区别？"></a>binlog 和 redo log 有什么区别？</h2><ul><li>bin log 会记录所有与数据库有关的日志记录，包括 InnoDB、MyISAM 等存储引擎的日志，而 redo log 只记 InnoDB 存储引擎的日志。</li><li>记录的内容不同，bin log 记录的是关于一个事务的具体操作内容，即该日志是逻辑日志。而 redo log 记录的是关于每个页（Page）的更改的物理情况。</li><li>写入的时间不同，bin log 仅在事务提交前进行提交，也就是只写磁盘一次。而在事务进行的过程中，却不断有 redo ertry 被写入 redo log 中。</li><li>写入的方式也不相同，redo log 是循环写入和擦除，bin log 是追加写入，不会覆盖已经写的文件。</li></ul><h2 id="一条更新语句怎么执行的了解吗？"><a href="#一条更新语句怎么执行的了解吗？" class="headerlink" title="一条更新语句怎么执行的了解吗？"></a>一条更新语句怎么执行的了解吗？</h2><p>更新语句的执行是 Server 层和引擎层配合完成，数据除了要写入表中，还要记录相应的日志。</p><p><img src="https://s2.loli.net/2023/03/28/QCKYAfwGNyarWuH.png" alt="update 执行"></p><center>update 执行</center><ol><li>执行器先找引擎获取 ID&#x3D;2 这一行。ID 是主键，存储引擎检索数据，找到这一行。如果 ID&#x3D;2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li><li>执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li><li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。</li><li>执行器生成这个操作的 binlog，并把 binlog 写入磁盘。</li><li>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。</li></ol><p>从上图可以看出，MySQL 在执行更新语句的时候，在服务层进行语句的解析和执行，在引擎层进行数据的提取和存储；同时在服务层对 binlog 进行写入，在 InnoDB 内进行 redo log 的写入。</p><p>不仅如此，在对 redo log 写入时有两个阶段的提交，一是 binlog 写入之前<code>prepare</code>状态的写入，二是 binlog 写入之后<code>commit</code>状态的写入。</p><h2 id="那为什么要两阶段提交呢？"><a href="#那为什么要两阶段提交呢？" class="headerlink" title="那为什么要两阶段提交呢？"></a>那为什么要两阶段提交呢？</h2><p>为什么要两阶段提交呢？直接提交不行吗？</p><p>我们可以假设不采用两阶段提交的方式，而是采用“单阶段”进行提交，即要么先写入 redo log，后写入 binlog；要么先写入 binlog，后写入 redo log。这两种方式的提交都会导致原先数据库的状态和被恢复后的数据库的状态不一致。</p><p><strong>先写入 redo log，后写入 binlog：</strong></p><p>在写完 redo log 之后，数据此时具有<code>crash-safe</code>能力，因此系统崩溃，数据会恢复成事务开始之前的状态。但是，若在 redo log 写完时候，binlog 写入之前，系统发生了宕机。此时 binlog 没有对上面的更新语句进行保存，导致当使用 binlog 进行数据库的备份或者恢复时，就少了上述的更新语句。从而使得<code>id=2</code>这一行的数据没有被更新。</p><p><img src="https://s2.loli.net/2023/03/28/yFgx7KH6WGETJsA.png" alt="先写 redo log，后写 bin log 的问题"></p><center>先写 redo log，后写 bin log 的问题</center><p><strong>先写入 binlog，后写入 redo log：</strong></p><p>写完 binlog 之后，所有的语句都被保存，所以通过 binlog 复制或恢复出来的数据库中 id&#x3D;2 这一行的数据会被更新为 a&#x3D;1。但是如果在 redo log 写入之前，系统崩溃，那么 redo log 中记录的这个事务会无效，导致实际数据库中<code>id=2</code>这一行的数据并没有更新。</p><p><img src="https://s2.loli.net/2023/03/28/ybDXZOz5nCtVTMd.png" alt="先写 bin log，后写 redo log 的问题"></p><center>先写 bin log，后写 redo log 的问题</center><p>简单说，redo log 和 binlog 都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。</p><h2 id="redo-log-怎么刷入磁盘的知道吗？"><a href="#redo-log-怎么刷入磁盘的知道吗？" class="headerlink" title="redo log 怎么刷入磁盘的知道吗？"></a>redo log 怎么刷入磁盘的知道吗？</h2><p>redo log 的写入不是直接落到磁盘，而是在内存中设置了一片称之为<code>redo log buffer</code>的连续内存空间，也就是<code>redo 日志缓冲区</code>。</p><p><img src="https://s2.loli.net/2023/03/28/AXzob39VmsCPfL1.png" alt="redo log 缓冲"></p><center>redo log 缓冲</center><blockquote><p><strong>什么时候会刷入磁盘？</strong></p></blockquote><p>在如下的一些情况中，log buffer 的数据会刷入磁盘：</p><ul><li>log buffer 空间不足时</li></ul><p>log buffer 的大小是有限的，如果不停的往这个有限大小的 log buffer 里塞入日志，很快它就会被填满。如果当前写入 log buffer 的 redo 日志量已经占满了 log buffer 总容量的大约<strong>一半</strong>左右，就需要把这些日志刷新到磁盘上。</p><ul><li>事务提交时</li></ul><p>在事务提交时，为了保证持久性，会把 log buffer 中的日志全部刷到磁盘。注意，这时候，除了本事务的，可能还会刷入其它事务的日志。</p><ul><li>后台线程输入</li></ul><p>有一个后台线程，大约每秒都会刷新一次<code>log buffer</code>中的<code>redo log</code>到磁盘。</p><ul><li>正常关闭服务器时</li><li><strong>触发 checkpoint 规则</strong></li></ul><p>重做日志缓存、重做日志文件都是以<strong>块（block）*<em>的方式进行保存的，称之为*<em>重做日志块（redo log block）</em></em>,块的大小是固定的 512 字节。我们的 redo log 它是固定大小的，可以看作是一个逻辑上的 <strong>log group</strong>，由一定数量的</strong>log block** 组成。</p><p><img src="https://s2.loli.net/2023/03/28/Ude8aEnzbq4y1Mv.png" alt="redo log 分块和写入"></p><center>redo log 分块和写入</center><p>它的写入方式是从头到尾开始写，写到末尾又回到开头循环写。</p><p>其中有两个标记位置：</p><p><code>write pos</code>是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。<code>checkpoint</code>是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到磁盘。</p><p><img src="https://s2.loli.net/2023/03/28/R3pEVzjQWYaueXM.png" alt="write pos 和 checkpoint"></p><center>write pos 和 checkpoint</center><p>当<code>write_pos</code>追上<code>checkpoint</code>时，表示 redo log 日志已经写满。这时候就不能接着往里写数据了，需要执行<code>checkpoint</code>规则腾出可写空间。</p><p>所谓的<strong>checkpoint 规则</strong>，就是 checkpoint 触发后，将 buffer 中日志页都刷到磁盘。</p><h1 id="SQL-优化"><a href="#SQL-优化" class="headerlink" title="SQL 优化"></a>SQL 优化</h1><h2 id="慢-SQL-如何定位呢？"><a href="#慢-SQL-如何定位呢？" class="headerlink" title="慢 SQL 如何定位呢？"></a>慢 SQL 如何定位呢？</h2><p>慢 SQL 的监控主要通过两个途径：</p><p><img src="https://s2.loli.net/2023/03/28/oq6EbJ5dRXeVYps.png" alt="发现慢 SQL">发现慢 SQL</p><ul><li><strong>慢查询日志</strong>：开启 MySQL 的慢查询日志，再通过一些工具比如 mysqldumpslow 去分析对应的慢查询日志，当然现在一般的云厂商都提供了可视化的平台。</li><li><strong>服务监控</strong>：可以在业务的基建中加入对慢 SQL 的监控，常见的方案有字节码插桩、连接池扩展、ORM 框架过程，对服务运行中的慢 SQL 进行监控和告警。</li></ul><h2 id="有哪些方式优化慢-SQL？"><a href="#有哪些方式优化慢-SQL？" class="headerlink" title="有哪些方式优化慢 SQL？"></a>有哪些方式优化慢 SQL？</h2><p>慢 SQL 的优化，主要从两个方面考虑，SQL 语句本身的优化，以及数据库设计的优化。</p><p><img src="https://s2.loli.net/2023/03/28/idm7sbTLY5ROJ6K.png" alt="SQL 优化">SQL 优化</p><h3 id="避免不必要的列"><a href="#避免不必要的列" class="headerlink" title="避免不必要的列"></a>避免不必要的列</h3><p>这个是老生常谈，但还是经常会出的情况，SQL 查询的时候，应该只查询需要的列，而不要包含额外的列，像<code>slect *</code> 这种写法应该尽量避免。</p><h3 id="分页优化"><a href="#分页优化" class="headerlink" title="分页优化"></a>分页优化</h3><p>在数据量比较大，分页比较深的情况下，需要考虑分页的优化。</p><p>例如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table where type = 2 and level = 9 order by id asc limit 190289,10;</span><br></pre></td></tr></table></figure><p>优化方案：</p><ul><li><strong>延迟关联</strong></li></ul><p>先通过 where 条件提取出主键，在将该表与原数据表关联，通过主键 id 提取数据行，而不是通过原来的二级索引提取数据行</p><p>例如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select a.* from table a, </span><br><span class="line"> (select id from table where type = 2 and level = 9 order by id asc limit 190289,10 ) b</span><br><span class="line"> where a.id = b.id</span><br></pre></td></tr></table></figure><ul><li><strong>书签方式</strong></li></ul><p>书签方式就是找到 limit 第一个参数对应的主键值，根据这个主键值再去过滤并 limit</p><p>例如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from table where id &gt;</span><br><span class="line">(select * from table where type = 2 and level = 9 order by id asc limit 190</span><br></pre></td></tr></table></figure><h3 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h3><p>合理地设计和使用索引，是优化慢 SQL 的利器。</p><p><strong>利用覆盖索引</strong></p><p>InnoDB 使用非主键索引查询数据时会回表，但是如果索引的叶节点中已经包含要查询的字段，那它没有必要再回表查询了，这就叫覆盖索引</p><p>例如对于如下查询：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name from test where city=&#x27;上海&#x27;</span><br></pre></td></tr></table></figure><p>我们将被查询的字段建立到联合索引中，这样查询结果就可以直接从索引中获取</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table test add index idx_city_name (city, name);</span><br></pre></td></tr></table></figure><p><strong>低版本避免使用 or 查询</strong></p><p>在 MySQL 5.0 之前的版本要尽量避免使用 or 查询，可以使用 union 或者子查询来替代，因为早期的 MySQL 版本使用 or 查询可能会导致索引失效，高版本引入了索引合并，解决了这个问题。</p><p><strong>避免使用 !&#x3D; 或者 &lt;&gt; 操作符</strong></p><p>SQL 中，不等于操作符会导致查询引擎放弃查询索引，引起全表扫描，即使比较的字段上有索引</p><p>解决方法：通过把不等于操作符改成 or，可以使用索引，避免全表扫描</p><p>例如，把<code>column&lt;&gt;’aaa’，改成column&gt;’aaa’ or column&lt;’aaa’</code>，就可以使用索引了</p><p><strong>适当使用前缀索引</strong></p><p>适当地使用前缀所云，可以降低索引的空间占用，提高索引的查询效率。</p><p>比如，邮箱的后缀都是固定的“<code>@xxx.com</code>”，那么类似这种后面几位为固定值的字段就非常适合定义为前缀索引</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table test add index index2(email(6));</span><br></pre></td></tr></table></figure><p>PS:需要注意的是，前缀索引也存在缺点，MySQL 无法利用前缀索引做 order by 和 group by 操作，也无法作为覆盖索引</p><p><strong>避免列上函数运算</strong></p><p>要避免在列字段上进行算术运算或其他表达式运算，否则可能会导致存储引擎无法正确使用索引，从而影响了查询的效率</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from test where id + 1 = 50;</span><br><span class="line">select * from test where month(updateTime) = 7;</span><br></pre></td></tr></table></figure><p><strong>正确使用联合索引</strong></p><p>使用联合索引的时候，注意最左匹配原则。</p><h3 id="JOIN-优化"><a href="#JOIN-优化" class="headerlink" title="JOIN 优化"></a>JOIN 优化</h3><p><strong>优化子查询</strong></p><p>尽量使用 Join 语句来替代子查询，因为子查询是嵌套查询，而嵌套查询会新创建一张临时表，而临时表的创建与销毁会占用一定的系统资源以及花费一定的时间，同时对于返回结果集比较大的子查询，其对查询性能的影响更大</p><p><strong>小表驱动大表</strong></p><p>关联查询的时候要拿小表去驱动大表，因为关联的时候，MySQL 内部会遍历驱动表，再去连接被驱动表。</p><p>比如 left join，左表就是驱动表，A 表小于 B 表，建立连接的次数就少，查询速度就被加快了。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name from A left join B ;</span><br></pre></td></tr></table></figure><p><strong>适当增加冗余字段</strong></p><p>增加冗余字段可以减少大量的连表查询，因为多张表的连表查询性能很低，所有可以适当的增加冗余字段，以减少多张表的关联查询，这是以空间换时间的优化策略</p><p><strong>避免使用 JOIN 关联太多的表</strong></p><p>《阿里巴巴 Java 开发手册》规定不要 join 超过三张表，第一 join 太多降低查询的速度，第二 join 的 buffer 会占用更多的内存。</p><p>如果不可避免要 join 多张表，可以考虑使用数据异构的方式异构到 ES 中查询。</p><h3 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h3><p><strong>利用索引扫描做排序</strong></p><p>MySQL 有两种方式生成有序结果：其一是对结果集进行排序的操作，其二是按照索引顺序扫描得出的结果自然是有序的</p><p>但是如果索引不能覆盖查询所需列，就不得不每扫描一条记录回表查询一次，这个读操作是随机 IO，通常会比顺序全表扫描还慢</p><p>因此，在设计索引时，尽可能使用同一个索引既满足排序又用于查找行</p><p>例如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--建立索引（date,staff_id,customer_id）</span><br><span class="line">select staff_id, customer_id from test where date = &#x27;2010-01-01&#x27; order by staff_id,customer_id;</span><br></pre></td></tr></table></figure><p>只有当索引的列顺序和 ORDER BY 子句的顺序完全一致，并且所有列的排序方向都一样时，才能够使用索引来对结果做排序</p><h3 id="UNION-优化"><a href="#UNION-优化" class="headerlink" title="UNION 优化"></a>UNION 优化</h3><p><strong>条件下推</strong></p><p>MySQL 处理 union 的策略是先创建临时表，然后将各个查询结果填充到临时表中最后再来做查询，很多优化策略在 union 查询中都会失效，因为它无法利用索引</p><p>最好手工将 where、limit 等子句下推到 union 的各个子查询中，以便优化器可以充分利用这些条件进行优化</p><p>此外，除非确实需要服务器去重，一定要使用 union all，如果不加 all 关键字，MySQL 会给临时表加上 distinct 选项，这会导致对整个临时表做唯一性检查，代价很高。</p><h2 id="怎么看执行计划（explain），如何理解其中各个字段的含义？"><a href="#怎么看执行计划（explain），如何理解其中各个字段的含义？" class="headerlink" title="怎么看执行计划（explain），如何理解其中各个字段的含义？"></a>怎么看执行计划（explain），如何理解其中各个字段的含义？</h2><p>explain 是 sql 优化的利器，除了优化慢 sql，平时的 sql 编写，也应该先 explain，查看一下执行计划，看看是否还有优化的空间。</p><p>直接在 select 语句之前增加<code>explain</code> 关键字，就会返回执行计划的信息。</p><p><img src="https://s2.loli.net/2023/03/28/oOTZiubU6tEzpVx.png" alt="img"></p><p><img src="https://s2.loli.net/2023/03/28/UMPrz6SVERD1fox.png" alt="img"></p><ol><li><strong>id</strong> 列：MySQL 会为每个 select 语句分配一个唯一的 id 值</li><li><strong>select_type</strong> 列，查询的类型，根据关联、union、子查询等等分类，常见的查询类型有 SIMPLE、PRIMARY。</li><li><strong>table</strong> 列：表示 explain 的一行正在访问哪个表。</li><li><strong>type</strong> 列：最重要的列之一。表示关联类型或访问类型，即 MySQL 决定如何查找表中的行。</li></ol><p>性能从最优到最差分别为：system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p><ul><li>system</li></ul><p><code>system</code>：当表仅有一行记录时(系统表)，数据量很少，往往不需要进行磁盘 IO，速度非常快</p><ul><li>const</li></ul><p><code>const</code>：表示查询时命中 <code>primary key</code> 主键或者 <code>unique</code> 唯一索引，或者被连接的部分是一个常量(<code>const</code>)值。这类扫描效率极高，返回数据量少，速度非常快。</p><ul><li>eq_ref</li></ul><p><code>eq_ref</code>：查询时命中主键<code>primary key</code> 或者 <code>unique key</code>索引， <code>type</code> 就是 <code>eq_ref</code>。</p><ul><li>ref_or_null</li></ul><p><code>ref_or_null</code>：这种连接类型类似于 ref，区别在于 <code>MySQL</code>会额外搜索包含<code>NULL</code>值的行。</p><ul><li>index_merge</li></ul><p><code>index_merge</code>：使用了索引合并优化方法，查询使用了两个以上的索引。</p><ul><li>unique_subquery</li></ul><p><code>unique_subquery</code>：替换下面的 <code>IN</code>子查询，子查询返回不重复的集合。</p><ul><li>index_subquery</li></ul><p><code>index_subquery</code>：区别于<code>unique_subquery</code>，用于非唯一索引，可以返回重复值。</p><ul><li>range</li></ul><p><code>range</code>：使用索引选择行，仅检索给定范围内的行。简单点说就是针对一个有索引的字段，给定范围检索数据。在<code>where</code>语句中使用 <code>bettween...and</code>、<code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>in</code> 等条件查询 <code>type</code> 都是 <code>range</code>。</p><ul><li>index</li></ul><p><code>index</code>：<code>Index</code> 与<code>ALL</code> 其实都是读全表，区别在于<code>index</code>是遍历索引树读取，而<code>ALL</code>是从硬盘中读取。</p><ul><li>ALL</li></ul><p>就不用多说了，全表扫描。</p><ol><li><strong>possible_keys</strong> 列：显示查询可能使用哪些索引来查找，使用索引优化 sql 的时候比较重要。</li><li><strong>key</strong> 列：这一列显示 mysql 实际采用哪个索引来优化对该表的访问，判断索引是否失效的时候常用。</li><li><strong>key_len</strong> 列：显示了 MySQL 使用</li><li><strong>ref</strong> 列：ref 列展示的就是与索引列作等值匹配的值，常见的有：const（常量），func，NULL，字段名。</li><li><strong>rows</strong> 列：这也是一个重要的字段，MySQL 查询优化器根据统计信息，估算 SQL 要查到结果集需要扫描读取的数据行数，这个值非常直观显示 SQL 的效率好坏，原则上 rows 越少越好。</li><li><strong>Extra</strong> 列：显示不适合在其它列的额外信息，虽然叫额外，但是也有一些重要的信息：</li></ol><ul><li>Using index：表示 MySQL 将使用覆盖索引，以避免回表</li><li>Using where：表示会在存储引擎检索之后再进行过滤</li><li>Using temporary ：表示对查询结果排序时会使用一个临时表。</li></ul><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引可以说是 MySQL 面试中的重中之重，一定要彻底拿下。</p><h2 id="能简单说一下索引的分类吗？"><a href="#能简单说一下索引的分类吗？" class="headerlink" title="能简单说一下索引的分类吗？"></a>能简单说一下索引的分类吗？</h2><p>从三个不同维度对索引分类：</p><p><img src="https://s2.loli.net/2023/03/28/8uAPTDQsmiNanhc.png" alt="索引分类"></p><center>索引分类</center><p>例如从基本使用使用的角度来讲：</p><ul><li>主键索引: InnoDB 主键是默认的索引，数据列不允许重复，不允许为 NULL，一个表只能有一个主键。</li><li>唯一索引: 数据列不允许重复，允许为 NULL 值，一个表允许多个列创建唯一索引。</li><li>普通索引: 基本的索引类型，没有唯一性的限制，允许为 NULL 值。</li><li>组合索引：多列值组成一个索引，用于组合搜索，效率大于索引合并</li></ul><h2 id="为什么使用索引会加快查询？"><a href="#为什么使用索引会加快查询？" class="headerlink" title="为什么使用索引会加快查询？"></a>为什么使用索引会加快查询？</h2><p>传统的查询方法，是按照表的顺序遍历的，不论查询几条数据，MySQL 需要将表的数据从头到尾遍历一遍。</p><p>在我们添加完索引之后，MySQL 一般通过 BTREE 算法生成一个索引文件，在查询数据库时，找到索引文件进行遍历，在比较小的索引数据里查找，然后映射到对应的数据，能大幅提升查找的效率。</p><p>和我们通过书的目录，去查找对应的内容，一样的道理。</p><p><img src="https://s2.loli.net/2023/03/28/GI2VDQTHY4bMa3c.png" alt="索引加快查询远离"></p><center>索引加快查询远离</center><h2 id="创建索引有哪些注意点？"><a href="#创建索引有哪些注意点？" class="headerlink" title="创建索引有哪些注意点？"></a>创建索引有哪些注意点？</h2><p>索引虽然是 sql 性能优化的利器，但是索引的维护也是需要成本的，所以创建索引，也要注意：</p><ol><li>索引应该建在查询应用频繁的字段</li></ol><p>在用于 where 判断、 order 排序和 join 的(on)字段上创建索引。</p><ol><li>索引的个数应该适量</li></ol><p>索引需要占用空间；更新时候也需要维护。</p><ol><li>区分度低的字段，例如性别，不要建索引。</li></ol><p>离散度太低的字段，扫描的行数降低的有限。</p><ol><li>频繁更新的值，不要作为主键或者索引</li></ol><p>维护索引文件需要成本；还会导致页分裂，IO 次数增多。</p><ol><li>组合索引把散列性高(区分度高)的值放在前面</li></ol><p>为了满足最左前缀匹配原则</p><ol><li>创建组合索引，而不是修改单列索引。</li></ol><p>组合索引代替多个单列索引（对于单列索引，MySQL 基本只能使用一个索引，所以经常使用多个条件查询时更适合使用组合索引）</p><ol><li>过长的字段，使用前缀索引。当字段值比较长的时候，建立索引会消耗很多的空间，搜索起来也会很慢。我们可以通过截取字段的前面一部分内容建立索引，这个就叫前缀索引。</li><li>不建议用无序的值(例如身份证、UUID )作为索引</li></ol><p>当主键具有不确定性，会造成叶子节点频繁分裂，出现磁盘存储的碎片化</p><h2 id="索引哪些情况下会失效呢？"><a href="#索引哪些情况下会失效呢？" class="headerlink" title="索引哪些情况下会失效呢？"></a>索引哪些情况下会失效呢？</h2><ul><li>查询条件包含 or，可能导致索引失效</li><li>如果字段类型是字符串，where 时一定用引号括起来，否则会因为隐式类型转换，索引失效</li><li>like 通配符可能导致索引失效。</li><li>联合索引，查询时的条件列不是联合索引中的第一个列，索引失效。</li><li>在索引列上使用 mysql 的内置函数，索引失效。</li><li>对索引列运算（如，+、-、*、&#x2F;），索引失效。</li><li>索引字段上使用（！&#x3D; 或者 &lt; &gt;，not in）时，可能会导致索引失效。</li><li>索引字段上使用 is null， is not null，可能导致索引失效。</li><li>左连接查询或者右连接查询查询关联的字段编码格式不一样，可能导致索引失效。</li><li>MySQL 优化器估计使用全表扫描要比使用索引快,则不使用索引。</li></ul><h2 id="索引不适合哪些场景呢？"><a href="#索引不适合哪些场景呢？" class="headerlink" title="索引不适合哪些场景呢？"></a>索引不适合哪些场景呢？</h2><ul><li>数据量比较少的表不适合加索引</li><li>更新比较频繁的字段也不适合加索引</li><li>离散低的字段不适合加索引（如性别）</li></ul><h2 id="索引是不是建的越多越好呢？"><a href="#索引是不是建的越多越好呢？" class="headerlink" title="索引是不是建的越多越好呢？"></a>索引是不是建的越多越好呢？</h2><p>当然不是。</p><ul><li><strong>索引会占据磁盘空间</strong></li><li><strong>索引虽然会提高查询效率，但是会降低更新表的效率</strong>。比如每次对表进行增删改操作，MySQL 不仅要保存数据，还有保存或者更新对应的索引文件。</li></ul><h2 id="MySQL-索引用的什么数据结构了解吗？"><a href="#MySQL-索引用的什么数据结构了解吗？" class="headerlink" title="MySQL 索引用的什么数据结构了解吗？"></a>MySQL 索引用的什么数据结构了解吗？</h2><p>MySQL 的默认存储引擎是 InnoDB，它采用的是 B+树结构的索引。</p><ul><li>B+树：只有叶子节点才会存储数据，非叶子节点只存储键值。叶子节点之间使用双向指针连接，最底层的叶子节点形成了一个双向有序链表。</li></ul><p><img src="https://s2.loli.net/2023/03/28/cmG8xLe1RzHP3Yo.png" alt="B+树索引"></p><center>B+树索引</center><p>在这张图里，有两个重点：</p><ul><li>最外面的方块，的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（粉色所示）和指针（黄色&#x2F;灰色所示），如根节点磁盘包含数据项 17 和 35，包含指针 P1、P2、P3，P1 表示小于 17 的磁盘块，P2 表示在 17 和 35 之间的磁盘块，P3 表示大于 35 的磁盘块。真实的数据存在于叶子节点即 3、4、5……、65。非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项，如 17、35 并不真实存在于数据表中。</li><li>叶子节点之间使用双向指针连接，最底层的叶子节点形成了一个双向有序链表，可以进行范围查询。</li></ul><h2 id="那一棵-B-树能存储多少条数据呢？"><a href="#那一棵-B-树能存储多少条数据呢？" class="headerlink" title="那一棵 B+树能存储多少条数据呢？"></a>那一棵 B+树能存储多少条数据呢？</h2><p><img src="https://s2.loli.net/2023/03/28/mFRZJC57eTvsIPY.png" alt="B+树存储数据条数"></p><center>B+树存储数据条数</center><p>假设索引字段是 bigint 类型，长度为 8 字节。指针大小在 InnoDB 源码中设置为 6 字节，这样一共 14 字节。非叶子节点(一页)可以存储 16384&#x2F;14&#x3D;1170 个这样的 单元(键值+指针)，代表有 1170 个指针。</p><p>树深度为 2 的时候，有 1170^2 个叶子节点，可以存储的数据为 1170<em>1170</em>16&#x3D;<strong>21902400</strong>。</p><p>在查找数据时一次页的查找代表一次 IO，也就是说，一张 2000 万左右的表，查询数据最多需要访问 3 次磁盘。</p><p>所以在 InnoDB 中 B+ 树深度一般为 1-3 层，它就能满足千万级的数据存储。</p><h2 id="为什么要用-B-树，而不用普通二叉树？"><a href="#为什么要用-B-树，而不用普通二叉树？" class="headerlink" title="为什么要用 B+ 树，而不用普通二叉树？"></a>为什么要用 B+ 树，而不用普通二叉树？</h2><p>可以从几个维度去看这个问题，查询是否够快，效率是否稳定，存储数据多少，以及查找磁盘次数。</p><blockquote><p><strong>为什么不用普通二叉树？</strong></p></blockquote><p>普通二叉树存在退化的情况，如果它退化成链表，相当于全表扫描。平衡二叉树相比于二叉查找树来说，查找效率更稳定，总体的查找速度也更快。</p><blockquote><p><strong>为什么不用平衡二叉树呢？</strong></p></blockquote><p>读取数据的时候，是从磁盘读到内存。如果树这种数据结构作为索引，那每查找一次数据就需要从磁盘中读取一个节点，也就是一个磁盘块，但是平衡二叉树可是每个节点只存储一个键值和数据的，如果是 B+ 树，可以存储更多的节点数据，树的高度也会降低，因此读取磁盘的次数就降下来啦，查询效率就快。</p><h2 id="为什么用-B-树而不用-B-树呢？"><a href="#为什么用-B-树而不用-B-树呢？" class="headerlink" title="为什么用 B+ 树而不用 B 树呢？"></a>为什么用 B+ 树而不用 B 树呢？</h2><p>B+相比较 B 树，有这些优势：</p><ul><li>它是 B Tree 的变种，B Tree 能解决的问题，它都能解决。</li></ul><p>B Tree 解决的两大问题：每个节点存储更多关键字；路数更多</p><ul><li>扫库、扫表能力更强</li></ul><p>如果我们要对表进行全表扫描，只需要遍历叶子节点就可以 了，不需要遍历整棵 B+Tree 拿到所有的数据。</p><ul><li>B+Tree 的磁盘读写能力相对于 B Tree 来说更强，IO 次数更少</li></ul><p>根节点和枝节点不保存数据区， 所以一个节点可以保存更多的关键字，一次磁盘加载的关键字更多，IO 次数更少。</p><ul><li>排序能力更强</li></ul><p>因为叶子节点上有下一个数据区的指针，数据形成了链表。</p><ul><li>效率更加稳定</li></ul><p>B+Tree 永远是在叶子节点拿到数据，所以 IO 次数是稳定的。</p><h2 id="Hash-索引和-B-树索引区别是什么？"><a href="#Hash-索引和-B-树索引区别是什么？" class="headerlink" title="Hash 索引和 B+ 树索引区别是什么？"></a>Hash 索引和 B+ 树索引区别是什么？</h2><ul><li>B+ 树可以进行范围查询，Hash 索引不能。</li><li>B+ 树支持联合索引的最左侧原则，Hash 索引不支持。</li><li>B+ 树支持 order by 排序，Hash 索引不支持。</li><li>Hash 索引在等值查询上比 B+ 树效率更高。</li><li>B+ 树使用 like 进行模糊查询的时候，like 后面（比如 % 开头）的话可以起到优化的作用，Hash 索引根本无法进行模糊查询。</li></ul><h2 id="聚簇索引与非聚簇索引的区别？"><a href="#聚簇索引与非聚簇索引的区别？" class="headerlink" title="聚簇索引与非聚簇索引的区别？"></a>聚簇索引与非聚簇索引的区别？</h2><p>首先理解聚簇索引不是一种新的索引，而是而是一种<strong>数据存储方式</strong>。聚簇表示数据行和相邻的键值紧凑地存储在一起。我们熟悉的两种存储引擎——MyISAM 采用的是非聚簇索引，InnoDB 采用的是聚簇索引。</p><p>可以这么说：</p><ul><li>索引的数据结构是树，聚簇索引的索引和数据存储在一棵树上，树的叶子节点就是数据，非聚簇索引索引和数据不在一棵树上。</li></ul><p><img src="https://s2.loli.net/2023/03/28/rbqz2g4iV5pok8K.png" alt="聚簇索引和非聚簇索引"></p><center>聚簇索引和非聚簇索引</center><ul><li>一个表中只能拥有一个聚簇索引，而非聚簇索引一个表可以存在多个。</li><li>聚簇索引，索引中键值的逻辑顺序决定了表中相应行的物理顺序；索引，索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同。</li><li>聚簇索引：物理存储按照索引排序；非聚集索引：物理存储不按照索引排序；</li></ul><h2 id="回表了解吗？"><a href="#回表了解吗？" class="headerlink" title="回表了解吗？"></a>回表了解吗？</h2><p>在 InnoDB 存储引擎里，利用辅助索引查询，先通过辅助索引找到主键索引的键值，再通过主键值查出主键索引里面没有符合要求的数据，它比基于主键索引的查询多扫描了一棵索引树，这个过程就叫回表。</p><p>例如:<code>select \* from user where name = ‘张三’;</code></p><p><img src="https://s2.loli.net/2023/03/28/3JrxWjh2HP8oYFd.png" alt="InnoDB 回表"></p><center>InnoDB 回表</center><h2 id="覆盖索引了解吗？"><a href="#覆盖索引了解吗？" class="headerlink" title="覆盖索引了解吗？"></a>覆盖索引了解吗？</h2><p>在辅助索引里面，不管是单列索引还是联合索引，如果 select 的数据列只用辅助索引中就能够取得，不用去查主键索引，这时候使用的索引就叫做覆盖索引，避免了回表。</p><p>比如，<code>select name from user where name = ‘张三’;</code></p><p><img src="https://s2.loli.net/2023/03/28/RJnivkGYUw5pLEr.png" alt="覆盖索引"></p><center>覆盖索引</center><h2 id="什么是最左前缀原则-x2F-最左匹配原则？"><a href="#什么是最左前缀原则-x2F-最左匹配原则？" class="headerlink" title="什么是最左前缀原则&#x2F;最左匹配原则？"></a>什么是最左前缀原则&#x2F;最左匹配原则？</h2><p>注意：最左前缀原则、最左匹配原则、最左前缀匹配原则这三个都是一个概念。</p><p><strong>最左匹配原则</strong>：在 InnoDB 的联合索引中，查询的时候只有匹配了前一个&#x2F;左边的值之后，才能匹配下一个。</p><p>根据最左匹配原则，我们创建了一个组合索引，如 (a1,a2,a3)，相当于创建了（a1）、(a1,a2)和 (a1,a2,a3) 三个索引。</p><p>为什么不从最左开始查，就无法匹配呢？</p><p>比如有一个 user 表，我们给 name 和 age 建立了一个组合索引。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE user add INDEX comidx_name_phone (name,age);</span><br></pre></td></tr></table></figure><p>组合索引在 B+Tree 中是复合的数据结构，它是按照从左到右的顺序来建立搜索树的 (name 在左边，age 在右边)。</p><p><img src="https://s2.loli.net/2023/03/28/GFkoXQ5tsv82ZUM.png" alt="组合索引">组合索引</p><p>从这张图可以看出来，name 是有序的，age 是无序的。当 name 相等的时候， age 才是有序的。</p><p>这个时候我们使用 <code>where name= ‘张三‘ and age = ‘20 ‘</code>去查询数据的时候， B+Tree 会优先比较 name 来确定下一步应该搜索的方向，往左还是往右。如果 name 相同的时候再比较 age。但是如果查询条件没有 name，就不知道下一步应该查哪个 节点，因为建立搜索树的时候 name 是第一个比较因子，所以就没用上索引。</p><h2 id="什么是索引下推优化？"><a href="#什么是索引下推优化？" class="headerlink" title="什么是索引下推优化？"></a>什么是索引下推优化？</h2><p>索引条件下推优化<code>（Index Condition Pushdown (ICP) ）</code>是 MySQL5.6 添加的，用于优化数据查询。</p><ul><li>不使用索引条件下推优化时存储引擎通过索引检索到数据，然后返回给 MySQL Server，MySQL Server 进行过滤条件的判断。</li><li>当使用索引条件下推优化时，如果存在某些被索引的列的判断条件时，MySQL Server 将这一部分判断条件<strong>下推</strong>给存储引擎，然后由存储引擎通过判断索引是否符合 MySQL Server 传递的条件，只有当索引符合条件时才会将数据检索出来返回给 MySQL 服务器。</li></ul><p>例如一张表，建了一个联合索引（name, age），查询语句：<code>select * from t_user where name like &#39;张%&#39; and age=10;</code>，由于<code>name</code>使用了范围查询，根据最左匹配原则：</p><p>不使用 ICP，引擎层查找到<code>name like &#39;张%&#39;</code>的数据，再由 Server 层去过滤<code>age=10</code>这个条件，这样一来，就回表了两次，浪费了联合索引的另外一个字段<code>age</code>。</p><p><img src="https://s2.loli.net/2023/03/28/5w6NdIUxkCP73cH.png" alt="没有使用 ICP"></p><center>没有使用 ICP</center><p>但是，使用了索引下推优化，把 where 的条件放到了引擎层执行，直接根据<code>name like &#39;张%&#39; and age=10</code>的条件进行过滤，减少了回表的次数。</p><p><img src="https://s2.loli.net/2023/03/28/n8QNEesTkM3vWVj.png" alt="使用 ICP"></p><center>使用 ICP</center><p>索引条件下推优化可以减少存储引擎查询基础表的次数，也可以减少 MySQL 服务器从存储引擎接收数据的次数。</p><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="MySQL-中有哪几种锁，列举一下？"><a href="#MySQL-中有哪几种锁，列举一下？" class="headerlink" title="MySQL 中有哪几种锁，列举一下？"></a>MySQL 中有哪几种锁，列举一下？</h2><p><img src="https://s2.loli.net/2023/03/28/aX2pQMNmdyIB4xT.png" alt="MySQL 中的锁"></p><center>MySQL 中的锁</center><p>如果按锁粒度划分，有以下 3 种：</p><ul><li>表锁：开销小，加锁快；锁定力度大，发生锁冲突概率高，并发度最低;不会出现死锁。</li><li>行锁：开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高。</li><li>页锁：开销和加锁速度介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般</li></ul><p>如果按照兼容性，有两种，</p><ul><li>共享锁（S Lock）,也叫读锁（read lock），相互不阻塞。</li><li>排他锁（X Lock），也叫写锁（write lock），排它锁是阻塞的，在一定时间内，只有一个请求能执行写入，并阻止其它锁读取正在写入的数据。</li></ul><h2 id="说说-InnoDB-里的行锁实现"><a href="#说说-InnoDB-里的行锁实现" class="headerlink" title="说说 InnoDB 里的行锁实现?"></a>说说 InnoDB 里的行锁实现?</h2><p>我们拿这么一个用户表来表示行级锁，其中插入了 4 行数据，主键值分别是 1,6,8,12，现在简化它的聚簇索引结构，只保留数据记录。</p><p><img src="https://s2.loli.net/2023/03/28/LfZay5Oe8pmtIh4.png" alt="简化的主键索引"></p><center>简化的主键索引</center><p>InnoDB 的行锁的主要实现如下：</p><ul><li><strong>Record Lock 记录锁</strong></li></ul><p>记录锁就是直接锁定某行记录。当我们使用唯一性的索引(包括唯一索引和聚簇索引)进行等值查询且精准匹配到一条记录时，此时就会直接将这条记录锁定。例如<code>select * from t where id =6 for update;</code>就会将<code>id=6</code>的记录锁定。</p><p><img src="https://s2.loli.net/2023/03/28/zp9VaxiyeRQX651.png" alt="记录锁"></p><center>记录锁</center><ul><li><strong>Gap Lock 间隙锁</strong></li></ul><p>间隙锁(Gap Locks) 的间隙指的是两个记录之间逻辑上尚未填入数据的部分,是一个<strong>左开右开空间</strong>。</p><p><img src="https://s2.loli.net/2023/03/28/y6MtN8BGVScDKTq.png" alt="间隙锁"></p><center>间隙锁</center><p>间隙锁就是锁定某些间隙区间的。当我们使用用等值查询或者范围查询，并且没有命中任何一个<code>record</code>，此时就会将对应的间隙区间锁定。例如<code>select * from t where id =3 for update;</code>或者<code>select * from t where id &gt; 1 and id &lt; 6 for update;</code>就会将(1,6)区间锁定。</p><ul><li><strong>Next-key Lock 临键锁</strong></li></ul><p>临键指的是间隙加上它右边的记录组成的<strong>左开右闭区间</strong>。比如上述的(1,6]、(6,8]等。</p><p><img src="https://s2.loli.net/2023/03/28/nzwFjbPMfXKDUre.png" alt="临键锁"></p><center>临键锁</center><p>临键锁就是记录锁(Record Locks)和间隙锁(Gap Locks)的结合，即除了锁住记录本身，还要再锁住索引之间的间隙。当我们使用范围查询，并且命中了部分<code>record</code>记录，此时锁住的就是临键区间。注意，临键锁锁住的区间会包含最后一个 record 的右边的临键区间。例如<code>select * from t where id &gt; 5 and id &lt;= 7 for update;</code>会锁住(4,7]、(7,+∞)。mysql 默认行锁类型就是<code>临键锁(Next-Key Locks)</code>。当使用唯一性索引，等值查询匹配到一条记录的时候，临键锁(Next-Key Locks)会退化成记录锁；没有匹配到任何记录的时候，退化成间隙锁。</p><blockquote><p><code>间隙锁(Gap Locks)</code>和<code>临键锁(Next-Key Locks)</code>都是用来解决幻读问题的，在<code>已提交读（READ COMMITTED）</code>隔离级别下，<code>间隙锁(Gap Locks)</code>和<code>临键锁(Next-Key Locks)</code>都会失效！</p></blockquote><p>上面是行锁的三种实现算法，除此之外，在行上还存在插入意向锁。</p><ul><li><strong>Insert Intention Lock 插入意向锁</strong></li></ul><p>一个事务在插入一条记录时需要判断一下插入位置是不是被别的事务加了意向锁 ，如果有的话，插入操作需要等待，直到拥有 gap 锁 的那个事务提交。但是事务在等待的时候也需要在内存中生成一个 锁结构 ，表明有事务想在某个 间隙 中插入新记录，但是现在在等待。这种类型的锁命名为 Insert Intention Locks ，也就是插入意向锁 。</p><p>假如我们有个 T1 事务，给(1,6)区间加上了意向锁，现在有个 T2 事务，要插入一个数据，id 为 4，它会获取一个（1,6）区间的插入意向锁，又有有个 T3 事务，想要插入一个数据，id 为 3，它也会获取一个（1,6）区间的插入意向锁，但是，这两个插入意向锁锁不会互斥。</p><p><img src="https://s2.loli.net/2023/03/28/riuMkBdUVWfSKgJ.png" alt="插入意向锁"></p><center>插入意向锁</center><h2 id="意向锁是什么知道吗？"><a href="#意向锁是什么知道吗？" class="headerlink" title="意向锁是什么知道吗？"></a>意向锁是什么知道吗？</h2><p>意向锁是一个表级锁，不要和插入意向锁搞混。</p><p>意向锁的出现是为了支持 InnoDB 的多粒度锁，它解决的是表锁和行锁共存的问题。</p><p>当我们需要给一个表加表锁的时候，我们需要根据去判断表中有没有数据行被锁定，以确定是否能加成功。</p><p>假如没有意向锁，那么我们就得遍历表中所有数据行来判断有没有行锁；</p><p>有了意向锁这个表级锁之后，则我们直接判断一次就知道表中是否有数据行被锁定了。</p><p>有了意向锁之后，要执行的事务 A 在申请行锁（写锁）之前，数据库会自动先给事务 A 申请表的意向排他锁。当事务 B 去申请表的互斥锁时就会失败，因为表上有意向排他锁之后事务 B 申请表的互斥锁时会被阻塞。</p><p><img src="https://s2.loli.net/2023/03/28/rsiFvTHWE1z3RS4.png" alt="意向锁"></p><center>意向锁</center><h2 id="MySQL-的乐观锁和悲观锁了解吗？"><a href="#MySQL-的乐观锁和悲观锁了解吗？" class="headerlink" title="MySQL 的乐观锁和悲观锁了解吗？"></a>MySQL 的乐观锁和悲观锁了解吗？</h2><ul><li><strong>悲观锁</strong>（Pessimistic Concurrency Control）：</li></ul><p>悲观锁认为被它保护的数据是极其不安全的，每时每刻都有可能被改动，一个事务拿到悲观锁后，其他任何事务都不能对该数据进行修改，只能等待锁被释放才可以执行。</p><p>数据库中的行锁，表锁，读锁，写锁均为悲观锁。</p><ul><li><strong>乐观锁（Optimistic Concurrency Control）</strong></li></ul><p>乐观锁认为数据的变动不会太频繁。</p><p>乐观锁通常是通过在表中增加一个版本(version)或时间戳(timestamp)来实现，其中，版本最为常用。</p><p>事务在从数据库中取数据时，会将该数据的版本也取出来(v1)，当事务对数据变动完毕想要将其更新到表中时，会将之前取出的版本 v1 与数据中最新的版本 v2 相对比，如果 v1&#x3D;v2，那么说明在数据变动期间，没有其他事务对数据进行修改，此时，就允许事务对表中的数据进行修改，并且修改时 version 会加 1，以此来表明数据已被变动。</p><p>如果，v1 不等于 v2，那么说明数据变动期间，数据被其他事务改动了，此时不允许数据更新到表中，一般的处理办法是通知用户让其重新操作。不同于悲观锁，乐观锁通常是由开发者实现的。</p><h2 id="MySQL-遇到过死锁问题吗，你是如何解决的？"><a href="#MySQL-遇到过死锁问题吗，你是如何解决的？" class="headerlink" title="MySQL 遇到过死锁问题吗，你是如何解决的？"></a>MySQL 遇到过死锁问题吗，你是如何解决的？</h2><p>排查死锁的一般步骤是这样的：</p><p>（1）查看死锁日志 show engine innodb status;</p><p>（2）找出死锁 sql</p><p>（3）分析 sql 加锁情况</p><p>（4）模拟死锁案发</p><p>（5）分析死锁日志</p><p>（6）分析死锁结果</p><p>当然，这只是一个简单的流程说明，实际上生产中的死锁千奇百怪，排查和解决起来没那么简单。</p><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="MySQL-事务的四大特性说一下？"><a href="#MySQL-事务的四大特性说一下？" class="headerlink" title="MySQL 事务的四大特性说一下？"></a>MySQL 事务的四大特性说一下？</h2><p><img src="https://s2.loli.net/2023/03/28/gTseEaWtIrSGbyz.png" alt="事务四大特性"></p><center>事务四大特性</center><ul><li>原子性：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。</li><li>一致性：指在事务开始之前和事务结束以后，数据不会被破坏，假如 A 账户给 B 账户转 10 块钱，不管成功与否，A 和 B 的总金额是不变的。</li><li>隔离性：多个事务并发访问时，事务之间是相互隔离的，即一个事务不影响其它事务运行效果。简言之，就是事务之间是进水不犯河水的。</li><li>持久性：表示事务完成以后，该事务对数据库所作的操作更改，将持久地保存在数据库之中。</li></ul><h2 id="那-ACID-靠什么保证的呢？"><a href="#那-ACID-靠什么保证的呢？" class="headerlink" title="那 ACID 靠什么保证的呢？"></a>那 ACID 靠什么保证的呢？</h2><ul><li>事务的<strong>隔离性</strong>是通过数据库锁的机制实现的。</li><li>事务的<strong>一致性</strong>由 undo log 来保证：undo log 是逻辑日志，记录了事务的 insert、update、deltete 操作，回滚的时候做相反的 delete、update、insert 操作来恢复数据。</li><li>事务的<strong>原子性</strong>和<strong>持久性</strong>由 redo log 来保证：redolog 被称作重做日志，是物理日志，事务提交的时候，必须先将事务的所有日志写入 redo log 持久化，到事务的提交操作才算完成。</li></ul><p><img src="https://s2.loli.net/2023/03/28/yj7UroSRFNVxLnK.png" alt="ACID 靠什么保证"></p><center>ACID 靠什么保证</center><h2 id="事务的隔离级别有哪些？MySQL-的默认隔离级别是什么？"><a href="#事务的隔离级别有哪些？MySQL-的默认隔离级别是什么？" class="headerlink" title="事务的隔离级别有哪些？MySQL 的默认隔离级别是什么？"></a>事务的隔离级别有哪些？MySQL 的默认隔离级别是什么？</h2><p><img src="https://s2.loli.net/2023/03/28/Twar97jB4tsOJ8Q.png" alt="img"></p><p>事务的四个隔离级别</p><ul><li>读未提交（Read Uncommitted）</li><li>读已提交（Read Committed）</li><li>可重复读（Repeatable Read）</li><li>串行化（Serializable）</li></ul><p>MySQL 默认的事务隔离级别是可重复读 (Repeatable Read)。</p><h2 id="什么是幻读，脏读，不可重复读呢？"><a href="#什么是幻读，脏读，不可重复读呢？" class="headerlink" title="什么是幻读，脏读，不可重复读呢？"></a>什么是幻读，脏读，不可重复读呢？</h2><ul><li>事务 A、B 交替执行，事务 A 读取到事务 B 未提交的数据，这就是<strong>脏读</strong>。</li><li>在一个事务范围内，两个相同的查询，读取同一条记录，却返回了不同的数据，这就是<strong>不可重复读</strong>。</li><li>事务 A 查询一个范围的结果集，另一个并发事务 B 往这个范围中插入 &#x2F; 删除了数据，并静悄悄地提交，然后事务 A 再次查询相同的范围，两次读取得到的结果集不一样了，这就是<strong>幻读</strong>。</li></ul><p>不同的隔离级别，在并发事务下可能会发生的问题：</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read Uncommited 读取未提交</td><td>是</td><td>是</td><td>是</td></tr><tr><td>Read Commited 读取已提交</td><td>否</td><td>是</td><td>是</td></tr><tr><td>Repeatable Read 可重复读</td><td>否</td><td>否</td><td>是</td></tr><tr><td>Serialzable 可串行化</td><td>否</td><td>否</td><td>否</td></tr></tbody></table><h2 id="事务的各个隔离级别都是如何实现的？"><a href="#事务的各个隔离级别都是如何实现的？" class="headerlink" title="事务的各个隔离级别都是如何实现的？"></a>事务的各个隔离级别都是如何实现的？</h2><p><strong>读未提交</strong></p><p>读未提交，就不用多说了，采取的是读不加锁原理。</p><ul><li>事务读不加锁，不阻塞其他事务的读和写</li><li>事务写阻塞其他事务写，但不阻塞其他事务读；</li></ul><p><strong>读取已提交&amp;可重复读</strong></p><p>读取已提交和可重复读级别利用了<code>ReadView</code>和<code>MVCC</code>，也就是每个事务只能读取它能看到的版本（ReadView）。</p><ul><li>READ COMMITTED：每次读取数据前都生成一个 ReadView</li><li>REPEATABLE READ ：在第一次读取数据时生成一个 ReadView</li></ul><p><strong>串行化</strong></p><p>串行化的实现采用的是读写都加锁的原理。</p><p>串行化的情况下，对于同一行事务，<code>写</code>会加<code>写锁</code>，<code>读</code>会加<code>读锁</code>。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</p><h2 id="MVCC-了解吗？怎么实现的？"><a href="#MVCC-了解吗？怎么实现的？" class="headerlink" title="MVCC 了解吗？怎么实现的？"></a>MVCC 了解吗？怎么实现的？</h2><p>MVCC(Multi Version Concurrency Control)，中文名是多版本并发控制，简单来说就是通过维护数据历史版本，从而解决并发访问情况下的读一致性问题。关于它的实现，要抓住几个关键点，<strong>隐式字段、undo 日志、版本链、快照读&amp;当前读、Read View</strong>。</p><p><strong>版本链</strong></p><p>对于 InnoDB 存储引擎，每一行记录都有两个隐藏列<strong>DB_TRX_ID、DB_ROLL_PTR</strong></p><ul><li><code>DB_TRX_ID</code>，事务 ID，每次修改时，都会把该事务 ID 复制给<code>DB_TRX_ID</code>；</li><li><code>DB_ROLL_PTR</code>，回滚指针，指向回滚段的 undo 日志。</li></ul><p><img src="https://s2.loli.net/2023/03/28/5FAYvIkVxNPBKfW.png" alt="表隐藏列"></p><center>表隐藏列</center><p>假如有一张<code>user</code>表，表中只有一行记录，当时插入的事务 id 为 80。此时，该条记录的示例图如下：</p><p><img src="https://s2.loli.net/2023/03/28/e7NFrbuPGpgMJYc.png" alt="img"></p><p>接下来有两个<code>DB_TRX_ID</code>分别为<code>100</code>、<code>200</code>的事务对这条记录进行<code>update</code>操作，整个过程如下：</p><p><img src="https://s2.loli.net/2023/03/28/4azw5m8KfyEdZNT.png" alt="update 操作"></p><center>update 操作</center><p>由于每次变动都会先把<code>undo</code>日志记录下来，并用<code>DB_ROLL_PTR</code>指向<code>undo</code>日志地址。因此可以认为，<strong>对该条记录的修改日志串联起来就形成了一个<code>版本链</code>，版本链的头节点就是当前记录最新的值</strong>。如下：</p><p><img src="https://s2.loli.net/2023/03/28/zlyh8T9DWEOxJei.png" alt="MVCC"></p><center>MVCC</center><p><strong>ReadView</strong></p><blockquote><p>对于<code>Read Committed</code>和<code>Repeatable Read</code>隔离级别来说，都需要读取已经提交的事务所修改的记录，也就是说如果版本链中某个版本的修改没有提交，那么该版本的记录时不能被读取的。所以需要确定在<code>Read Committed</code>和<code>Repeatable Read</code>隔离级别下，版本链中哪个版本是能被当前事务读取的。于是就引入了<code>ReadView</code>这个概念来解决这个问题。</p></blockquote><p>Read View 就是事务执行<strong>快照读</strong>时，产生的读视图，相当于某时刻表记录的一个快照，通过这个快照，我们可以获取：</p><p><img src="https://s2.loli.net/2023/03/28/g6NSLVqFzjiDyQh.png" alt="事务和 ReadView"></p><center>事务和 ReadView</center><ul><li>m_ids ：表示在生成 ReadView 时当前系统中活跃的读写事务的事务 id 列表。</li><li>min_trx_id ：表示在生成 ReadView 时当前系统中活跃的读写事务中最小的 事务 id ，也就是 m_ids 中的最小值。</li><li>max_trx_id ：表示生成 ReadView 时系统中应该分配给下一个事务的 id 值。</li><li>creator_trx_id ：表示生成该 ReadView 的事务的 事务 id</li></ul><p>有了这个 ReadView ，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见：</p><ul><li>如果被访问版本的 DB_TRX_ID 属性值与 ReadView 中的 creator_trx_id 值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。</li><li>如果被访问版本的 DB_TRX_ID 属性值小于 ReadView 中的 min_trx_id 值，表明生成该版本的事务在当前事务生成 ReadView 前已经提交，所以该版本可以被当前事务访问。</li><li>如果被访问版本的 DB_TRX_ID 属性值大于 ReadView 中的 max_trx_id 值，表明生成该版本的事务在当前事务生成 ReadView 后才开启，所以该版本不可以被当前事务访问。</li><li>如果被访问版本的 DB_TRX_ID 属性值在 ReadView 的 min_trx_id 和 max_trx_id 之间，那就需要判断一下 trx_id 属性值是不是在 m_ids 列表中，如果在，说明创建 ReadView 时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建 ReadView 时生成该版本的事务已经被提交，该版本可以被访问。</li></ul><p>如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本。如果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录。</p><p>在 MySQL 中， READ COMMITTED 和 REPEATABLE READ 隔离级别的的一个非常大的区别就是它们生成 ReadView 的时机不同。</p><p>READ COMMITTED 是<strong>每次读取数据前都生成一个 ReadView</strong>，这样就能保证自己每次都能读到其它事务提交的数据；REPEATABLE READ 是在<strong>第一次读取数据时生成一个 ReadView</strong>，这样就能保证后续读取的结果完全一致。</p><h1 id="高可用-x2F-性能"><a href="#高可用-x2F-性能" class="headerlink" title="高可用&#x2F;性能"></a>高可用&#x2F;性能</h1><h2 id="数据库读写分离了解吗？"><a href="#数据库读写分离了解吗？" class="headerlink" title="数据库读写分离了解吗？"></a>数据库读写分离了解吗？</h2><p>读写分离的基本原理是将数据库读写操作分散到不同的节点上，下面是基本架构图：</p><p><img src="https://s2.loli.net/2023/03/28/KE89aPkZFmhL5us.png" alt="读写分离"></p><center>读写分离</center><p>读写分离的基本实现是:</p><ul><li>数据库服务器搭建主从集群，一主一从、一主多从都可以。</li><li>数据库主机负责读写操作，从机只负责读操作。</li><li>数据库主机通过复制将数据同步到从机，每台数据库服务器都存储了所有的业务数据。</li><li>业务服务器将写操作发给数据库主机，将读操作发给数据库从机。</li></ul><h2 id="那读写分离的分配怎么实现呢？"><a href="#那读写分离的分配怎么实现呢？" class="headerlink" title="那读写分离的分配怎么实现呢？"></a>那读写分离的分配怎么实现呢？</h2><p>将读写操作区分开来，然后访问不同的数据库服务器，一般有两种方式：程序代码封装和中间件封装。</p><ol><li>程序代码封装</li></ol><p>程序代码封装指在代码中抽象一个数据访问层（所以有的文章也称这种方式为 “中间层封装” ） ，实现读写操作分离和数据库服务器连接的管理。例如，基于 Hibernate 进行简单封装，就可以实现读写分离：</p><p><img src="https://s2.loli.net/2023/03/28/cl9i68PAF7qL4Yg.png" alt="业务代码封装"></p><center>业务代码封装</center><p>目前开源的实现方案中，淘宝的 TDDL (Taobao Distributed Data Layer, 外号：头都大了）是比较有名的。</p><ol><li>中间件封装</li></ol><p>中间件封装指的是独立一套系统出来，实现读写操作分离和数据库服务器连接的管理。中间件对业务服务器提供 SQL 兼容的协议，业务服务器无须自己进行读写分离。</p><p>对于业务服务器来说，访问中间件和访问数据库没有区别，事实上在业务服务器看来，中间件就是一个数据库服务器。</p><p>其基本架构是：</p><p><img src="https://s2.loli.net/2023/03/28/YhDyZUJfNj8ta6K.png" alt="数据库中间件"></p><center>数据库中间件</center><h2 id="主从复制原理了解吗？"><a href="#主从复制原理了解吗？" class="headerlink" title="主从复制原理了解吗？"></a>主从复制原理了解吗？</h2><ul><li>master 数据写入，更新 binlog</li><li>master 创建一个 dump 线程向 slave 推送 binlog</li><li>slave 连接到 master 的时候，会创建一个 IO 线程接收 binlog，并记录到 relay log 中继日志中</li><li>slave 再开启一个 sql 线程读取 relay log 事件并在 slave 执行，完成同步</li><li>slave 记录自己的 binglog</li></ul><p><img src="https://s2.loli.net/2023/03/28/bPn1RTMX68sC9cO.png" alt="主从复制"></p><center>主从复制</center><h2 id="主从同步延迟怎么处理？"><a href="#主从同步延迟怎么处理？" class="headerlink" title="主从同步延迟怎么处理？"></a>主从同步延迟怎么处理？</h2><p><strong>主从同步延迟的原因</strong></p><p>一个服务器开放Ｎ个链接给客户端来连接的，这样有会有大并发的更新操作, 但是从服务器的里面读取 binlog 的线程仅有一个，当某个 SQL 在从服务器上执行的时间稍长 或者由于某个 SQL 要进行锁表就会导致，主服务器的 SQL 大量积压，未被同步到从服务器里。这就导致了主从不一致， 也就是主从延迟。</p><p><strong>主从同步延迟的解决办法</strong></p><p>解决主从复制延迟有几种常见的方法:</p><ol><li>写操作后的读操作指定发给数据库主服务器</li></ol><p>例如，注册账号完成后，登录时读取账号的读操作也发给数据库主服务器。这种方式和业务强绑定，对业务的侵入和影响较大，如果哪个新来的程序员不知道这样写代码，就会导致一个 bug。</p><ol><li>读从机失败后再读一次主机</li></ol><p>这就是通常所说的 “二次读取” ，二次读取和业务无绑定，只需要对底层数据库访问的 API 进行封装即可，实现代价较小，不足之处在于如果有很多二次读取，将大大增加主机的读操作压力。例如，黑客暴力破解账号，会导致大量的二次读取操作，主机可能顶不住读操作的压力从而崩溃。</p><ol><li>关键业务读写操作全部指向主机，非关键业务采用读写分离</li></ol><p>例如，对于一个用户管理系统来说，注册 + 登录的业务读写操作全部访问主机，用户的介绍、爰好、等级等业务，可以采用读写分离，因为即使用户改了自己的自我介绍，在查询时却看到了自我介绍还是旧的，业务影响与不能登录相比就小很多，还可以忍受。</p><h2 id="你们一般是怎么分库的呢？"><a href="#你们一般是怎么分库的呢？" class="headerlink" title="你们一般是怎么分库的呢？"></a>你们一般是怎么分库的呢？</h2><ul><li>垂直分库：以表为依据，按照业务归属不同，将不同的表拆分到不同的库中。</li></ul><p><img src="https://s2.loli.net/2023/03/28/8JL2FsOIMluvGY9.png" alt="垂直分库"><center>垂直分库</center></p><ul><li>水平分库：以字段为依据，按照一定策略（hash、range 等），将一个库中的数据拆分到多个库中。</li></ul><p><img src="https://s2.loli.net/2023/03/28/OGDcjWQ8Hl5bPo1.png" alt="水平分库"></p><center>水平分库</center><h2 id="那你们是怎么分表的？"><a href="#那你们是怎么分表的？" class="headerlink" title="那你们是怎么分表的？"></a>那你们是怎么分表的？</h2><ul><li>水平分表：以字段为依据，按照一定策略（hash、range 等），将一个表中的数据拆分到多个表中。</li><li>垂直分表：以字段为依据，按照字段的活跃性，将表中字段拆到不同的表（主表和扩展表）中。</li></ul><p><img src="https://s2.loli.net/2023/03/28/gTlEsez8D2mLIaG.png" alt="表拆分"></p><center>表拆分</center><h2 id="水平分表有哪几种路由方式？"><a href="#水平分表有哪几种路由方式？" class="headerlink" title="水平分表有哪几种路由方式？"></a>水平分表有哪几种路由方式？</h2><p>什么是路由呢？就是数据应该分到哪一张表。</p><p>水平分表主要有三种路由方式：</p><ul><li><strong>范围路由</strong>：选取有序的数据列 （例如，整形、时间戳等） 作为路由的条件，不同分段分散到不同的数据库表中。</li></ul><p>我们可以观察一些支付系统，发现只能查一年范围内的支付记录，这个可能就是支付公司按照时间进行了分表。</p><p><img src="https://s2.loli.net/2023/03/28/eUPn5LbspJdxQNm.png" alt="范围路由"></p><center>范围路由</center><p>范围路由设计的复杂点主要体现在分段大小的选取上，分段太小会导致切分后子表数量过多，增加维护复杂度；分段太大可能会导致单表依然存在性能问题，一般建议分段大小在 100 万至 2000 万之间，具体需要根据业务选取合适的分段大小。</p><p>范围路由的优点是可以随着数据的增加平滑地扩充新的表。例如，现在的用户是 100 万，如果增加到 1000 万，只需要增加新的表就可以了，原有的数据不需要动。范围路由的一个比较隐含的缺点是分布不均匀，假如按照 1000 万来进行分表，有可能某个分段实际存储的数据量只有 1000 条，而另外一个分段实际存储的数据量有 900 万条。</p><ul><li><strong>Hash 路由</strong>：选取某个列 （或者某几个列组合也可以） 的值进行 Hash 运算，然后根据 Hash 结果分散到不同的数据库表中。</li></ul><p>同样以订单 id 为例，假如我们一开始就规划了 4 个数据库表，路由算法可以简单地用 id % 4 的值来表示数据所属的数据库表编号，id 为 12 的订单放到编号为 50 的子表中，id 为 13 的订单放到编号为 61 的字表中。</p><p><img src="https://s2.loli.net/2023/03/28/nv6wEgTN4i9BZYh.png" alt="Hash 路由"></p><center>Hash 路由</center><p>Hash 路由设计的复杂点主要体现在初始表数量的选取上，表数量太多维护比较麻烦，表数量太少又可能导致单表性能存在问题。而用了 Hash 路由后，增加子表数量是非常麻烦的，所有数据都要重分布。Hash 路由的优缺点和范围路由基本相反，Hash 路由的优点是表分布比较均匀，缺点是扩充新的表很麻烦，所有数据都要重分布。</p><ul><li><strong>配置路由</strong>：配置路由就是路由表，用一张独立的表来记录路由信息。同样以订单 id 为例，我们新增一张 order_router 表，这个表包含 orderjd 和 tablejd 两列 , 根据 orderjd 就可以查询对应的 table_id。</li></ul><p>配置路由设计简单，使用起来非常灵活，尤其是在扩充表的时候，只需要迁移指定的数据，然后修改路由表就可以了。</p><p><img src="https://s2.loli.net/2023/03/28/SVvhiks789jUGeF.png" alt="配置路由"></p><center>配置路由</center><p>配置路由的缺点就是必须多查询一次，会影响整体性能；而且路由表本身如果太大（例如，几亿条数据） ，性能同样可能成为瓶颈，如果我们再次将路由表分库分表，则又面临一个死循环式的路由算法选择问题。</p><h2 id="不停机扩容怎么实现？"><a href="#不停机扩容怎么实现？" class="headerlink" title="不停机扩容怎么实现？"></a>不停机扩容怎么实现？</h2><p>实际上，不停机扩容，实操起来是个非常麻烦而且很有风险的操作，当然，面试回答起来就简单很多。</p><ul><li><strong>第一阶段：在线双写，查询走老库</strong></li></ul><ol><li>建立好新的库表结构，数据写入久库的同时，也写入拆分的新库</li><li>数据迁移，使用数据迁移程序，将旧库中的历史数据迁移到新库</li><li>使用定时任务，新旧库的数据对比，把差异补齐</li></ol><p><img src="https://s2.loli.net/2023/03/28/Qc2AhVgI9PdqHrv.png" alt="img"></p><ul><li><strong>第二阶段：在线双写，查询走新库</strong></li></ul><ol><li>完成了历史数据的同步和校验</li><li>把对数据的读切换到新库</li></ol><p><img src="https://s2.loli.net/2023/03/28/jksZp7OqrNYCxti.png" alt="img"></p><ul><li><strong>第三阶段：旧库下线</strong></li></ul><ol><li>旧库不再写入新的数据</li><li>经过一段时间，确定旧库没有请求之后，就可以下线老库</li></ol><p><img src="https://s2.loli.net/2023/03/28/UQAVYmfuTgGCsan.png" alt="img"></p><h2 id="常用的分库分表中间件有哪些？"><a href="#常用的分库分表中间件有哪些？" class="headerlink" title="常用的分库分表中间件有哪些？"></a>常用的分库分表中间件有哪些？</h2><ul><li>sharding-jdbc</li><li>Mycat</li></ul><h2 id="那你觉得分库分表会带来什么问题呢？"><a href="#那你觉得分库分表会带来什么问题呢？" class="headerlink" title="那你觉得分库分表会带来什么问题呢？"></a>那你觉得分库分表会带来什么问题呢？</h2><p>从分库的角度来讲：</p><ul><li><strong>事务的问题</strong></li></ul><p>使用关系型数据库，有很大一点在于它保证事务完整性。</p><p>而分库之后单机事务就用不上了，必须使用分布式事务来解决。</p><ul><li><strong>跨库 JOIN 问题</strong></li></ul><p>在一个库中的时候我们还可以利用 JOIN 来连表查询，而跨库了之后就无法使用 JOIN 了。</p><p>此时的解决方案就是<strong>在业务代码中进行关联</strong>，也就是先把一个表的数据查出来，然后通过得到的结果再去查另一张表，然后利用代码来关联得到最终的结果。</p><p>这种方式实现起来稍微比较复杂，不过也是可以接受的。</p><p>还有可以<strong>适当的冗余一些字段</strong>。比如以前的表就存储一个关联 ID，但是业务时常要求返回对应的 Name 或者其他字段。这时候就可以把这些字段冗余到当前表中，来去除需要关联的操作。</p><p>还有一种方式就是<strong>数据异构</strong>，通过 binlog 同步等方式，把需要跨库 join 的数据异构到 ES 等存储结构中，通过 ES 进行查询。</p><p>从分表的角度来看：</p><ul><li><strong>跨节点的 count,order by,group by 以及聚合函数问题</strong></li></ul><p>只能由业务代码来实现或者用中间件将各表中的数据汇总、排序、分页然后返回。</p><ul><li><strong>数据迁移，容量规划，扩容等问题</strong></li></ul><p>数据的迁移，容量如何规划，未来是否可能再次需要扩容，等等，都是需要考虑的问题。</p><ul><li><strong>ID 问题</strong></li></ul><p>数据库表被切分后，不能再依赖数据库自身的主键生成机制，所以需要一些手段来保证全局主键唯一。</p><ol><li>还是自增，只不过自增步长设置一下。比如现在有三张表，步长设置为 3，三张表 ID 初始值分别是 1、2、3。这样第一张表的 ID 增长是 1、4、7。第二张表是 2、5、8。第三张表是 3、6、9，这样就不会重复了。</li><li>UUID，这种最简单，但是不连续的主键插入会导致严重的页分裂，性能比较差。</li><li>分布式 ID，比较出名的就是 Twitter 开源的 sonwflake 雪花算法</li></ol><h1 id="运维"><a href="#运维" class="headerlink" title="运维"></a>运维</h1><h2 id="百万级别以上的数据如何删除？"><a href="#百万级别以上的数据如何删除？" class="headerlink" title="百万级别以上的数据如何删除？"></a>百万级别以上的数据如何删除？</h2><p>关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件,所以当我们对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的 IO,会降低增&#x2F;改&#x2F;删的执行效率。</p><p>所以，在我们删除数据库百万级别数据的时候，查询 MySQL 官方手册得知删除数据的速度和创建的索引数量是成正比的。</p><ol><li>所以我们想要删除百万数据的时候可以先删除索引</li><li>然后删除其中无用数据</li><li>删除完成后重新创建索引创建索引也非常快</li></ol><h2 id="百万千万级大表如何添加字段？"><a href="#百万千万级大表如何添加字段？" class="headerlink" title="百万千万级大表如何添加字段？"></a>百万千万级大表如何添加字段？</h2><p>当线上的数据库数据量到达几百万、上千万的时候，加一个字段就没那么简单，因为可能会长时间锁表。</p><p>大表添加字段，通常有这些做法：</p><ul><li>通过中间表转换过去</li></ul><p>创建一个临时的新表，把旧表的结构完全复制过去，添加字段，再把旧表数据复制过去，删除旧表，新表命名为旧表的名称，这种方式可能回丢掉一些数据。</p><ul><li>用 pt-online-schema-change</li></ul><p><code>pt-online-schema-change</code>是 percona 公司开发的一个工具，它可以在线修改表结构，它的原理也是通过中间表。</p><ul><li>先在从库添加 再进行主从切换</li></ul><p>如果一张表数据量大且是热表（读写特别频繁），则可以考虑先在从库添加，再进行主从切换，切换后再将其他几个节点上添加字段。</p><h2 id="MySQL-数据库-cpu-飙升的话，要怎么处理呢？"><a href="#MySQL-数据库-cpu-飙升的话，要怎么处理呢？" class="headerlink" title="MySQL 数据库 cpu 飙升的话，要怎么处理呢？"></a>MySQL 数据库 cpu 飙升的话，要怎么处理呢？</h2><p>排查过程：</p><p>（1）使用 top 命令观察，确定是 mysqld 导致还是其他原因。</p><p>（2）如果是 mysqld 导致的，show processlist，查看 session 情况，确定是不是有消耗资源的 sql 在运行。</p><p>（3）找出消耗高的 sql，看看执行计划是否准确， 索引是否缺失，数据量是否太大。</p><p>处理：</p><p>（1）kill 掉这些线程 (同时观察 cpu 使用率是否下降)，</p><p>（2）进行相应的调整 (比如说加索引、改 sql、改内存参数)</p><p>（3）重新跑这些 SQL。</p><p>其他情况：</p><p>也有可能是每个 sql 消耗资源并不多，但是突然之间，有大量的 session 连进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等</p>]]></content>
      
      
      <categories>
          
          <category> 面渣逆袭 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面渣逆袭 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面渣逆袭-操作系统</title>
      <link href="/Blog/2023/03/18/interview/%E9%9D%A2%E6%B8%A3%E9%80%86%E8%A2%AD-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/Blog/2023/03/18/interview/%E9%9D%A2%E6%B8%A3%E9%80%86%E8%A2%AD-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="引论"><a href="#引论" class="headerlink" title="引论"></a>引论</h1><h2 id="什么是操作系统？"><a href="#什么是操作系统？" class="headerlink" title="什么是操作系统？"></a>什么是操作系统？</h2><p>可以这么说，操作系统是一种运行在内核态的软件。</p><p>它是应用程序和硬件之间的媒介，向应用程序提供硬件的抽象，以及管理硬件资源。</p><p><img src="https://s2.loli.net/2023/03/29/gyCilQhTE7AJRBD.png" alt="操作系统是什么"></p><center>操作系统是什么</center><h2 id="操作系统主要有哪些功能？"><a href="#操作系统主要有哪些功能？" class="headerlink" title="操作系统主要有哪些功能？"></a>操作系统主要有哪些功能？</h2><p>操作系统最主要的功能：</p><ul><li>处理器（CPU）管理：CPU的管理和分配，主要指的是进程管理。</li><li>内存管理：内存的分配和管理，主要利用了虚拟内存的方式。</li><li>外存管理：外存（磁盘等）的分配和管理，将外存以文件的形式提供出去。</li><li>I&#x2F;O管理：对输入&#x2F;输出设备的统一管理。</li></ul><p>除此之外，还有保证自身正常运行的健壮性管理，防止非法操作和入侵的安全性管理。</p><p><img src="https://s2.loli.net/2023/03/29/hpDk72rUL9A3cPe.png" alt="操作系统主要功能"></p><center>操作系统主要功能</center><h1 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h1><h2 id="什么是内核？"><a href="#什么是内核？" class="headerlink" title="什么是内核？"></a>什么是内核？</h2><p>可以这么说，内核是一个计算机程序，它是操作系统的核心，提供了操作系统最核心的能力，可以控制操作系统中所有的内容。</p><h2 id="什么是用户态和内核态？"><a href="#什么是用户态和内核态？" class="headerlink" title="什么是用户态和内核态？"></a>什么是用户态和内核态？</h2><p>内核具有很⾼的权限，可以控制 cpu、内存、硬盘等硬件，出于权限控制的考虑，因此⼤多数操作系统，把内存分成了两个区域：</p><ul><li>内核空间，这个内存空间只有内核程序可以访问；</li><li>⽤户空间，这个内存空间专⻔给应⽤程序使⽤，权限比较小；</li></ul><p>⽤户空间的代码只能访问⼀个局部的内存空间，⽽内核空间的代码可以访问所有内存空间。因此，当程序使⽤⽤户空间时，我们常说该程序在<strong>⽤户态</strong>执⾏，⽽当程序使内核空间时，程序则在<strong>内核态</strong>执⾏。</p><h2 id="用户态和内核态是如何切换的？"><a href="#用户态和内核态是如何切换的？" class="headerlink" title="用户态和内核态是如何切换的？"></a>用户态和内核态是如何切换的？</h2><p>应⽤程序如果需要进⼊内核空间，就需要通过系统调⽤，来进入内核态：</p><p><img src="https://s2.loli.net/2023/03/29/38EmOi2xrMaZzsv.png" alt="用户态&amp;内核态切换"></p><center>用户态&内核态切换</center><p>内核程序执⾏在内核态，⽤户程序执⾏在⽤户态。当应⽤程序使⽤系统调⽤时，会产⽣⼀个中断。发⽣中断后， CPU 会中断当前在执⾏的⽤户程序，转⽽跳转到中断处理程序，也就是开始执⾏内核程序。内核处理完后，主动触发中断，把 CPU 执⾏权限交回给⽤户程序，回到⽤户态继续⼯作。</p><h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><h2 id="并行和并发有什么区别？"><a href="#并行和并发有什么区别？" class="headerlink" title="并行和并发有什么区别？"></a>并行和并发有什么区别？</h2><p>并发就是在一段时间内，多个任务都会被处理；但在某一时刻，只有一个任务在执行。单核处理器做到的并发，其实是利用时间片的轮转，例如有两个进程A和B，A运行一个时间片之后，切换到B，B运行一个时间片之后又切换到A。因为切换速度足够快，所以宏观上表现为在一段时间内能同时运行多个程序。</p><p>并行就是在同一时刻，有多个任务在执行。这个需要多核处理器才能完成，在微观上就能同时执行多条指令，不同的程序被放到不同的处理器上运行，这个是物理上的多个进程同时进行。</p><p><img src="https://s2.loli.net/2023/03/29/PcKhbTVyeoDXvE8.png" alt="并发和并行"></p><center>并发和并行</center><h2 id="什么是进程上下文切换？"><a href="#什么是进程上下文切换？" class="headerlink" title="什么是进程上下文切换？"></a>什么是进程上下文切换？</h2><p>对于单核单线程 CPU 而言，在某一时刻只能执行一条 CPU 指令。上下文切换 (Context Switch) 是一种将 CPU 资源从一个进程分配给另一个进程的机制。从用户角度看，计算机能够并行运行多个进程，这恰恰是操作系统通过快速上下文切换造成的结果。在切换的过程中，操作系统需要先存储当前进程的状态 (包括内存空间的指针，当前执行完的指令等等)，再读入下一个进程的状态，然后执行此进程。</p><p><img src="https://s2.loli.net/2023/03/29/zoyr7UJLb54cv3X.png" alt="进程上下文切换"><center>进程上下文切换</center></p><h2 id="进程有哪些状态？"><a href="#进程有哪些状态？" class="headerlink" title="进程有哪些状态？"></a>进程有哪些状态？</h2><p>当一个进程开始运行时，它可能会经历下面这几种状态：</p><p>上图中各个状态的意义：</p><ul><li>运⾏状态（<em>Runing</em>）：该时刻进程占⽤ CPU；</li><li>就绪状态（<em>Ready</em>）：可运⾏，由于其他进程处于运⾏状态⽽暂时停⽌运⾏；</li><li>阻塞状态（<em>Blocked</em>）：该进程正在等待某⼀事件发⽣（如等待输⼊&#x2F;输出操作的完成）⽽暂时停⽌运⾏，这时，即使给它CPU控制权，它也⽆法运⾏；</li></ul><p><img src="https://s2.loli.net/2023/03/29/WVuYt8Z2fCIBNke.png" alt="进程3种状态"></p><center>进程3种状态</center><p>当然，进程还有另外两个基本状态：</p><ul><li>创建状态（<em>new</em>）：进程正在被创建时的状态；</li><li>结束状态（<em>Exit</em>）：进程正在从系统中消失时的状态；</li></ul><p><img src="https://s2.loli.net/2023/03/29/mKsAY4zXE1bwhpG.png" alt="进程5种状态">进程5种状态</p><h2 id="什么是僵尸进程？"><a href="#什么是僵尸进程？" class="headerlink" title="什么是僵尸进程？"></a>什么是僵尸进程？</h2><p>僵尸进程是已完成且处于终止状态，但在进程表中却仍然存在的进程。</p><p>僵尸进程一般发生有父子关系的进程中，一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait() 或 waitpid()，那么子进程的进程描述符仍然保存在系统中。</p><h2 id="什么是孤儿进程？"><a href="#什么是孤儿进程？" class="headerlink" title="什么是孤儿进程？"></a>什么是孤儿进程？</h2><p>一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程将被 init 进程 (进程 ID 为 1 的进程) 所收养，并由 init 进程对它们完成状态收集工作。因为孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。</p><h2 id="进程有哪些调度算法？"><a href="#进程有哪些调度算法？" class="headerlink" title="进程有哪些调度算法？"></a>进程有哪些调度算法？</h2><p>进程调度就是确定某一个时刻CPU运行哪个进程，常见的进程调度算法有：</p><p><img src="https://s2.loli.net/2023/03/29/pWTNZRMnH3cJ8wA.png" alt="进程调度算法"></p><center>进程调度算法</center><ul><li><strong>先来先服务</strong></li></ul><p>非抢占式的调度算法，按照请求的顺序进行调度。有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。另外，对I&#x2F;O密集型进程也不利，因为这种进程每次进行I&#x2F;O操作之后又得重新排队。</p><p><img src="https://s2.loli.net/2023/03/29/O3JDxZLgc9TuMAi.png" alt="先来先服务"></p><center>先来先服务</center><ul><li><strong>短作业优先</strong></li></ul><p>非抢占式的调度算法，按估计运行时间最短的顺序进行调度。长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p><p><img src="https://s2.loli.net/2023/03/29/Ae3CqI7ciS2ZWoh.png" alt="短作业优先"></p><center>短作业优先</center><ul><li><strong>优先级调度</strong></li></ul><p>为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p><p><img src="https://s2.loli.net/2023/03/29/gQLzre6ut54hjVy.png" alt="优先级调度"></p><center>优先级调度</center><ul><li><strong>时间片轮转</strong></li></ul><p>将所有就绪进程按 先来先服务的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。</p><p>时间片轮转算法的效率和时间片的大小有很大关系：因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。 而如果时间片过长，那么实时性就不能得到保证。</p><p><img src="https://s2.loli.net/2023/03/29/hseLMXm9biRa7Hl.png" alt="时间片轮转"></p><center>时间片轮转</center><ul><li><strong>最短剩余时间优先</strong></li></ul><p>最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p><h2 id="进程间通信有哪些方式？"><a href="#进程间通信有哪些方式？" class="headerlink" title="进程间通信有哪些方式？"></a>进程间通信有哪些方式？</h2><p><img src="https://s2.loli.net/2023/03/29/SPtuTVki643nFBX.png" alt="进程间通信方式"></p><center>进程间通信方式</center><ul><li><p>管道：管道可以理解成不同进程之间的对白，一方发声，一方接收，声音的介质可是是空气或者电缆，进程之间就可以通过管道，<strong>所谓的管道就是内核中的一串缓存</strong>，从管道的一端写入数据，就是缓存在了内核里，另一端读取，也是从内核中读取这段数据。</p><p>管道可以分为两类：<strong>匿名管道</strong>和<strong>命名管道</strong>。匿名管道是单向的，只能在有亲缘关系的进程间通信；命名管道是双向的，可以实现本机任意两个进程通信。</p><p><img src="https://s2.loli.net/2023/03/29/9x51ZLAuFrYGhzi.png" alt="“奉先我儿”"><center>“奉先我儿”</center></p></li><li><p>信号 ： 信号可以理解成一种电报，发送方发送内容，指定接收进程，然后发出特定的软件中断，操作系统接到中断请求后，找到接收进程，通知接收进程处理信号。</p><p>比如<code>kill -9 1050</code>就表示给PID为1050的进程发送<code>SIGKIL</code>信号。Linux系统中常用信号：</p><p>（1）SIGHUP：用户从终端注销，所有已启动进程都将收到该进程。系统缺省状态下对该信号的处理是终止进程。 （2）SIGINT：程序终止信号。程序运行过程中，按Ctrl+C键将产生该信号。 （3）SIGQUIT：程序退出信号。程序运行过程中，按Ctrl+\键将产生该信号。 （4）SIGBUS和SIGSEGV：进程访问非法地址。 （5）SIGFPE：运算中出现致命错误，如除零操作、数据溢出等。 （6）SIGKILL：用户终止进程执行信号。shell下执行kill -9发送该信号。 （7）SIGTERM：结束进程信号。shell下执行kill 进程pid发送该信号。 （8）SIGALRM：定时器信号。 （9）SIGCLD：子进程退出信号。如果其父进程没有忽略该信号也没有处理该信号，则子进程退出后将形成僵尸进程。</p></li><li><p>消息队列：<strong>消息队列就是保存在内核中的消息链表</strong>，包括Posix消息队列和System V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p></li></ul><p><img src="https://s2.loli.net/2023/03/29/YG2x18fwDq3XTci.png" alt="消息队列"></p><center>消息队列</center><ul><li>共享内存：<strong>共享内存的机制，就是拿出⼀块虚拟地址空间来，映射到相同的物理内存中</strong>。这样这个进程写⼊的东西，另外的进程⻢上就能看到。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</li></ul><p><img src="https://s2.loli.net/2023/03/29/RepXqLGrYdUwvDg.png" alt="共享内存"></p><center>共享内存</center><ul><li><p>信号量：信号量我们可以理解成红绿灯，红灯行，绿灯停。<strong>它本质上是一个整数计数器</strong>，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p><p>信号量表示资源的数量，控制信号量的⽅式有两种原⼦操作：</p><ul><li>⼀个是 <strong>P</strong> <strong>操作</strong>，这个操作会把信号量减去 1，相减后如果信号量 &lt; 0，则表明资源已被占⽤，进程需阻塞等待；相减后如果信号量 &gt;&#x3D; 0，则表明还有资源可使⽤，进程可正常继续执⾏。</li><li>另⼀个是 <strong>V</strong> <strong>操作</strong>，这个操作会把信号量加上 1，相加后如果信号量 &lt;&#x3D; 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运⾏；相加后如果信号量 &gt; 0，则表明当前没有阻塞中的进程；</li></ul><p>P 操作是⽤在进⼊共享资源之前，V 操作是⽤在离开共享资源之后，这两个操作是必须成对出现的。</p><p><img src="https://s2.loli.net/2023/03/29/LT5PqfyMkpxARZN.png" alt="信号量"><center>信号量</center></p></li><li><p>Socket：与其他通信机制不同的是，它可用于不同机器间的进程通信。</p></li></ul><p>优缺点：</p><ul><li>管道：简单；效率低，容量有限；</li><li>消息队列：不及时，写入和读取需要用户态、内核态拷贝。</li><li>共享内存区：能够很容易控制容量，速度快，但需要注意不同进程的同步问题。</li><li>信号量：不能传递复杂消息，一般用来实现进程间的同步；</li><li>信号：它是进程间通信的唯一异步机制。</li><li>Socket：用于不同主机进程间的通信。</li></ul><h2 id="进程和线程的联系和区别？"><a href="#进程和线程的联系和区别？" class="headerlink" title="进程和线程的联系和区别？"></a>进程和线程的联系和区别？</h2><p>线程和进程的联系：</p><p><strong>线程是进程当中的⼀条执⾏流程。</strong></p><p>同⼀个进程内多个线程之间可以共享代码段、数据段、打开的⽂件等资源，但每个线程各⾃都有⼀套独⽴的寄存器和栈，这样可以确保线程的控制流是相对独⽴的。</p><p><img src="https://s2.loli.net/2023/03/29/L2ozbxEi9CNOS1D.png" alt="多线程"><center>多线程</center></p><p>线程与进程的⽐较如下：</p><ul><li>调度：<strong>进程是资源（包括内存、打开的⽂件等）分配的单位</strong>，<strong>线程是 CPU 调度的单位</strong>；</li><li>资源：进程拥有⼀个完整的资源平台，⽽线程只独享必不可少的资源，如寄存器和栈；</li><li>拥有资源：线程同样具有就绪、阻塞、执⾏三种基本状态，同样具有状态之间的转换关系；</li><li>系统开销：线程能减少并发执⾏的时间和空间开销——创建或撤销进程时，系统都要为之分配或回收系统资源，如内存空间，I&#x2F;O设备等，OS所付出的开销显著大于在创建或撤销线程时的开销，进程切换的开销也远大于线程切换的开销。</li></ul><h2 id="线程上下文切换了解吗？"><a href="#线程上下文切换了解吗？" class="headerlink" title="线程上下文切换了解吗？"></a>线程上下文切换了解吗？</h2><p>这还得看线程是不是属于同⼀个进程：</p><ul><li>当两个线程不是属于同⼀个进程，则切换的过程就跟进程上下⽂切换⼀样；</li><li><strong>当两个线程是属于同⼀个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据</strong>；</li></ul><p>所以，线程的上下⽂切换相⽐进程，开销要⼩很多。</p><h2 id="线程有哪些实现方式？"><a href="#线程有哪些实现方式？" class="headerlink" title="线程有哪些实现方式？"></a>线程有哪些实现方式？</h2><p>主要有三种线程的实现⽅式：</p><ul><li><strong>内核态线程实现</strong>：在内核空间实现的线程，由内核直接管理直接管理线程。</li></ul><p><img src="https://s2.loli.net/2023/03/29/7mvZfc4kiaBqwgK.png" alt="内核态线程实现"></p><center>内核态线程实现</center><ul><li><strong>⽤户态线程实现</strong>：在⽤户空间实现线程，不需要内核的参与，内核对线程无感知。</li></ul><p><img src="https://s2.loli.net/2023/03/29/Muoi9c3zHGsELNP.png" alt="用户态线程"></p><center>用户态线程</center><ul><li><strong>混合线程实现</strong>：现代操作系统基本都是将两种方式结合起来使用。用户态的执行系统负责进程内部线程在非阻塞时的切换；内核态的操作系统负责阻塞线程的切换。即我们同时实现内核态和用户态线程管理。其中内核态线程数量较少，而用户态线程数量较多。每个内核态线程可以服务一个或多个用户态线程。</li></ul><p><img src="https://s2.loli.net/2023/03/29/HMgrNAW19hfiGxt.png" alt="混合线程实现"></p><center>混合线程实现</center><h2 id="线程间如何同步？"><a href="#线程间如何同步？" class="headerlink" title="线程间如何同步？"></a>线程间如何同步？</h2><p>同步解决的多线程操作共享资源的问题，目的是不管线程之间的执行如何穿插，最后的结果都是正确的。</p><p>我们前面知道线程和进程的关系：线程是进程当中的⼀条执⾏流程。所以说下面的一些同步机制不止针对线程，同样也可以针对进程。</p><p><strong>临界区</strong>：我们把对共享资源访问的程序片段称为<code>临界区</code>，我们希望这段代码是<code>互斥</code>的，保证在某时刻只能被一个线程执行，也就是说一个线程在临界区执行时，其它线程应该被阻止进入临界区。</p><p><img src="https://s2.loli.net/2023/03/29/OxfYXpEk13ihW7J.png" alt="临界区互斥"></p><center>临界区互斥</center><p>临界区不仅针对线程，同样针对进程。</p><p>临界区同步的一些实现方式：</p><p>1、<strong>锁</strong></p><p>使⽤加锁操作和解锁操作可以解决并发线程&#x2F;进程的互斥问题。</p><p>任何想进⼊临界区的线程，必须先执⾏加锁操作。若加锁操作顺利通过，则线程可进⼊临界区；在完成对临界资源的访问后再执⾏解锁操作，以释放该临界资源。</p><p>加锁和解锁锁住的是什么呢？可以是<code>临界区对象</code>，也可以只是一个简单的<code>互斥量</code>，例如互斥量是<code>0</code>无锁，<code>1</code>表示加锁。</p><p><img src="https://s2.loli.net/2023/03/29/4peacvz1dHEgnFh.png" alt="加锁和解锁"><center>加锁和解锁</center></p><p>根据锁的实现不同，可以分为<code>忙等待锁和</code>和<code>⽆忙等待锁</code>。</p><p><code>忙等待锁和</code>就是加锁失败的线程，会不断尝试获取锁，也被称为自旋锁，它会一直占用CPU。</p><p><code>⽆忙等待锁</code>就是加锁失败的线程，会进入阻塞状态，放弃CPU，等待被调度。</p><p>2、<strong>信号量</strong></p><p>信号量是操作系统提供的⼀种协调共享资源访问的⽅法。</p><p>通常<strong>信号量表示资源的数量</strong>，对应的变量是⼀个整型（ sem ）变量。</p><p>另外，还有<strong>两个原⼦操作的系统调⽤函数来控制信号量的</strong>，分别是：</p><ul><li><em>P</em> 操作：将 sem 减 1 ，相减后，如果 sem &lt; 0 ，则进程&#x2F;线程进⼊阻塞等待，否则继续，表明 P操作可能会阻塞；</li><li><em>V</em> 操作：将 sem 加 1 ，相加后，如果 sem &lt;&#x3D; 0 ，唤醒⼀个等待中的进程&#x2F;线程，表明 V 操作不会阻塞；</li></ul><p>P 操作是⽤在进⼊临界区之前，V 操作是⽤在离开临界区之后，这两个操作是必须成对出现的。</p><h2 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h2><p>在两个或者多个并发线程中，如果每个线程持有某种资源，而又等待其它线程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组线程产生了死锁。通俗的讲就是两个或多个线程无限期的阻塞、相互等待的一种状态。</p><p><img src="https://s2.loli.net/2023/03/29/NvMimgdk1yBGYEl.png" alt="死锁"></p><center>死锁</center><h2 id="死锁产生有哪些条件？"><a href="#死锁产生有哪些条件？" class="headerlink" title="死锁产生有哪些条件？"></a>死锁产生有哪些条件？</h2><p>死锁产生需要<strong>同时</strong>满足四个条件：</p><ul><li><strong>互斥条件</strong>：指线程对己经获取到的资源进行它性使用，即该资源同时只由一个线程占用。如果此时还有其它线程请求获取获取该资源，则请求者只能等待，直至占有资源的线程释放该资源。</li><li><strong>请求并持有条件</strong>：指一个 线程己经持有了至少一个资源，但又提出了新的资源请求，而新资源己被其它线程占有，所以当前线程会被阻塞，但阻塞 的同时并不释放自己已经获取的资源。</li><li><strong>不可剥夺条件</strong>：指线程获取到的资源在自己使用完之前不能被其它线程抢占，只有在自己使用完毕后才由自己释放该资源。</li><li><strong>环路等待条件</strong>：指在发生死锁时，必然存在一个线程——资源的环形链，即线程集合 {T0，T1，T2,…… ，Tn} 中 T0 正在等待一 T1 占用的资源，Tl1正在等待 T2用的资源，…… Tn 在等待己被 T0占用的资源。</li></ul><h2 id="如何避免死锁呢？"><a href="#如何避免死锁呢？" class="headerlink" title="如何避免死锁呢？"></a>如何避免死锁呢？</h2><p>产⽣死锁的有四个必要条件：互斥条件、持有并等待条件、不可剥夺条件、环路等待条件。</p><p>避免死锁，破坏其中的一个就可以。</p><p><strong>消除互斥条件</strong></p><p>这个是没法实现，因为很多资源就是只能被一个线程占用，例如锁。</p><p><strong>消除请求并持有条件</strong></p><p>消除这个条件的办法很简单，就是一个线程一次请求其所需要的所有资源。</p><p><strong>消除不可剥夺条件</strong></p><p>占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源，这样不可剥夺这个条件就破坏掉了。</p><p><strong>消除环路等待条件</strong></p><p>可以靠按序申请资源来预防。所谓按序申请，是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后就不存在环路了。</p><h2 id="活锁和饥饿锁了解吗？"><a href="#活锁和饥饿锁了解吗？" class="headerlink" title="活锁和饥饿锁了解吗？"></a>活锁和饥饿锁了解吗？</h2><p><strong>饥饿锁：</strong></p><p>饥饿锁，这个饥饿指的是资源饥饿，某个线程一直等不到它所需要的资源，从而无法向前推进，就像一个人因为饥饿无法成长。</p><p><strong>活锁：</strong></p><p>在活锁状态下，处于活锁线程组里的线程状态可以改变，但是整个活锁组的线程无法推进。</p><p>活锁可以用两个人过一条很窄的小桥来比喻：为了让对方先过，两个人都往旁边让，但两个人总是让到同一边。这样，虽然两个人的状态一直在变化，但却都无法往前推进。</p><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="什么是虚拟内存？"><a href="#什么是虚拟内存？" class="headerlink" title="什么是虚拟内存？"></a>什么是虚拟内存？</h2><p>我们实际的物理内存主要是主存，但是物理主存空间有限，所以一般现代操作系统都会想办法把一部分内存块放到磁盘中，用到的时候再装入主存，但是对用户程序而言，是不需要注意实际的物理内存的，为什么呢？因为有<code>虚拟内存</code>的机制。</p><p><strong>简单说，虚拟内存是操作系统提供的⼀种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来。</strong></p><p>每个进程都有自己独立的地址空间，再由操作系统映射到到实际的物理内存。</p><p>于是，这⾥就引出了两种地址的概念：</p><p>程序所使⽤的内存地址叫做<strong>虚拟内存地址</strong>（<em>Virtual Memory Address</em>）</p><p>实际存在硬件⾥⾯的空间地址叫<strong>物理内存地址</strong>（<em>Physical Memory Address</em>）。</p><p><img src="https://s2.loli.net/2023/03/29/EbJtFSvMz1OHAhi.png" alt="虚拟内存"><center>虚拟内存</center></p><h2 id="什么是内存分段？"><a href="#什么是内存分段？" class="headerlink" title="什么是内存分段？"></a>什么是内存分段？</h2><p>程序是由若⼲个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。不同的段是有不同的属性的，所以就⽤分段（Segmentation）的形式把这些段分离出来。</p><p>分段机制下的虚拟地址由两部分组成，<strong>段号</strong>和<strong>段内偏移量</strong>。</p><p>虚拟地址和物理地址通过段表映射，段表主要包括<strong>段号</strong>、<code>段的界限</code>。</p><p><img src="https://s2.loli.net/2023/03/29/ejPAvLs5YoZXG9F.png" alt="虚拟地址、段表、物理地址"></p><center>虚拟地址、段表、物理地址</center><p>我们来看一个映射，虚拟地址：段3、段偏移量500 —-&gt; 段基地址7000+段偏移量500 —-&gt; 物理地址：7500。</p><p><img src="https://s2.loli.net/2023/03/29/uFIePxiB8ZmzhjY.png" alt="段虚拟地址映射"></p><center>段虚拟地址映射</center><h2 id="什么是内存分页？"><a href="#什么是内存分页？" class="headerlink" title="什么是内存分页？"></a>什么是内存分页？</h2><p><strong>分⻚是把整个虚拟和物理内存空间切成⼀段段固定尺⼨的⼤⼩</strong>。这样⼀个连续并且尺⼨固定的内存空间，我们叫<strong>⻚</strong>（<em>Page</em>）。在 Linux 下，每⼀⻚的⼤⼩为 4KB 。</p><p>访问分页系统中内存数据需要两次的内存访问 ：一次是从内存中访问页表，从中找到指定的物理页号，加上页内偏移得到实际物理地址，第二次就是根据第一次得到的物理地址访问内存取出数据。</p><p><img src="https://s2.loli.net/2023/03/29/tfNAF8iJI1gjGmc.png" alt="内存分页"></p><center>内存分页</center><h2 id="多级页表知道吗？"><a href="#多级页表知道吗？" class="headerlink" title="多级页表知道吗？"></a>多级页表知道吗？</h2><p>操作系统可能会有非常多进程，如果只是使用简单分页，可能导致的后果就是页表变得非常庞大。</p><p>所以，引入了多级页表的解决方案。</p><p>所谓的多级页表，就是把我们原来的单级页表再次分页，这里利用了<code>局部性原理</code>，除了顶级页表，其它级别的页表一来可以在需要的时候才被创建，二来内存紧张的时候还可以被置换到磁盘中。</p><p><img src="https://s2.loli.net/2023/03/29/7WIJYECt4BauFyo.png" alt="多级页表示意图"></p><center>多级页表示意图</center><h2 id="什么是块表？"><a href="#什么是块表？" class="headerlink" title="什么是块表？"></a>什么是块表？</h2><p>同样利用了<code>局部性原理</code>，即在⼀段时间内，整个程序的执⾏仅限于程序中的某⼀部分。相应地，执⾏所访问的存储空间也局限于某个内存区域。</p><p>利⽤这⼀特性，把最常访问的⼏个⻚表项存储到访问速度更快的硬件，于是计算机科学家们，就在 CPU 芯⽚中，加⼊了⼀个专⻔存放程序最常访问的⻚表项的 Cache，这个 Cache 就是 TLB（<em>Translation Lookaside Buffer</em>） ，通常称为⻚表缓存、转址旁路缓存、快表等。</p><p><img src="https://s2.loli.net/2023/03/29/cOGxkRXmgiynfZH.png" alt="TLB示意图">TLB示意图-来源参考[3]</p><h2 id="分页和分段有什么区别？"><a href="#分页和分段有什么区别？" class="headerlink" title="分页和分段有什么区别？"></a>分页和分段有什么区别？</h2><ul><li>段是信息的逻辑单位，它是根据用户的需要划分的，因此段对用户是可见的 ；页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的。</li><li>段的大小不固定，有它所完成的功能决定；页的大小固定，由系统决定</li><li>段向用户提供二维地址空间；页向用户提供的是一维地址空间</li><li>段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制。</li></ul><h2 id="什么是交换空间？"><a href="#什么是交换空间？" class="headerlink" title="什么是交换空间？"></a>什么是交换空间？</h2><p>操作系统把物理内存(Physical RAM)分成一块一块的小内存，每一块内存被称为页(page)。当内存资源不足时，Linux把某些页的内容转移至磁盘上的一块空间上，以释放内存空间。磁盘上的那块空间叫做交换空间(swap space),而这一过程被称为交换(swapping)。物理内存和交换空间的总容量就是虚拟内存的可用容量。</p><p>用途：</p><ul><li>物理内存不足时一些不常用的页可以被交换出去，腾给系统。</li><li>程序启动时很多内存页被用来初始化，之后便不再需要，可以交换出去。</li></ul><h2 id="页面置换算法有哪些？"><a href="#页面置换算法有哪些？" class="headerlink" title="页面置换算法有哪些？"></a>页面置换算法有哪些？</h2><p>在分页系统里，一个虚拟的页面可能在主存里，也可能在磁盘中，如果CPU发现虚拟地址对应的物理页不在主存里，就会产生一个缺页中断，然后从磁盘中把该页调入主存中。</p><p>如果内存里没有空间，就需要从主存里选择一个页面来置换。</p><p>常见的页面置换算法：</p><p><img src="https://s2.loli.net/2023/03/29/AfFWGKHiEy3Snw1.png" alt="常见页面置换算法"></p><center>常见页面置换算法</center><ul><li><strong>最佳⻚⾯置换算法（*OPT*）</strong></li></ul><p>最佳⻚⾯置换算法是一个理想的算法，基本思路是，<strong>置换在未来最⻓时间不访问的⻚⾯</strong>。</p><p>所以，该算法实现需要计算内存中每个逻辑⻚⾯的下⼀次访问时间，然后⽐较，选择未来最⻓时间不访问的⻚⾯。</p><p>但这个算法是无法实现的，因为当缺页中断发生时，操作系统无法知道各个页面下一次将在什么时候被访问。</p><ul><li><strong>先进先出置换算法（FIFO）</strong></li></ul><p>既然我们⽆法预知⻚⾯在下⼀次访问前所需的等待时间，那可以<strong>选择在内存驻留时间很⻓的⻚⾯进⾏中置换</strong>，这个就是「先进先出置换」算法的思想。</p><p>FIFO的实现机制是使用链表将所有在内存的页面按照进入时间的早晚链接起来，然后每次置换链表头上的页面就行了，新加进来的页面则挂在链表的末端。</p><p><img src="https://s2.loli.net/2023/03/29/U3HyJFNZEYLnfga.png" alt="按照进入内存早晚构建的页面链表 "></p><center>按照进入内存早晚构建的页面链表</center><ul><li><strong>最近最久未使⽤的置换算法（LRU）</strong></li></ul><p>最近最久未使⽤（<em>LRU</em>）的置换算法的基本思路是，发⽣缺⻚时，<strong>选择最⻓时间没有被访问的⻚⾯进⾏置换</strong>，也就是说，该算法假设已经很久没有使⽤的⻚⾯很有可能在未来较⻓的⼀段时间内仍然不会被使⽤。</p><p>这种算法近似最优置换算法，最优置换算法是通过「未来」的使⽤情况来推测要淘汰的⻚⾯，⽽ LRU 则是通过<code>历史</code>的使⽤情况来推测要淘汰的⻚⾯。</p><p>LRU 在理论上是可以实现的，但代价很⾼。为了完全实现 LRU，需要在内存中维护⼀个所有⻚⾯的链表，最近最多使⽤的⻚⾯在表头，最近最少使⽤的⻚⾯在表尾。</p><p><img src="https://s2.loli.net/2023/03/29/nXNMLQKcWqi5r1P.png" alt="LRU实现"></p><center>LRU实现</center><p>困难的是，在每次访问内存时都必须要更新整个链表。在链表中找到⼀个⻚⾯，删除它，然后把它移动到表头是⼀个⾮常费时的操作。</p><p>所以，LRU 虽然看上去不错，但是由于开销⽐较⼤，实际应⽤中⽐较少使⽤。</p><ul><li><strong>时钟页面置换算法</strong></li></ul><p>这个算法的思路是，把所有的⻚⾯都保存在⼀个类似钟⾯的环形链表中，⼀个表针指向最⽼的⻚⾯。</p><p><img src="https://s2.loli.net/2023/03/29/VW3amxjln9TMFt2.png" alt="时钟页面置换算法"></p><center>时钟页面置换算法</center><p>当发⽣缺⻚中断时，算法⾸先检查表针指向的⻚⾯：</p><p>如果它的访问位位是 0 就淘汰该⻚⾯，并把新的⻚⾯插⼊这个位置，然后把表针前移⼀个位置；</p><p>如果访问位是 1 就清除访问位，并把表针前移⼀个位置，重复这个过程直到找到了⼀个访问位为 0 的⻚⾯为⽌；</p><ul><li><strong>最不常⽤置换算法</strong></li></ul><p>最不常用算法（LFU），<strong>当发⽣缺⻚中断时，选择访问次数最少的那个⻚⾯，将其置换</strong>。</p><p>它的实现⽅式是，对每个⻚⾯设置⼀个「访问计数器」，每当⼀个⻚⾯被访问时，该⻚⾯的访问计数器就累加 1。在发⽣缺⻚中断时，淘汰计数器值最⼩的那个⻚⾯。</p><h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><h2 id="硬链接和软链接有什么区别？"><a href="#硬链接和软链接有什么区别？" class="headerlink" title="硬链接和软链接有什么区别？"></a>硬链接和软链接有什么区别？</h2><ul><li>硬链接就是在目录下创建一个条目，记录着文件名与 inode 编号，这个 inode 就是源文件的 inode。删除任意一个条目，文件还是存在，只要引用数量不为 0。但是硬链接有限制，它不能跨越文件系统，也不能对目录进行链接。</li></ul><p><img src="https://s2.loli.net/2023/03/29/i7KCD9YJb2FdRlf.png" alt="硬链接"></p><center>硬链接</center><ul><li><p>软链接相当于重新创建⼀个⽂件，这个⽂件有<strong>独⽴的</strong> <strong>inode</strong>，但是这个<strong>⽂件的内容是另外⼀个⽂件的路径</strong>，所以访问软链接的时候，实际上相当于访问到了另外⼀个⽂件，所以<strong>软链接是可以跨⽂件系统的</strong>，甚⾄<strong>⽬标⽂件被删除了，链接⽂件还是在的，只不过打不开指向的文件了而已。</strong></p><p><img src="https://s2.loli.net/2023/03/29/FADxud5Qi9JeNK6.png" alt="软链接"><center>软链接</center></p></li></ul><h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><h2 id="零拷贝了解吗？"><a href="#零拷贝了解吗？" class="headerlink" title="零拷贝了解吗？"></a>零拷贝了解吗？</h2><p>假如需要文件传输，使用传统I&#x2F;O，数据读取和写入是用户空间到内核空间来回赋值，而内核空间的数据是通过操作系统的I&#x2F;O接口从磁盘读取或者写入，这期间发生了多次用户态和内核态的上下文切换，以及多次数据拷贝。</p><p><img src="https://s2.loli.net/2023/03/29/YK28iENRQmlCdvX.png" alt="传统文件传输示意图"></p><center>传统文件传输示意图</center><p>为了提升I&#x2F;O性能，就需要<strong>减少用户态与内核态的上下文切换</strong>和<strong>内存拷贝的次数</strong>。</p><p>这就用到了我们零拷贝的技术，零拷贝技术实现主要有两种：</p><ul><li><strong>mmap + write</strong></li></ul><p>mmap() 系统调⽤函数会直接把内核缓冲区⾥的数据「<strong>映射</strong>」到⽤户空间，这样，操作系统内核与⽤户空间就不需要再进⾏任何的数据拷⻉操作。</p><p><img src="https://s2.loli.net/2023/03/29/ylt5MW1F6PNwG9J.png" alt="mmap示意图"><center>mmap示意图</center></p><ul><li><strong>sendfile</strong></li></ul><p>在 Linux 内核版本 2.1 中，提供了⼀个专⻔发送⽂件的系统调⽤函数 sendfile() 。</p><p>⾸先，它可以替代前⾯的 read() 和 write() 这两个系统调⽤，这样就可以减少⼀次系统调⽤，也就减少了 2 次上下⽂切换的开销。</p><p>其次，该系统调⽤，可以直接把内核缓冲区⾥的数据拷⻉到 socket 缓冲区⾥，不再拷⻉到⽤户态，这样就只有 2 次上下⽂切换，和 3 次数据拷⻉。</p><p><img src="https://s2.loli.net/2023/03/29/Kx9PrjyAgLXQvhJ.png" alt="sendfile示意图"><center>sendfile示意图</center></p><p>很多开源项目如Kafka、RocketMQ都采用了零拷贝技术来提升IO效率。</p><h2 id="聊聊阻塞与⾮阻塞-I-x2F-O-、-同步与异步-I-x2F-O？"><a href="#聊聊阻塞与⾮阻塞-I-x2F-O-、-同步与异步-I-x2F-O？" class="headerlink" title="聊聊阻塞与⾮阻塞 **I&#x2F;O **、 同步与异步 I&#x2F;O？"></a>聊聊<strong>阻塞与⾮阻塞</strong> **I&#x2F;O **、 <strong>同步与异步</strong> <strong>I&#x2F;O</strong>？</h2><ul><li><strong>阻塞I&#x2F;O</strong></li></ul><p>先来看看<strong>阻塞</strong> <strong>I&#x2F;O</strong>，当⽤户程序执⾏ read ，线程会被阻塞，⼀直等到内核数据准备好，并把数据从内核缓冲区拷⻉到应⽤程序的缓冲区中，当拷⻉过程完成， read 才会返回。</p><p>注意，<strong>阻塞等待的是<code>内核数据准备好</code>和<code>数据从内核态拷⻉到⽤户态</code>这两个过程</strong>。</p><p><img src="https://s2.loli.net/2023/03/29/Wx6nIkUKPzvOYpo.png" alt="阻塞I/O"><center>阻塞I&#x2F;O</center></p><ul><li><strong>非阻塞I&#x2F;O</strong></li></ul><p>⾮阻塞的 read 请求在数据未准备好的情况下⽴即返回，可以继续往下执⾏，此时应⽤程序不断轮询内核，直到数据准备好，内核将数据拷⻉到应⽤程序缓冲区， read 调⽤才可以获取到结果。</p><p><img src="https://s2.loli.net/2023/03/29/XSnhkQGMHN1a83d.png" alt="非阻塞I/O"><center>非阻塞I&#x2F;O</center></p><ul><li><strong>基于非阻塞的I&#x2F;O多路复用</strong></li></ul><p>我们上面的非阻塞I&#x2F;O有一个问题，什么问题呢？应用程序要一直轮询，这个过程没法干其它事情，所以引入了<strong>I&#x2F;O</strong> <strong>多路复⽤</strong>技术。</p><p>当内核数据准备好时，以事件通知应⽤程序进⾏操作。</p><p><img src="https://s2.loli.net/2023/03/29/YmyF8x6fqZRMhHw.png" alt="基于非阻塞的I/O多路复用"><center>基于非阻塞的I&#x2F;O多路复用</center></p><p>**注意：**⽆论是阻塞 I&#x2F;O、还是⾮阻塞 I&#x2F;O、非阻塞I&#x2F;O多路复用，都是同步调⽤。因为它们在read调⽤时，内核将数据从内核空间拷⻉到应⽤程序空间，过程都是需要等待的，也就是说这个过程是**同步**的，如果内核实现的拷⻉效率不⾼，read调⽤就会在这个同步过程中等待⽐较⻓的时间。</p><ul><li><strong>异步I&#x2F;O</strong></li></ul><p>真正的<strong>异步</strong> <strong>I&#x2F;O</strong> 是<code>内核数据准备好</code>和<code>数据从内核态拷⻉到⽤户态</code>这两个过程都不⽤等待。</p><p>发起 aio_read 之后，就⽴即返回，内核⾃动将数据从内核空间拷⻉到应⽤程序空间，这个拷⻉过程同样是异步的，内核⾃动完成的，和前⾯的同步操作不⼀样，应⽤程序并不需要主动发起拷⻉动作。</p><p><img src="https://s2.loli.net/2023/03/29/XzI3moNUMBQdjl2.png" alt="异步/IO"></p><center>异步/IO</center><blockquote><p>拿例子理解几种I&#x2F;O模型</p></blockquote><p>老三关注了很多UP主，有些UP主是老鸽子，到了更新的时间：</p><p>阻塞I&#x2F;O就是，老三不干别的，就干等着，盯着UP的更新。</p><p>非阻塞I&#x2F;O就是，老三发现UP没更，就去喝个茶什么的，过一会儿来盯一次，一直等到UP更新。</p><p>基于⾮阻塞的 I&#x2F;O 多路复⽤好⽐，老三发现UP没更，就去干别的，过了一会儿B站推送消息了，老三一看，有很多条，就去翻动态，看看等的UP是不是更新了。</p><p>异步I&#x2F;O就是，老三说UP你该更了，UP赶紧爆肝把视频做出来，然后把视频亲自呈到老三面前，这个过程不用等待。</p><p><img src="https://s2.loli.net/2023/03/29/61oquOEZsyKQiXR.png" alt="鸽宗"><center>鸽宗</center></p><h2 id="详细讲一讲I-x2F-O多路复用？"><a href="#详细讲一讲I-x2F-O多路复用？" class="headerlink" title="详细讲一讲I&#x2F;O多路复用？"></a>详细讲一讲I&#x2F;O多路复用？</h2><blockquote><p>我们先了解什么是I&#x2F;O多路复用？</p></blockquote><p>我们在传统的I&#x2F;O模型中，如果服务端需要支持多个客户端，我们可能要为每个客户端分配一个进程&#x2F;线程。</p><p>不管是基于重一点的进程模型，还是轻一点的线程模型，假如连接多了，操作系统是扛不住的。</p><p>所以就引入了<strong>I&#x2F;O多路复用</strong> 技术。</p><p>简单说，就是一个进程&#x2F;线程维护多个Socket，这个多路复用就是多个连接复用一个进程&#x2F;线程。</p><p><img src="https://s2.loli.net/2023/03/29/GAkZRerxNI8sPcB.png" alt="I/O多路复用"></p><center>I/O多路复用</center><p>我们来看看I&#x2F;O多路复用三种实现机制：</p><ul><li><strong>select</strong></li></ul><p>select 实现多路复⽤的⽅式是：</p><p>将已连接的 Socket 都放到⼀个<strong>⽂件描述符集合</strong>fd_set，然后调⽤ select 函数将fd_set集合拷⻉到内核⾥，让内核来检查是否有⽹络事件产⽣，检查的⽅式很粗暴，就是通过遍历fd_set的⽅式，当检查到有事件产⽣后，将此 Socket 标记为可读或可写， 接着再把整个fd_set拷⻉回⽤户态⾥，然后⽤户态还需要再通过遍历的⽅法找到可读或可写的 Socket，再对其处理。</p><p>select 使⽤固定⻓度的 BitsMap，表示⽂件描述符集合，⽽且所⽀持的⽂件描述符的个数是有限制的，在Linux 系统中，由内核中的 FD_SETSIZE 限制， 默认最⼤值为 1024 ，只能监听 0~1023 的⽂件描述符。</p><blockquote><p>select机制的缺点：</p></blockquote><p>（1）每次调用select，都需要把fd_set集合从用户态拷贝到内核态，如果fd_set集合很大时，那这个开销也很大，比如百万连接却只有少数活跃连接时这样做就太没有效率。</p><p>（2）每次调用select都需要在内核遍历传递进来的所有fd_set，如果fd_set集合很大时，那这个开销也很大。</p><p>（3）为了减少数据拷贝带来的性能损坏，内核对被监控的fd_set集合大小做了限制，一般为1024，如果想要修改会比较麻烦，可能还需要编译内核。</p><p>（4）每次调用select之前都需要遍历设置监听集合，重复工作。</p><ul><li><strong>poll</strong></li></ul><p>poll 不再⽤ BitsMap 来存储所关注的⽂件描述符，取⽽代之⽤动态数组，以链表形式来组织，突破了select 的⽂件描述符个数限制，当然还会受到系统⽂件描述符限制。</p><p>但是 poll 和 select 并没有太⼤的本质区别，都是使⽤线性结构存储进程关注的Socket集合，因此都需要遍历⽂件描述符集合来找到可读或可写的Socke，时间复杂度为O(n)，⽽且也需要在⽤户态与内核态之间拷⻉⽂件描述符集合，这种⽅式随着并发数上来，性能的损耗会呈指数级增⻓。</p><ul><li><strong>epoll</strong></li></ul><p>epoll 通过两个⽅⾯，很好解决了 select&#x2F;poll 的问题。</p><p>第⼀点，epoll 在内核⾥使⽤<strong>红⿊树来跟踪进程所有待检测的⽂件描述字</strong>，把需要监控的 socket 通过epoll_ctl() 函数加⼊内核中的红⿊树⾥，红⿊树是个⾼效的数据结构，增删查⼀般时间复杂度是O(logn) ，通过对这棵⿊红树进⾏操作，这样就不需要像 select&#x2F;poll 每次操作时都传⼊整个 socket 集合，只需要传⼊⼀个待检测的 socket，<strong>减少了内核和⽤户空间⼤量的数据拷⻉和内存分配</strong>。</p><p>第⼆点， epoll 使⽤事件驱动的机制，内核⾥<strong>维护了⼀个链表来记录就绪事件</strong>，当某个 socket 有事件发⽣时，通过回调函数，内核会将其加⼊到这个就绪事件列表中，当⽤户调⽤ epoll_wait() 函数时，只会返回有事件发⽣的⽂件描述符的个数，不需要像 select&#x2F;poll 那样轮询扫描整个 socket 集合，⼤⼤提⾼了检测的效率。</p><p><img src="https://s2.loli.net/2023/03/29/IwiF9K5TfS6JERA.png" alt="epoll接口作用"></p><center>epoll接口作用</center><p>epoll 的⽅式即使监听的 Socket 数量越多的时候，效率不会⼤幅度降低，能够同时监听的 Socket 的数⽬也⾮常的多了，上限就为系统定义的进程打开的最⼤⽂件描述符个数。因⽽，<strong>epoll</strong> <strong>被称为解决</strong> <strong>C10K</strong> <strong>问题的利器</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 面渣逆袭 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面渣逆袭 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
